

Table of Contents

Preface

1

Chapter 1: Basics of Rust

6

Getting to know Rust

7

Installing Rust

8

Windows

8

Linux/Mac

8

Test your installation

10

Documentation and reference

11

Main function

11

Variables

11

Built-in data types

12

Integer types

13

Floating-point types

13

Boolean type

13

Character type

13

Control flow

14

Writing a condition

14

Creating while loops

14

Creating functions

15

Creating structures

15

References

17

Clone types

18

Copy types

19

Mutable references

20

Methods

20

Constructors

21

Tuples

22

Enumerations

22

Pattern matching

23

Irrefutable patterns

25

Traits

25

Default methods

27

Associated types

27

Rules

28

Table of Contents

Generics

29

The Option type

29

Arrays

30

Slices

30

For loops

31

Macros

33

Multiple pattern rules

34

Repetitions

35

Optional quantifier

37

Summary

38

Chapter 2: Starting with SDL

39

Understanding Rust crates

39

Installing SDL2

39

Installing SDL2 on Linux

39

Installing SDL2 on Mac

40

Installing SDL2 on Windows

40

Windows with Build Script

40

Windows (MinGW)

42

Windows (MSVC)

43

Setting up your Rust project

44

Cargo and crates.io

45

The docs.rs documentation

47

Back to our Cargo.toml file

48

Rust's modules

49

Tetris

51

Creating a window

52

Drawing

54

Playing with Options

60

Solution

61

Loading images

64

Installing SDL2_image on Mac

64

Installing SDL2_image on Linux

64

Installing SDL2_image on Windows

65

Playing with features

65

Playing with images

66

Handling files

69

Saving/loading high scores

72

Iterators

72

Reading formatted data from files

74

Summary

77

[ ii ]

Table of Contents

Chapter 3: Events and Basic Game Mechanisms

78

Writing Tetris

78

Tetrimino

79

Creating tetriminos

83

Generating a tetrimino

89

Rotating a tetrimino

91

Tetris struct

95

Interacting with the game map

99

SDL events

102

Score, level, lines sent

110

Levels and lines sent

113

Highscores loading/overwriting

114

Summary

128

Chapter 4: Adding All Game Mechanisms

129

Getting started with game mechanisms

129

Rendering UI

129

Rendering initialization

130

Rendering

133

Playing with fonts

140

Install on OS X

141

Install on Linux

141

Other system/package manager

141

Loading font

142

Summary

147

Chapter 5: Creating a Music Player

148

Installing the prerequisite

148

Installing GTK+ on Linux

149

Installing GTK+ on Mac

149

Installing GTK+ on Windows

149

Creating your first window

149

Closure

152

Preventing the default behavior of an event

153

Creating a toolbar

153

Stock item

155

Improving the organization of the application

156

Adding tool button events

159

Lifetime

161

Ownership

165

Containers

166

[ iii ]

Table of Contents

Types of containers

166

The Box container

167

Adding a playlist

169

The MVC pattern

171

Opening MP3 files

175

Reference-counting pointer

176

ID3â€” MP3 metadata

177

Opening files with a file dialog

178

Deleting a song

180

Displaying the cover when playing a song

181

Summary

182

Chapter 6: Implementing the Engine of the Music Player 183

Installing the dependencies

184

Installing dependencies on Linux

184

Installing dependencies on Mac

184

Installing dependencies on Windows

184

Decoding MP3 files

185

Adding dependencies

185

Implementing an MP3 decoder

185

Getting the frame samples

189

Playing music

190

Event loop

191

Atomic reference counting

192

Mutual exclusion

193

Send trait

193

Sync trait

193

Lock-free data structures

193

Playing music

196

Mutex guard

198

RAII

198

Using the music player

200

Pausing and resuming the song

201

Interior mutability

202

Showing the progression of the song

209

Improving CPU usage

213

Condition variable

214

Showing the song's current time

216

Loading and saving the playlist

220

Saving a playlist

220

Loading a playlist

223

[ iv ]

Table of Contents

Using gstreamer for playback

226

Summary

230

Chapter 7: Music Player in a More Rusty Way with Relm 231

Reasons to use relm instead of gtk-rs directly

232

State mutation

232

Asynchronous user interface

233

Creating custom widgets

233

Creating a window with relm

234

Installing Rust nightly

235

Widget

236

Model

236

Messages

236

View

237

Properties

238

Events

238

Code generation

238

Update function

239

Adding child widgets

240

One-way data binding

243

Post-initialization of the view

244

Dialogs

248

Other methods

250

Playlist

252

Model parameter

253

Adding a relm widget

259

Communicating between widgets

260

Communicating with the same widget

260

Emit

261

With different widgets

262

Handle messages from a relm widget

264

Syntax sugar to send a message to another relm widget 265

Playing music

269

Computing the song duration

279

Using relm on stable Rust

283

Relm widgets data binding

285

Summary

287

Chapter 8: Understanding FTP

288

File transfer protocol

288

Introduction to FTP

289

[ v ]

Table of Contents

Implementing simple chunks of commands

290

Starting with basics

292

Commands implementation

300

Implementing the SYST command

300

Implementing the USER command

301

Implementing the NOOP command

303

Implementing the PWD command

304

Implementing the TYPE command

304

Implementing the LIST command

305

Implementing the PASV command

305

Back to the LIST command

308

Implementing the CWD command

311

Implementing the CDUP command

315

Full implementation of the LIST command

315

Implementing the MKD command

318

Implementing the RMD command

319

Testing it

320

Summary

321

Chapter 9: Implementing an Asynchronous FTP Server 322

Advantages of asynchronous IO

322

Disadvantages of asynchronous IO

322

Creating the new project

323

Using Tokio

328

Tokio event loop

329

Using futures

329

Handling errors

329

Unwrapping

329

Custom error type

330

Displaying the error

330

Composing error types

332

The ? operator, revisited

334

Starting the Tokio event loop

334

Starting the server

335

Handling clients

337

Handling commands

338

FTP codec

339

Decoding FTP commands

340

Encoding FTP commands

341

Handling commands

342

Managing the current working directory

344

Printing the current directory

344

Changing the current directory

345

[ vi ]

Table of Contents

Setting the transfer type

348

Entering passive mode

350

Bytes codec

353

Decoding data bytes

353

Encoding data bytes

354

Quitting

354

Creating directories

355

Removing directories

356

Summary

357

Chapter 10: Implementing Asynchronous File Transfer 358

Listing files

358

Downloading a file

364

Uploading files

367

Going further!

369

Configuration

369

Securing the config.toml access

381

Unit tests

382

Backtraces

385

Testing failures

386

Ignoring tests

387

Integration tests

389

Teardown

390

Print output to stdout

393

Documentation

393

Documenting a crate

394

Documenting a module

394

Headers

394

Code blocks

395

Documenting an enumeration (or any type with public fields) 395

Generating the documentation

396

Warning about public items without documentation

397

Hiding items from the documentation

398

Documentation tests

398

Tags

398

ignore

399

compile_fail

400

no_run

401

should_panic

402

Combining flags?

402

About the doc blocks themselves

403

[ vii ]

Table of Contents

Hiding code blocks lines

403

Fuzzing tests

404

Summary

411

Chapter 11: Rust Best Practices

412

Rust best practices

412

Slices

412

API tips and improvements

414

Explaining the Some function

414

Using the Path function

415

Usage tips

416

Builder pattern

416

Playing with mutable borrows

417

Playing with moves

418

Code readability

418

Big number formatting

418

Specifying types

419

Matching

420

Summary

420

Other Books You May Enjoy

421

Index

424

[ viii ]





Preface

The aim of this book is to give a little tour of some Rust basics (playing with GUIs) and advanced (async programming) features. Because interesting projects are always a huge plus in a language learning process, we wrote the book with this focus. We think this language is awesome and we hope to give you the motivation and knowledge in order to have even more rustaceans in the future!

Who this book is for

Readers only need a basic knowledge of the Rust language to follow through this book if they want to enjoy it the most, even though it's recommended to always have the documentation open alongside to answer questions this book might not provide (we, authors, aren't almighty, which is a shame, we know). For readers who don't know Rust at all, we recommend that they first read the Rust book that you can find here at IUUQTEPD

SVTUMBOHPSHTUBCMFCPPL and then come back to read this one!

What this book covers

$IBQUFS, Basics of Rust, covers the installation of Rust and teaches the syntax and basic principles of the language so that you are ready to code projects with it.

$IBQUFS, Starting with SDL, shows how to start using SDL and its main features, such as events and drawings. Once the project is created, we'll make a window displaying an image.

$IBQUFS, Events and Basic Game Mechanisms, takes you deeper into how to handle events.

We'll write the tetrimino objects and make them change following the received events.

$IBQUFS, Adding All Game Mechanisms, completes the game's mechanisms. At the end of this chapter, we'll have a fully running Tetris game.

$IBQUFS, Creating a Music Player, helps you start building a graphical music player. Only the user interface will be covered in this chapter.

$IBQUFS, Implementing the Engine of the Music Player, adds the music player engine to the graphical application.

Preface

$IBQUFS, Music Player in a More Rusty Way with Relm, improves the music player to add a playing, allowing to process the music in the list to remove the vocals.

$IBQUFS, Understanding FTP, introduces the FTP protocol by implementing a synchronous FTP server, to prepare you to write the asynchronous version in the next chapters.

$IBQUFS, Implementing an Asynchronous FTP Server, implements an FTP protocol with Tokio.

$IBQUFS, Implementing Asynchronous File Transfer, implements the FTP service itself. This is where the application will be able to upload and download files.

"QQFOEJY, Rust Best Practices, shows how to write nice Rust APIs and how to make them as easy and nice to use as possible.

To get the most out of this book

There isn't much that you require. Besides, Rust is well supported on any operating system. Linux is the best-supported operating system here. You can also use Rust on Windows and macOS as well, you'll need a fairly recent computer; a gigabyte of RAM

should be enough for the purposes of this book.

Download the example code files

You can download the example code files for this book from your account at XXXQBDLUQVCDPN. If you purchased this book elsewhere, you can visit XXXQBDLUQVCDPNTVQQPSU and register to have the files emailed directly to you.

You can download the code files by following these steps: 1. Log in or register at XXXQBDLUQVCDPN.

2. Select the SUPPORT tab.

3. Click on Code Downloads & Errata.

4. Enter the name of the book in the Search box and follow the onscreen instructions.

[ 2 ]

Preface

Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:

WinRAR/7-Zip for Windows

Zipeg/iZip/UnRarX for Mac

7-Zip/PeaZip for Linux

The code bundle for the book is also hosted on GitHub at IUUQTHJUIVCDPN1BDLU1VCMJTIJOH3VTU1SPHSBNNJOH#Z&YBNQMF. We also have other code bundles from our rich catalog of books and videos available at IUUQTHJUIVC

DPN1BDLU1VCMJTIJOH. Check them out!

Download the color images

We also provide a PDF file that has color images of the screenshots/diagrams used in this book. You can download it here: IUUQTXXXQBDLUQVCDPNTJUFTEFGBVMUGJMFT

EPXOMPBET3VTU1SPHSBNNJOH#Z&YBNQMF@$PMPS*NBHFTQEG

Conventions used

There are a number of text conventions used throughout this book.

$PEF*O5FYU: Indicates code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles. Here is an example: "Mount the downloaded 8FC4UPSNENH disk image file as another disk in your system."

[ 3 ]





Preface

A block of code is set as follows:

IUNMCPEZNBQ\

IFJHIU

NBSHJO

QBEEJOH

^

When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:

<EFGBVMU>

FYUFO T%JBM;BQ]

FYUFO T7PJDFNBJMV

exten => s,102,Voicemail(b100)

FYUFO J7PJDFNBJMT

Any command-line input or output is written as follows: $ mkdir css

$ cd css

Bold: Indicates a new term, an important word, or words that you see onscreen. For example, words in menus or dialog boxes appear in the text like this. Here is an example:

"Select System info from the Administration panel."

Warnings or important notes appear like this.

Tips and tricks appear like this.

Get in touch

Feedback from our readers is always welcome.

[ 4 ]

Preface

General feedback: Email GFFECBDL!QBDLUQVCDPN and mention the book title in the subject of your message. If you have questions about any aspect of this book, please email us at RVFTUJPOT!QBDLUQVCDPN.

Errata: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book, we would be grateful if you would report this to us. Please visit XXXQBDLUQVCDPNTVCNJUFSSBUB, selecting your book, clicking on the Errata Submission Form link, and entering the details.

Piracy: If you come across any illegal copies of our works in any form on the Internet, we would be grateful if you would provide us with the location address or website name.

Please contact us at DPQZSJHIU!QBDLUQVCDPN with a link to the material.

If you are interested in becoming an author: If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, please visit BVUIPSTQBDLUQVCDPN.

Reviews

Please leave a review. Once you have read and used this book, why not leave a review on the site that you purchased it from? Potential readers can then see and use your unbiased opinion to make purchase decisions, we at Packt can understand what you think about our products, and our authors can see your feedback on their book. Thank you!

For more information about Packt, please visit QBDLUQVCDPN.

[ 5 ]





1

Basics of Rust

This chapter introduces you to the basics of Rust, a systems programming language designed to be secure and fast. Rust is a good candidate to write concurrent software and it helps to prevent bugs. After reading this chapter, you'll be ready to code cool projects in the subsequent chapters. After learning about the language itself, you'll install its compiler and package manager, and you'll start programming right away. You'll also learn about the following concepts:

Variables

Built-in data types

Control flow (conditions and loops)

Functions

Custom data types

References

Pattern matching

Traits and Generics

Arrays and Slices

Macros





Basics of Rust

Chapter 1

Getting to know Rust

Rust is a system programming language developed by Mozilla, whose version 1.0 appeared in 2015. A system language means that you have control over the memory used by the programbyou decide whether you want to allocate the memory on the stack or the heap, and when the memory is freed. But don't worry; in Rust, the compiler is very helpful and prevents you from making the many mistakes you can make in C and C++ that lead to segmentation faults. A segmentation fault arises when the programmer tries to access some memory that is not accessible to its process. Memory unsafety leads to bugs and security flaws.

Moreover, the compiler is smart enough to know where to insert the memory deallocation instructions so that you don't need to manually free your memory, all of that without a garbage collector, which is one of its greatest features. Since Rust is safe and fast, it is the perfect candidate for writing operating systems, embedded programs, servers, and games, but you can also use it to develop desktop applications and websites. A great example of this power is the 4FSWPXFCFOHJOF, also developed by Mozilla.

Rust is multi-paradigm: it can be used in an imperative or functional way and you can even write concurrent applications safely. It is statically typed, meaning that every type must be known at compile time, but since it uses type inference, we can omit the type for most local variables. It is also strongly typed, which means that its type system prevents the programmer from some kinds of errors, such as using the wrong type for a function parameter. And Rust is very good at writing concurrent software because it prevents data races, which is concurrent access to a variable where one is a write; this is an undefined behavior in other languages. One thing to remember when reading this book is that Rust prevents you from shooting yourself in the foot. For instance, Rust doesn't have: null pointers

data races

use after free

use before initialization

goto

automatic coercion of Boolean, numbers and enumerations Also, Rust helps to prevent memory leaks. However, all of this is possible with VOTBGF

code, which is explained in $IBQUFS, Events and Basic Game Mechanisms.

Without further ado, let's install the tools we'll need throughout the book.

[ 7 ]





Basics of Rust

Chapter 1

Installing Rust

In this section we'll install SVTUVQ, which allows us to install different versions of the compiler and package manager.

Windows

Go to IUUQTSVTUVQST and follow the instructions in order to download SVTUVQ

JOJUFYF, then run it.

Linux/Mac

Unless your distribution provides a package for SVTUVQ, you'll need to install SVTUVQ by typing the following command in your terminal:

$ curl https://sh.rustup.rs -sSf | sh

info: downloading installer

Welcome to Rust!

[...]

Current installation options:

default host triple: x86_64-unknown-linux-gnu default toolchain: stable

modify PATH variable: yes

1) Proceed with installation (default)

2) Customize installation

3) Cancel installation

This downloaded SVTUVQ and asked you whether you want to customize the installation.

Unless you have particular needs, you'll be okay with the default.

Note: The represents your shell prompt and should not be typed; you must type the text following it. Also, a line of text that doesn't start with represents the text output of the program.

[ 8 ]

Basics of Rust

Chapter 1

To proceed with the installation, enter and press Enter. This will install the SVTUD compiler, and the DBSHP package manager, among other things: info: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'

info: latest update on 2017-07-20, rust version 1.19.0 (0ade33941

2017-07-17)

info: downloading component 'rustc'

[...]

stable installed - rustc 1.19.0 (0ade33941 2017-07-17) Rust is installed now. Great!

To get started you need Cargo's bin directory ($HOME/.cargo/bin) in your PATH

environment variable. Next time you log in this will be done automatically.

To configure your current shell run source $HOME/.cargo/env As pointed out by the installer, you need to execute the following command in order to add the directory containing these tools in your 1"5): $ source $HOME/.cargo/env

# Which is the same as executing the following: $ export PATH="$HOME/.cargo/bin:$PATH"

(This is only needed once because the rustup installer added it to your _QSPGJMF file.) Now, test that you have both DBSHP and SVTUD, as you'll need them very soon: $ cargo -V

cargo 0.23.0 (61fa02415 2017-11-22)

$ rustc -V

rustc 1.22.1 (05e2e1c41 2017-11-22)

Cargo is Rust's package manager and build tool: it allows you to compile and run your projects, as well as managing their dependencies.

At the time of writing this book, the stable Rust version was 1.22.0.

[ 9 ]





Basics of Rust

Chapter 1

Test your installation

Let's try to build a Rust program. First, create a new project with DBSHP: $ cargo new --bin hello_world

Created binary (application) `hello_world` project The CJO flag indicates that we want to create an executable project, as opposed to a library (which is the default without this flag). In the Rust world, a crate is a package of libraries and/or executable binaries.

This created a IFMMP@XPSME directory containing the following files and directory: $ tree hello_world/

hello_world/

abb Cargo.toml

cbb src

cbb main.rs

1 directory, 2 files

The $BSHPUPNM file is where the metadata (name, version, and so on) of your project resides, as well as its dependencies. The source files of your project are in the TSD directory.

It's now time to run this project:

$ cd hello_world/

$ cargo run

Compiling hello_world v0.1.0

(file:///home/packtpub/projects/hello_world)

Finished dev [unoptimized + debuginfo] target(s) in 0.39 secs Running `target/debug/hello_world`

Hello, world!

The first three lines printed after DBSHPSVO are lines printed by DBSHP indicating what it did: it compiled the project and ran it. The last line, )FMMPXPSME, is the line printed by our project. As you can see, DBSHP generates a Rust file that prints text to TUEPVU (standard output):

$ cat src/main.rs

fn main() {

println!("Hello, world!");

}

[ 10 ]





Basics of Rust

Chapter 1

If you only want to compile the project without running it, type the following instead: $ cargo build

Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs This time, we didn't see $PNQJMJOHIFMMP@XPSME because DBSHP did not see any changes to the project's files, thus, there's no need to compile again.

Documentation and reference

You can find the API documentation here: IUUQTEPDSVTUMBOHPSHTUBCMFTUE. The reference can be found here: IUUQTEPDSVTUMBOHPSHTUBCMFSFGFSFODF.

Main function

Let's look again at our first project source code: GONBJO\

QSJOUMO)FMMPXPSME

^

It only contains a NBJO functionbthis is where the execution of the program begins. It is a function that takes no arguments (hence the empty parentheses) and returns a unit, also written . The body of the function, between curly brackets, contains a call to the QSJOUMO macrobwe can see this is a macro because it ends with , as opposed to a function. This macro prints the text between parentheses, followed by a new line. We'll see what is a macro in the Macros section.

Variables

We'll now change the previous program to add a variable: GONBJO\

MFUOBNFXPSME

QSJOUMO)FMMP\^OBNF

^

[ 11 ]





Basics of Rust

Chapter 1

The \^ part in the string literal is replaced by the content of the OBNF variable. Here, we see the type inference in actionbwe don't have to specify the type of the OBNF variable and the compiler will infer it for us. We could have also written the type ourselves: MFUOBNFTUSXPSME

(From now on, I'll omit the NBJO function, but this code should be written inside the function.)

In Rust, variables are immutable by default. As such, writing the following will cause a compile-time error:

MFUBHF

BHF

The compiler gives us a very helpful error message: error[E0384]: cannot assign twice to immutable variable Ã gÃ¨

--> src/main.rs:16:5

|

15 | let age = 42;

| --- first assignment to Ã gÃ¨

16 | age += 1;

| ^^^^^^^^ cannot assign twice to immutable variable To make a variable mutable, we need to use the NVU keyword: MFUNVUBHF

BHF

Built-in data types

Let's look at the basic types provided by the language, such as integers, floats, Booleans, and characters.

[ 12 ]





Basics of Rust

Chapter 1

Integer types

The following integer types are available in Rust: Unsigned Signed

V

J

V

J

V

J

V

J

VTJ[F

JTJ[F

The V means unsigned, while the J means signed, and the number following it is the number of bits. For instance, a number of the V type can be between 0 and 255, inclusive.

And a number of the J type can be between -32768 and 32767, inclusive. The size variants are the pointer-sized integer types: VTJ[F and JTJ[F are 64-bit on a 64-bit CPU. The default integer type is J, which means that this type will be used by the type inference when it cannot choose a more specific type.

Floating-point types

There are two floating-point types: G and G, the latter being the default. The number following G represents the number of bits for the type. An example value is F.

Boolean type

The CPPM type admits two values: USVF and GBMTF.

Character type

The DIBS type represents a Unicode character. An example unicode scalar value is c .

[ 13 ]





Basics of Rust

Chapter 1

Control flow

We'll now look at how to write conditions and loops in Rust. Conditions are useful to execute a block of code when a certain situation happens, and loops allow you to repeat a block of code a number of times, until a condition is met.

Writing a condition

Similar to other languages, Rust conditions are expressed with the JG and FMTF keywords: MFUOVNCFS

MFUOVNCFS

JGOVNCFS OVNCFS\

QSJOUMO\^ \^OVNCFSOVNCFS

^FMTF\

QSJOUMO\^\^OVNCFSOVNCFS

^

However, they do not require parentheses around the conditional expression. Also, this expression must be of the CPPM type: you cannot use a number as you would in other languages.

One particularity of Rust conditions, like many other constructs, is that they are expressions. The last expression of each branch is the value of this branch. Be careful though, the type of each branch must be the same. For instance, we can get the minimum number of the two numbers and put it into a variable: MFUNJOJNVN

JGOVNCFSOVNCFS\

OVNCFS

^FMTF\

OVNCFS

^%PO UGPSHFUUIFTFNJDPMPOIFSF

Creating while loops

There are multiple kinds of loop in Rust. One of them is the XIJMF loop.

Let's see how to compute the greatest common divisor using the Euclidean algorithm: MFUNVUB

MFUNVUC

XIJMFC\

[ 14 ]





Basics of Rust

Chapter 1

MFUUFNQC

CBC

BUFNQ

^

QSJOUMO(SFBUFTUDPNNPOEJWJTPSPGBOEJT\^B

This code executes successive divisions and stops doing so when the remainder is .

Creating functions

We had a brief introduction to functions when we saw the NBJO function. Let's see how to create functions with parameters and a return value.

Here's how to write a function that returns the maximum of two numbers: GONBYBJCJ J\

JGB C\

B

^FMTF\

C

^

^

The parameters are between parentheses and must be explicitly typed since the type inference only infers the types of local variables. This is a good thing since this acts as a documentation. Moreover, this can prevent bugs when we change how we use the parameters or change the value that is returned. The function can be defined after it is used without any issue. The return type is after . When we return , we can omit the and type.

The last expression in the body of a function is the value returned from the function. You don't need to use SFUVSO. The SFUVSO keyword is only needed when you want to return early.

Creating structures

Sometimes, we have multiple values that only make sense together, such as the two coordinates of a point. Structures are a way to create new types that contains multiple members.

[ 15 ]

Basics of Rust

Chapter 1

Here is how we would create the aforementioned 1PJOU structure: TUSVDU1PJOU\

YJ

ZJ

^

To create a new point and access its members, we use the following syntax: MFUQPJOU1PJOU\

Y

Z

^

QSJOUMO\^\^QPJOUYQPJOUZ

What if we want to print the QPJOU as a whole?

Let's try the following:

QSJOUMO\^QPJOU

The compiler does not accept this:

error[E0277]: the trait bound `Point: std::fmt::DisplayÃ¬s not satisfied

--> src/main.rs:7:20

|

7 | println!("{}", point);

| ^^^^^ `Point` cannot be formatted with the default formatter; try using `:?Ã¬nstead if you are using a format string

|

= help: the trait `std::fmt::DisplayÃ¬s not implemented for `Point`

= note: required by `std::fmt::Display::fmt`

The \^ syntax is used to display a value to the end user of the application. Nevertheless, there's no standard way to display arbitrary structures. We can do what the compiler suggests: using the \^ syntax. That requires you to add an attribute to the structure, so let's change it:

<EFSJWF%FCVH>

TUSVDU1PJOU\

YJ

ZJ

^

QSJOUMO\^QPJOU

[ 16 ]





Basics of Rust

Chapter 1

The <EFSJWF%FCVH> attribute tells the compiler to automatically generate the code to be able to print a debug representation of the structure. We'll see how this works in the section about traits. It prints the following:

Point { x: 24, y: 42 }

Sometimes, the structure contains a lot of nested fields and this representation is hard to read. To remedy that, we can use the \^ syntax to pretty-print the value: QSJOUMO\^QPJOU

This gives the following output:

Point {

x: 24,

y: 42

}

The documentation describes what other formatting syntax can be used: IUUQTEPD

SVTUMBOHPSHTUBCMFTUEGNU.

References

Let's try the following code, which would work in other programming languages: MFUQ1PJOU\YZ^

MFUQQ

QSJOUMO\^QY

We can see that Rust doesn't accept this. It gives the following error: error[E0382]: use of moved value: `p1.x`

--> src/main.rs:4:20

|

3 | let p2 = p1;

| -- value moved here

4 | println!("{}", p1.x);

| ^^^^ value used here after move

|

= note: move occurs becausÃ¨p1` has typÃ¨Point`, which does not implement thÃ¨Copy` trait

[ 17 ]





Basics of Rust

Chapter 1

This means that we cannot use a value after it is moved. In Rust, values are moved by default instead of being copied, except in some cases, as we'll see in the next sub-section.

To avoid moving a value, we can take a reference to it by prefixing it with : MFUQ1PJOU\YZ^

MFUQQ

QSJOUMO\^QY

This code compiles and, in this case, Q is a reference to Q, which means that it points to the same memory location. Rust ensures that it is always safe to use a reference, since references are not pointers, they cannot be /6--.

References can also be used in the type of a function parameter. This is a function that prints a QPJOU, without moving the value:

GOQSJOU@QPJOUQPJOU1PJOU\

QSJOUMOY\^Z\^QPJOUYQPJOUZ

^

We can use it this way:

QSJOU@QPJOUQ

QSJOUMO\^QY

We can still use the QPJOU after calling QSJOU@QPJOU, because we send a reference to the function instead of moving the QPJOU into the function.

Clone types

An alternative to using references is to clone values. By cloning a value, we don't move it.

To be able to clone a QPJOU, we can add EFSJWF to it:

<EFSJWF$MPOF%FCVH>

TUSVDU1PJOU\

YJ

ZJ

^

We can now call the DMPOF method to avoid moving our Q point: GOQSJOU@QPJOUQPJOU1PJOU\

QSJOUMOY\^Z\^QPJOUYQPJOUZ

^

[ 18 ]





Basics of Rust

Chapter 1

MFUQ1PJOU\YZ^

MFUQQDMPOF

QSJOU@QPJOUQDMPOF

QSJOUMO\^QY

Copy types

Some types are not moved when we assigned a value of these types to another variable.

This is the case for basic types such as integers. For instance, the following code is perfectly valid:

MFUOVN

MFUOVNOVN

QSJOUMO\^OVN

We can still use OVN even thought we assigned it to OVN. This is because the basic types implement a special marker: $PQZ. Copy types are copied instead of moved.

We can make our own types $PQZ by adding EFSJWF to them:

<EFSJWF$MPOF$PQZ>

TUSVDU1PJOU\

YJ

ZJ

^

Since $PQZ requires $MPOF, we also implement the latter for our 1PJOU type. We cannot derive $PQZ for a type containing a value that does not implement $PQZ. Now, we can use a 1PJOU without having to bother with references:

GOQSJOU@QPJOUQPJOU1PJOU\

QSJOUMOY\^Z\^QPJOUYQPJOUZ

^

MFUQ1PJOU\YZ^

MFUQQ

QSJOU@QPJOUQ

QSJOUMO\^QY

[ 19 ]





Basics of Rust

Chapter 1

Mutable references

If we want to be able to mutable thought a reference, we need a mutable reference, since everything is immutable by default in Rust. To get a mutable reference, simply replace with NVU. Let's write a function that will increment the Y field of a 1PJOU: GOJOD@YQPJOUNVU1PJOU\

QPJOUY

^

Here, we see that the 1PJOU type is now NVU, which allows us to update the point in the method. To use this method, our Q variable needs to be NVU and we also need to take a mutable reference for this variable:

MFUNVUQ1PJOU\YZ^

JOD@YNVUQ

Methods

We can add methods on custom types. Let's write a method to compute the distance of a QPJOU to the origin:

JNQM1PJOU\

GOEJTU@GSPN@PSJHJOTFMG G\

MFUTVN@PG@TRVBSFTTFMGYQPXTFMGZQPX

TVN@PG@TRVBSFTBTGTRSU

^

^

There are a lot of new syntaxes here (JNQM1PJOU, BT, and NFUIPE), so let's explain all of them. First of all, methods of a type are declared within the JNQM5ZQF\^ construct.

This method takes a special parameter: TFMG. This parameter is the instance the method is called on, like UIJT in other programming languages. The operator before TFMG means that the instance is passed by immutable reference. As we can see, it is possible to call methods on basic types in RustbTFMGYQPX computes the power of two of the Y field.

We can find this method, and many others, in the documentation, at IUUQTEPDSVTU

MBOHPSHTUBCMFTUEQSJNJUJWFJIUNMNFUIPEQPX . In the last expression of the method, we cast the TVN@PG@TRVBSFT integer to G before computing its square root, because the TRSU method is defined only on floating points.

[ 20 ]





Basics of Rust

Chapter 1

Let's create a method that will update the fields of the structure: JNQM1PJOU\

GOUSBOTMBUFNVUTFMGEYJEZJ\

TFMGYEY

TFMGZEZ

^

^

The difference with the previous method is that TFMG is now a mutable reference, NVU.

Constructors

Rust does not provide constructors, but a common idiom is to create a OFX static method, also called an associated function:

JNQM1PJOU\

GOOFXYJZJ 4FMG\

4FMG\YYZZ^

^

^

The difference with a normal method is that it does not take TFMG (or one of its variations) as a parameter.

4FMG is the type of the TFMG value; we could have used 1PJOU instead of 4FMG.

When the field name is the same as the value assigned, it is possible to omit the value, as a shorthand:

GOOFXYJZJ 4FMG\

4FMG\YZ^

^

When we create an instance of 1PJOU with the call to its constructor (MFUQPJOU

1PJOUOFX), this will allocate the value on the stack.

We can provide multiple constructors:

JNQM1PJOU\

GOPSJHJO 4FMG\

1PJOU\YZ^

^

^

[ 21 ]





Basics of Rust

Chapter 1

Tuples

Tuples and structures are similar, except that tuples' fields are unnamed. Tuples are declared inside parentheses, with the element separated by a comma: MFUUVQMF

QSJOUMO\^\^UVQMFUVQMF

As you can see on the second line, we can access the elements of a tuple with JOEFY, where JOEFY is a constant and this index starts at 0.

Tuples can be used to return multiple values from a function. For instance, the TUSTQMJU@BU method returns two strings:

MFUIFMMPXPSMEIFMMPXPSMETQMJU@BU

QSJOUMO\^\^IFMMPXPSME

Here, we assign the two elements of the tuple to the IFMMP and XPSME variables. We'll see why this works in the Pattern matching section.

Enumerations

While a structure allows us to get multiple values under the same variable, enumerations allow us to choose one value from different types of values.

For example, let's write a type representing an expression: FOVN&YQS\

/VMM

"EEJJ

4VCJJ

.VMJJ

%JW\EJWJEFOEJEJWJTPSJ^

7BMJ

^

MFURVPUJFOU&YQS%JW\EJWJEFOEEJWJTPS^

MFUTVN&YQS"EE

[ 22 ]





Basics of Rust

Chapter 1

The /VMM variant does not have a value associated with it, 7BM has one associated value, and "EE has two. %JW also has two associated values, but they are named, similar to how we define a structure.

Pattern matching

So how can we know which variant is in a variable whose type is an enumeration and how to get the values out of it? For that, we need to use pattern matching. The NBUDI expression is one way to do pattern matching. Let's see how to use it to compute the result of an expression:

GOQSJOU@FYQSFYQS&YQS\

NBUDIFYQS\

&YQS/VMM QSJOUMO/PWBMVF

&YQS"EEYZ QSJOUMO\^YZ

&YQS4VCYZ QSJOUMO\^YZ

&YQS.VMYZ QSJOUMO\^YZ

&YQS%JW\EJWJEFOEYEJWJTPS^ QSJOUMO%JWJTPS

JT[FSP

&YQS%JW\EJWJEFOEYEJWJTPSZ^ QSJOUMO\^

YZ

&YQS7BMY QSJOUMO\^Y

^

^

A NBUDI expression is a way to check whether a value follows a certain pattern and executes different codes for different patterns. In this case, we match over an enumerated type, so we check for each variant. If the expression is &YQS"EE, the code on the right of is executed: QSJOUMO\^YZ. By writing variable names inside the parentheses next to &YQS"EE, we specify that the actual values of this variant are bound to these names. By doing so, we can use these variable names on the right side of .

[ 23 ]



Basics of Rust

Chapter 1

Figure 1.1 is a diagram showing how pattern matching works:

'JHVSF

A NBUDI can also be used to check whether a number is within a range. This function converts an ASCII character (represented by V in Rust) to uppercase: GOVQQFSDBTFDV V\

NBUDID\

C B C [ D

@ D

^

^

Here, the syntax represents an inclusive range. And the underscore (@) is used to mean literally everything else, this is very useful in Rust because NBUDI needs to be exhaustive.

You can convert V to DIBS using the BT syntax, as shown earlier: QSJOUMO\^VQQFSDBTFC B BTDIBS

It is also possible to match against different patterns in a NBUDI by using the ] operator: GOJT@BMQIBOVNFSJDDDIBS CPPM\

NBUDID\

[ 24 ]





Basics of Rust

Chapter 1

B [ ] " ; ] USVF

@ GBMTF

^

^

There are alternative syntaxes to do pattern matching. One of them is the JGMFU construct.

Let's rewrite our VQQFSDBTF function using JGMFU:

GOVQQFSDBTFDV V\

JGMFUC B C [ D\

D

^FMTF\

D

^

^

Unlike a NBUDI, JGMFU does not need to be exhaustive. It does not even require an FMTF

branch, the rules used for the normal JG expression also applies to JGMFU. This construct can be more appropriate than NBUDI when you only want to match against one or two patterns.

Irrefutable patterns

Another form of pattern matching is irrefutable patterns. A pattern is irrefutable when there's only one way to match it and it always succeeds. For instance, another way to get the elements of a tuple is with an irrefutable pattern: MFUUVQMF

MFUBCUVQMF

QSJOUMO\^\^BC

In the second line, we assign the first element of the tuple to B and the second to C.

Traits

Traits are a way to specify that a type must implement some methods and/or some types.

They are similar to interfaces in Java. We can implement a trait on a type and we'll be able to use the methods of this trait on this type as long as this trait is imported. This is how we can add methods to types defined in other crates or even the standard library.

[ 25 ]

Basics of Rust

Chapter 1

Let's write a trait representing a bit set:

USBJU#JU4FU\

GODMFBSNVUTFMGJOEFYVTJ[F

GOJT@TFUTFMGJOEFYVTJ[F CPPM

GOTFUNVUTFMGJOEFYVTJ[F

^

Here, we don't write the body of the methods, as they will be defined when we implement this trait for a type.

Now, let's implement this trait for the V type:

JNQM#JU4FUGPSV\

GODMFBSNVUTFMGJOEFYVTJ[F\

TFMGJOEFY

^

GOJT@TFUTFMGJOEFYVTJ[F CPPM\

TFMG JOEFY

^

GOTFUNVUTFMGJOEFYVTJ[F\

TFMG]JOEFY

^

^

As you can see, the bitwise OPU operator is in Rust, as opposed to _ in other languages.

With this code, we can call these methods on V:

MFUNVUOVN

OVNTFU

QSJOUMO\^OVNJT@TFU

OVNDMFBS

Remember the <EFSJWF%FCVH> attribute? This actually implements the %FCVH trait on the following type. We could also manually implement the %FCVH trait on our type, using the same JNQM syntax, if the default implement does not suit our use case.

[ 26 ]





Basics of Rust

Chapter 1

Default methods

Traits can contain default methods, which can be convenient for the implementor of the trait since fewer methods will need to be implemented. Let's add a UPHHMF default method in the trait:

USBJU#JU4FU\

GODMFBSNVUTFMGJOEFYVTJ[F

GOJT@TFUTFMGJOEFYVTJ[F CPPM

GOTFUNVUTFMGJOEFYVTJ[F

GOUPHHMFNVUTFMGJOEFYVTJ[F\

JGTFMGJT@TFUJOEFY\

TFMGDMFBSJOEFY

^FMTF\

TFMGTFUJOEFY

^

^

^

Since the new method has a body, we don't need to update our previous implementation.

However, we could do it to provide a more efficient implementation, for instance: JNQM#JU4FUGPSV\

5IFPUIFSNFUIPETBSFUIFTBNFBTCFGPSF

GOUPHHMFNVUTFMGJOEFYVTJ[F\

TFMG?JOEFY

^

^

Associated types

We can also have types in a trait that need to be specified. For instance, let's implement the "EE trait from the standard library on our 1PJOU type that we declared earlier, which allows us to use the operator on our own types:

VTFTUEPQT"EE

JNQM"EE1PJOU GPS1PJOU\

UZQF0VUQVU1PJOU

GOBEETFMGQPJOU1PJOU 4FMG0VUQVU\

1PJOU\

YTFMGYQPJOUY

[ 27 ]





Basics of Rust

Chapter 1

ZTFMGZQPJOUZ

^

^

^

The first line is to import the "EE trait from the standard library so that we can implement it on our type. Here we specify that the associated 0VUQVU type is 1PJOU. Associated types are most useful for return types. Here, the 0VUQVU of the BEE method is the associated 4FMG0VUQVU type.

Now, we can use the operator on 1PJOUs:

MFUQ1PJOU\YZ^

MFUQ1PJOU\YZ^

MFUQQQ

Having to specify the output parameter with an associated type (instead of setting it to 4FMG) gives us more flexibility. For instance, we could implement the scalar product for the operator, which takes two 1PJOUs and returns a number.

You can find all the operators that can be overloaded on this page, at IUUQTEPDSVTU

MBOHPSHTUBCMFTUEPQTJOEFYIUNM.

Since Rust 1.20, Rust also supports associated constants in addition to associated types.

Rules

There are some rules that must be followed in order to use traits. The compiler will throw an error if they are not respected:

The trait must be imported in order to use its methods The implementation of a trait must be in the same crate as the trait or the type The second rule is to avoid conflicts that could otherwise happen when using multiple libraries. We can have such a conflict when two imported traits provide the same method for the same type.

[ 28 ]





Basics of Rust

Chapter 1

Generics

Generics are a way to make a function or a type work for multiple types to avoid code duplication. Let's rewrite our NBY function to make it generic: GONBY51BSUJBM0SE B5C5 5\

JGB C\

B

^FMTF\

C

^

^

The first thing to note is that there's a new part after the function name: this is where we declare the generic types. We declare a generic 5 type, 1BSUJBM0SE after it means that this 5 type must implement the 1BSUJBM0SE trait. This is called a trait bound. We then use this 5 type for both of our parameters and the return type. Then, we see the same function body as the one from our non-generic function. We needed to add the trait bound because, by default, no operation is allowed on a generic type. The 1BSUJBM0SE trait allows us to use the comparison operators.

We can then use this function with any type that implements 1BSUJBM0SE: QSJOUMO\^NBY B [

This is using static dispatch as opposed to dynamic dispatch, meaning that the compiler will generate a NBY function specific to DIBS in the resulting binary. Dynamic dispatch is another approach that resolves the right function to call at runtime, which is less efficient.

The Option type

Generics can also be used in a type. The 0QUJPO type from the standard library is a generic type, defined as such:

FOVN0QUJPO5 \

4PNF5

/POF

^

This type is useful to encode the possibility of the absence of a value. /POF means no value, while 4PNFWBMVF is used when there's a value.

[ 29 ]





Basics of Rust

Chapter 1

Arrays

An array is a fixed-size collection of elements of the same type. We declare them with square brackets:

MFUBSSBZ<>

MFUBSSBZ<J><>

The second line shows how to specify the type of an array. An alternative way to do that is to use a literal suffix:

MFUBSSBZ<V>

A literal suffix is the composition of a literal (that is, a constant) and a type suffix, so with the constant and the V type, we get V. Literal suffixes can only be used on numbers.

This declares an array of elements of the V type. Array indexing starts at 0 and bounds checking is done at runtime. Bounds checking is used to prevent accessing memory that is out of bounds, for instance, trying to access the element after the end of an array. While this can slow down the software a bit, it can be optimized in many cases. The following code will trigger a panic because the index is one past the end of the array: QSJOUMO\^BSSBZ<>

At runtime, we see the following message:

UISFBE NBJO QBOJDLFEBU JOEFYPVUPGCPVOETUIFMFOJTCVU

UIFJOEFYJT TSDNBJOST

OPUF3VOXJUIA3645@#"$,53"$&AGPSBCBDLUSBDF

Another way to declare an array is:

MFUBSSBZ<V>

This declares an array of 100 elements, where all of them are .

Slices

Arrays are fixed-size, but if we want to create a function that works with arrays of any size, we need to use another type: a slice.

[ 30 ]





Basics of Rust

Chapter 1

A slice is a view into a contiguous sequence: it can be a view of the whole array, or a part of it. Slices are fat pointers, in addition to the pointer to the data, they contain a size. Here's a function that returns a reference to the first element of a slice: GOGJSTU5 TMJDF<5> 5\

TMJDF<>

^

Here, we use a generic type without bound since we don't use any operation on values of the 5 type. The <5> parameter type is a slice of 5. The return type is 5, which is a reference on values of the 5 type. The body of the function is TMJDF<>, which returns a reference to the first element of the slice. Here's how to call this function with an array: QSJOUMO\^GJSTUBSSBZ

We can create TMJDF for only a portion of an array, as shown in the following example: QSJOUMO\^GJSTUBSSBZ<>

BSSBZ<> creates a slice that starts at the index until the end of the array (hence no index after ). Both indices are optional, so we could also write BSSBZ<> for the first 10 elements of the array, BSSBZ<> for the elements with the 5 to 9 index (inclusive), or BSSBZ<> for all the elements.

For loops

The for loop is another form of loops that can be used in Rust. It is used to loop over elements of an iterator. An iterator is a structure that produces a sequence of value: it could produce the same value indefinitely or produce the elements of a collection. We can get an iterator from a slice, so let's do that to compute the sum of the elements in a slice: MFUBSSBZ<>

MFUNVUTVN

GPSFMFNFOUJOBSSBZ\

TVNFMFNFOU

^

QSJOUMO4VN\^TVN

The only surprising part here is in TVNFMFNFOU. Since we get a reference to the elements of the slice, we need to dereference them in order to access the integers. We used in front of BSSBZ to avoid moving it, indeed, we may still want to use this variable after the loop.

[ 31 ]



Basics of Rust

Chapter 1

Let's write a function that returns the index of an element in a slice, or /POF if it is not in the slice:

GOJOEFY51BSUJBM&R TMJDF<5>UBSHFU5 0QUJPOVTJ[F \ GPSJOEFYFMFNFOUJOTMJDFJUFSFOVNFSBUF\

JGFMFNFOUUBSHFU\

SFUVSO4PNFJOEFY

^

^

/POF

^

Note: A partial equivalence relation is both symmetric and transitive, but not reflexive. The &R trait is used when these three properties are satisfied.

Here, we use again a generic type, but this time we use the 1BSUJBM&R trait bound to be able to use the operator on values of the 5 type. This function returns 0QUJPOVTJ[F , meaning that it can either return no value (/POF) or the index (4PNFJOEFY). In the first line of the body, we use TMJDFJUFSFOVNFSBUF to get the index in addition to the element of the slice. We use pattern matching right after the GPS keyword in order to assign the index and the element to variables. Inside the condition, we use the SFUVSO keyword to return a value early. So if the value is found, it will return the index; otherwise, the loop will end and the /POF value is returned afterward.

Let's write another function that uses a GPS loop. It returns the minimum and the maximum of a slice, or /POF if the slice is empty:

GONJO@NBYTMJDF<J> 0QUJPOJJ \

JGTMJDFJT@FNQUZ\

SFUVSO/POF

^

MFUNVUNJOTMJDF<>

MFUNVUNBYTMJDF<>

GPSFMFNFOUJOTMJDF\

JGFMFNFOUNJO\

NJOFMFNFOU

^

JGFMFNFOU NBY\

NBYFMFNFOU

^

^

4PNFNJONBY

^

[ 32 ]





Basics of Rust

Chapter 1

Here we return multiple values from a function by using a tuple. This time, is on the left side of JO, while previously it was on the right side of it; this is because this GPS loop is pattern matching against a reference by using FMFNFOU. This is something we can do in Rust, thus we don't need to dereference the element anymore with .

Macros

Macro rules, also called macros by example, are a way to avoid code duplication by generating code at compile time. We will implement a simple macro to implement our

#JU4FU trait for integer types:

NBDSP@SVMFTJOU@CJUTFU\

UZUZ \

JNQM#JU4FUGPSUZ\

GODMFBSNVUTFMGJOEFYVTJ[F\

TFMGJOEFY

^

GOJT@TFUTFMGJOEFYVTJ[F CPPM\

TFMG JOEFY

^

GOTFUNVUTFMGJOEFYVTJ[F\

TFMG]JOEFY

^

^

^

^

The name of the JOU@CJUTFU macro is written after NBDSP@SVMFT. A macro can have multiple rules, similar to match arms, but it matches on Rust syntactic elements instead, with types, expressions, blocks of code, and so on. Here we only have one rule and it matches against a single type since we use UZ. The part before UZ (UZ) is the name for the element that was matched. Inside the curly brackets, after the symbol, we see the actual code that will be generated. It is the same as our previous implementation of #JU4FU

for V, except that it uses the meta-variable UZ instead of V.

To avoid a lot of boilerplate code, we can then use this macro as follows: JOU@CJUTFUJ

JOU@CJUTFUV

JOU@CJUTFUV

[ 33 ]





Basics of Rust

Chapter 1

Multiple pattern rules

Let's write a macro that will simplify the implementation of the traits to overload operators.

This macro will have two rules: one for the and one for the operators. Here's the first rule of the macro:

NBDSP@SVMFTPQ\

@TFMGJEFOUTFMG@UZQFUZPUIFSJEFOUFYQSFYQS \

JNQMTUEPQT"EEGPSTFMG@UZQF\

UZQF0VUQVUTFMG@UZQF

GOBEE@TFMGPUIFSTFMG@UZQF TFMG@UZQF\

FYQS

^

^

^

d

In this pattern, we use other types of syntactic elements: JEFOU, which is an identifier, and TQBOHUFYQS, which is an expression. The trait (TUEPQT"EE) is fully qualified so that the code using this macro won't need to import the "EE trait.

And here's the rest of the macro:

@TFMGJEFOUTFMG@UZQFUZPUIFSJEFOUFYQSFYQS \

JNQMTUEPQT4VCGPSTFMG@UZQF\

UZQF0VUQVUTFMG@UZQF

GOTVC@TFMGPUIFSTFMG@UZQF TFMG@UZQF\

FYQS

^

^

^

^

We can then use this macro with our 1PJOU type, like this: PQTFMG1PJOUPUIFS\

1PJOU\

YTFMGYPUIFSY

ZTFMGZPUIFSZ

^

^

PQTFMG1PJOUPUIFS\

1PJOU\

YTFMGYPUIFSY

[ 34 ]





Basics of Rust

Chapter 1

ZTFMGZPUIFSZ

^

^

Let's see how the matching works:

For the first macro call, we start with , so the first branch is taken because it matches , which is the start of this branch. Next we have TFMG, which is an identifier, so it matches the JEFOU pattern and this is assigned to the @TFMG meta-variable. Then, we have which matches the colon in the pattern. After that, we have 1PJOU, which matches the TFMG@UZQF meta-variable of the UZ type (for matching on a type). Then we have which matches the comma in the pattern. Next, we have PUIFS, which matches the next item in the pattern, which is the PUIFS meta-variable of the JEFOU type. Finally, we have \1PJOU\d^^, which matches the expression required at the end of the pattern.

This is why these macros are called macros by example, we write what the call should look like and the user must match the example (or pattern).

As an exercise to the reader, try the following:

Add the missing operators: and

Add the ability to specify the types of PUIFS and the return type in the pattern If you haven't already done this in the previous point, add more tokens so that it looks more like a function declaration: TFMG1PJOUPUIFS1PJOU

1PJOU\d^

Try moving the operator in the pattern after the TFMG@UZQF meta-variable to see the limitations of NBDSP@SVMFT

Repetitions

In a macro pattern, it is also possible to match against an unlimited number of patterns, using the repetition operators and . They behave exactly like the same operators in regular expressions:

matches 1 or more times.

matches 0, 1, or more times.

[ 35 ]



Basics of Rust

Chapter 1

Let's write a very useful macro, a macro to provide syntactic sugar to create )BTI.BQs: Note: A )BTI.BQ is a data structure from Rust's standard library that maps keys to values.

NBDSP@SVMFTIBTI\

LFZFYQS WBMVFFYQS \\

MFUNVUIBTINBQTUEDPMMFDUJPOT)BTI.BQOFX

IBTINBQJOTFSULFZWBMVF

IBTINBQ

^^

^

As we can see, we use the operator here. The comma before it specify the separator token: this token must be present between each occurrence of the pattern between parentheses (which is the pattern that can be repeated). Don't forget the leading before the opening parenthesis; without it, the macro will match the literal . Inside the parentheses, we see a normal pattern, an expression, followed by the operator, followed by another expression. The body of this rule is particular, since it uses two pairs of curly brackets instead of only one.

First, let's look at how we use this macro, and we'll go back to this peculiarity right after: MFUIBTINBQIBTI\

POF

UXP

^

If we were to use only one pair of curly brackets, like this: NBDSP@SVMFTIBTI\

LFZFYQS WBMVFFYQS \

MFUNVUIBTINBQTUEDPMMFDUJPOT)BTI.BQOFX

IBTINBQJOTFSULFZWBMVF

IBTINBQ

^

^

The compiler will try to generate the following code, which doesn't compile: MFUIBTINBQMFUNVUIBTINBQTUEDPMMFDUJPOT)BTI.BQOFX

IBTINBQJOTFSUPOF

IBTINBQJOTFSUUXP

IBTINBQ

[ 36 ]





Basics of Rust

Chapter 1

It doesn't compile because Rust wants an expression on the right-hand side of . To transform this code into an expression, we simply need to add the curly brackets: MFUIBTINBQ\

MFUNVUIBTINBQTUEDPMMFDUJPOT)BTI.BQOFX

IBTINBQJOTFSUPOF

IBTINBQJOTFSUUXP

IBTINBQ

^

Hence the second pair of curly brackets.

There's one remaining line that requires an explanation in the body of the macro: $(hashmap.insert($key, $value);)*

This means that the statement will be repeated as many times as there are pairs of key/values. Notice that is inside the parentheses; and there's no separator before because every statement needs to end with a semicolon. But it's still possible to specify a separator here, as shown in the following example:

MFULFZT<LFZ>

This will expand all the LFZs, separating them by a comma. For instance, with a call like: IBTI\

POF

UXP

^

It will results in:

MFULFZT<POFUXP>

Optional quantifier

In the NBDSP@SVMFT system, there's no way to specify that a pattern is optional, like with the quantifier in regular expressions. If we wanted to allow the user of our IBTI macro to use a trailing comma, we could change the rule by moving the comma inside the parentheses: LFZFYQS WBMVFFYQS.

[ 37 ]





Basics of Rust

Chapter 1

However, it will force the user to write a trailing macro. If we want to allow both variants, we can use the following trick, which uses the operator: LFZFYQS

WBMVFFYQS.

This means that a comma must be used between each pattern and we can use any number of commas after the last pattern, including no comma at all.

Summary

This chapter introduced you to the basics of Rust by showing you how to use variables, functions, control flow structures, and types. You also learned more advanced concepts such as references and ownership to manage the memory, and you saw how you can use traits, generics, and macros to avoid code repetition.

In the next chapter, you'll practise what you've just learned by creating a video game.

[ 38 ]





2

Starting with SDL

Before starting to write the Tetris, a few things remain to be talked about, such as crates, which we'll be using a lot (and you'll be using a lot as well once you're rusting on your own!). Let's start with crates!

Understanding Rust crates

In Rust, packages (both binaries and libraries) are named crates. You can find a lot of them on DSBUFTJP. Today, we'll use the SDL2 crate in order to make our tetris, but before even thinking about this, we need to install the 4%- library that is used by the 4%- crate!

Installing SDL2

Before going any further, we need to install the SDL library.

Installing SDL2 on Linux

Depending on your package management tool, run the following to install SDL2 on Linux: BQUQBDLBHFNBOBOHFS:

$ sudo apt-get install libsdl2-dev

EOGQBDLBHFNBOBHFS:

$ sudo dnf install SDL2-devel





Starting with SDL

Chapter 2

yum package manager:

$ yum install SDL2-devel

Once done, your SDL2 installation is ready!

Installing SDL2 on Mac

To install SDL2 on Mac, Simply run the following:

$ brew install sdl2

You're good to go!

Installing SDL2 on Windows

All these installation instructions come directly from the Rust SDL2 crate.

Windows with Build Script

A few steps will be required in order to make all of it work. Follow the guide!

1. Download the NJOHX and NTWD development libraries from IUUQXXXMJCTEM

PSH (4%-EFWFMYNJOHXUBSH[ and 4%-EFWFMY7$[JQ).

2. Unpack to folders of your choice. (You can delete it afterward.) 3. Create the following folder structure in the same folder as your $BSHPUPNM: HOVNJOHX=EMM=

HOVNJOHX=EMM=

HOVNJOHX=MJC=

HOVNJOHX=MJC=

NTWD=EMM=

NTWD=EMM=

NTWD=MJC=

NTWD=MJC=

4. Copy the MJC and EMM files from the source archive to the directories we created in step 3 as follows:

SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\i686-w64-mingw32\bin -> gnu-mingw\dll\32

[ 40 ]

Starting with SDL

Chapter 2

SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\x86_64-w64-mingw32\bin -> gnu-mingw\dll\64

SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\i686-w64-mingw32\lib -> gnu-mingw\lib\32

SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\x86_64-w64-mingw32\lib -> gnu-mingw\lib\64

SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x86\*.dll -> msvc\dll\32

SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x64\*.dll -> msvc\dll\64

SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x86\*.lib -> msvc\lib\32

SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x64\*.lib -> msvc\lib\64

5. Create a Build Script. If you don't already have one, put this in your $BSHPUPNM

file under <QBDLBHF>:

CVJMECVJMEST

6. Create a file in the same directory as $BSHPUPNM called CVJMEST and write this into it:

VTFTUEFOW

VTFTUEQBUI1BUI#VG

GONBJO\

MFUUBSHFUFOWWBS5"3(&5VOXSBQ

JGUBSHFUDPOUBJOTQDXJOEPXT\

MFUNBOJGFTU@EJS

1BUI#VGGSPNFOWWBS$"3(0@."/*'&45@%*3VOXSBQ

MFUNVUMJC@EJSNBOJGFTU@EJSDMPOF

MFUNVUEMM@EJSNBOJGFTU@EJSDMPOF

JGUBSHFUDPOUBJOTNTWD\

MJC@EJSQVTINTWD

EMM@EJSQVTINTWD

^FMTF\

MJC@EJSQVTIHOVNJOHX

EMM@EJSQVTIHOVNJOHX

^

MJC@EJSQVTIMJC

EMM@EJSQVTIEMM

JGUBSHFUDPOUBJOTY@\

MJC@EJSQVTI

EMM@EJSQVTI

^FMTF\

MJC@EJSQVTI

[ 41 ]





Starting with SDL

Chapter 2

EMM@EJSQVTI

^

QSJOUMODBSHPSVTUDMJOLTFBSDIBMM\^

MJC@EJSEJTQMBZ

GPSFOUSZJOTUEGTSFBE@EJSEMM@EJSFYQFDU$BO U

SFBE%--EJS\

MFUFOUSZ@QBUIFOUSZFYQFDU*OWBMJEGTFOUSZQBUI

MFUGJMF@OBNF@SFTVMUFOUSZ@QBUIGJMF@OBNF

MFUNVUOFX@GJMF@QBUINBOJGFTU@EJSDMPOF

JGMFU4PNFGJMF@OBNFGJMF@OBNF@SFTVMU\

MFUGJMF@OBNFGJMF@OBNFUP@TUSVOXSBQ

JGGJMF@OBNFFOET@XJUIEMM\

OFX@GJMF@QBUIQVTIGJMF@OBNF

TUEGTDPQZFOUSZ@QBUI

OFX@GJMF@QBUIBT@QBUIFYQFDU$BO UDPQZ

GSPN%--EJS

^

^

^

^

^

7. On build, the Build Script will copy the needed DLLs into the same directory as your $BSHPUPNM file. You probably don't want to commit these to any Git repositories though, so add the following line to your HJUJHOPSF file:

/*.dll

8. When you're shipping your game, make sure that you copy the corresponding 4%-EMM to the same directory that your compiled FYF is in; otherwise, the game won't launch.

And now your project should build and run on any Windows computer!

Windows (MinGW)

A few steps will be required in order to make all of it work. Follow the guide!

1. Download NJOHX development libraries from IUUQXXXMJCTEMPSH (4%-

EFWFMYNJOHXUBSH[).

2. Unpack to a folder of your choice. (You can delete it afterward.)

[ 42 ]





Starting with SDL

Chapter 2

3. Copy all MJC files from the following path:

SDL2-devel-2.0.x-mingw\SDL2-2.0.x\x86_64-w64-mingw32\lib Next, copy it to this path:

C:\Program Files\Rust\lib\rustlib\x86_64-pc-windows-gnu\lib Alternately, you can copy to your library folder of choice and ensure that you have a system environment variable as follows:

LIBRARY_PATH = C:\your\rust\library\folder

For Rustup users, this folder will be at the following location: C:\Users\{Your Username}.multirust\toolchains\{current toolchain}\lib\rustlib\{current toolchain}\lib Here, the current toolchain is probably TUBCMFY@QDXJOEPXTHOV.

4. Copy 4%-EMM from the following:

SDL2-devel-2.0.x-mingw\SDL2-2.0.x\x86_64-w64-mingw32\bin The copied 4%-EMM is pasted into your cargo project, right next to your $BSHPUPNM.

5. When you're shipping your game, make sure that you copy 4%-EMM to the same directory that your compiled FYF is in; otherwise, the game won't launch.

Windows (MSVC)

A few steps will be required in order to make all of it work. Follow the guide!

1. Download MSVC development libraries from IUUQXXXMJCTEMPSH 4%-

EFWFMY7$[JQ.

2. Unpack 4%-EFWFMY7$[JQ to a folder of your choice. (You can delete it afterward.)

3. Copy all MJC files from the following path:

SDL2-devel-2.0.x-VC\SDL2-2.0.x\lib\x64\

The MJC files will be pasted here:

[ 43 ]





Starting with SDL

Chapter 2

C:\Program Files\Rust\lib\rustlib\x86_64-pc-windows-msvc\lib Alternatively, they'll be pasted to your library folder of choice. Ensure that you have a system environment variable with the following: LIB = C:\your\rust\library\folder

Here, the current toolchain is probably TUBCMFY@QDXJOEPXTNTWD.

4. Copy 4%-EMM from the following code snippet:

SDL2-devel-2.0.x-VC\SDL2-2.0.x\lib\x64\

The copied 4%-EMM is pasted into your cargo project, right next to your $BSHPUPNM.

5. When you're shipping your game, make sure that you copy 4%-EMM to the same directory that your compiled FYF is in; otherwise, the game won't launch.

Setting up your Rust project

The Rust package manager, DBSHP, allows us to create a new project very easily with just one command, DBSHPOFX. Let's run it as follow:

cargo new tetris --bin

You should have a new folder UFUSJT containing the following: UFUSJT

]

]$BSHPUPNM

]TSD

]

]NBJOST

Note that if you ran DBSHPOFX without the CJO flag, then you will have a MJCST file instead of NBJOST.

[ 44 ]





Starting with SDL

Chapter 2

Now write this into your $BSHPUPNM file:

<QBDLBHF>

OBNFUFUSJT

WFSTJPO

<EFQFOEFODJFT>

TEM

Here, we declare that our project's name is UFUSJT, its version is (it isn't really important at the moment), and that it has a dependency on the TEM crate.

For the versioning, $BSHP follows SemVer (Semantic Versioning). It works as follows:

<NBKPS><NJOPS><QBUI>

So here's exactly what every part means:

Update the <NBKPS> number version when you make incompatible API changes Update the <NJOPS> number version when adding functionalities that don't break backward compatibility

Update the <QBUDI> number version when you make bug fixes that don't break backward compatibility

It's not vital to know this, but it's always nice to be aware of it in case you intend to write crates in the future.

Cargo and crates.io

A very important thing to note with Rust's ecosystem is that $BSHP is really important if not central. It makes things much easier and all Rust projects are using it.

[ 45 ]



Starting with SDL

Chapter 2

Cargo isn't only a build tool, it's also Rust's default package manager. If you need to download a dependency, $BSHP will do it. You can find all available published crates on IUUQTDSBUFTJP. Consider the following screenshot:

'JHVSF

In the case of the TEM crate, we can see on its page (IUUQTDSBUFTJPDSBUFTTEM) some interesting and useful information:

[ 46 ]





Starting with SDL

Chapter 2

'JHVSF

On the right-hand side, you can see the version history. It can be useful to check whether you have the last version or not and whether the crate is still maintained.

In the middle, you have the crate's dependencies. It's always interesting to know what you'll need to install in addition to your crate if something is missing.

And finally on the left-hand side, you have a few links that might be very useful (not always those ones, it depends on what has been put into the $BSHPUPNM file): Documentation: This is where the documentation is hosted (even though I generally recommend EPDTST, I'll talk about it in a moment) Repository: This is where this crate's repository is hosted Dependent crates: This is the list of the crates depending on this one Homepage: If the crate has a website, you can go to its link Time to go back to EPDTST for a bit.

The docs.rs documentation

Every published crate on DSBUFTJP gets its documentation generated and hosted on IUUQTEPDTST. If the crate's documentation hasn't been published by anyone anywhere online, you'll find it there as long as it has been published. With DSBUFTJP and SVTU

MBOHPSH, it's one of the most known places of the Rust ecosystem, so bookmark it and doesn't lose it!

[ 47 ]





Starting with SDL

Chapter 2

Here's a screenshot of what EPDTST looks like:

'JHVSF

Back to our Cargo.toml file

To go back to our $BSHPUPNM file, it's also possible to use crates directly from their repositories; you just have to specify this when adding the dependency in your $BSHPUPNM file. Generally, the published version is less advanced than the one on the corresponding repository but will be more stable.

So for example, if we want to use the repository version for the TEM crate, we need to write in our $BSHPUPNM file:

<EFQFOEFODJFT>

TEM\HJUIUUQTHJUIVCDPN3VTU4%-SVTUTEM^

[ 48 ]





Starting with SDL

Chapter 2

Easy right? $BSHP can also start tests or benchmarks, install binaries, handle special builds through a build file (by default in CVJMEST), or handle features (we'll come back to this point later in this part).

To put it simply, it's a complete tool, and explaining most of its features would take a lot of time and space, so we'll just stick to the basics for the moment.

You can find a very good documentation/tutorial on Cargo at IUUQEPD

DSBUFTJPJOEFYIUNM.

Rust's modules

Before going any further, we need to talk about how file hierarchy works in Rust through its modules.

The first thing to know is that files and folders are handled as modules in Rust. Consider the following:

]TSD

]

]NBJOST

]BOPUIFS@GJMFST

If you want to declare that a module is in the BOPUIFS@GJMFST file, you'll need to add to your NBJOST file:

NPEBOPUIFS@GJMF

You will now have access to everything contained in BOPUIFS@GJMFST (as long as it's public).

Another thing to know: you can only declare modules whose files are on the same level as your current module/file. Here's a short example to sum this up:

]TSD

]

]NBJOST

]TVCGPMEFS

]BOPUIFS@GJMFST

[ 49 ]

Starting with SDL

Chapter 2

If you try to declare a module referring to BOPUIFS@GJMFST directly into NBJOST, as shown preceding, it'll fail because there are no BOPUIFS@GJMFST in TSD. In this case, you'll need to do three things:

1. Add a NPEST file into the TVCGPMEFS folder.

2. Declare BOPUIFS@GJMF into NPEST.

3. Declare TVCGPMEFS into NBJOST.

You certainly wonder, why NPEST? It's the norm in Rustbwhen you import a module, which is a folder, the compiler will look for a file named NPEST into it. The NPEST files are mainly used for re-exporting modules' content outside.

Let's now write down the code to do this:

Inside NPEST:

QVCNPEBOPUIFS@GJMF

Inside NBJOST:

NPETVCGPMEFS

Now, you can use everything that is in BOPUIFS@GJMF (as long as it's public!). Consider the following example:

VTFTVCGPMEFSBOPUIFS@GJMFTPNF@GVODUJPO

You will certainly have noticed that we declared BOPUIFS@GJMF publicly in NPEST. It's simply because NBJOST won't be able to access its content otherwise, as it's not at the same module level. However, a child module can access a parent's private items.

To conclude this small part, let's talk about the third type of modules: the module blocks (yes, as simple as that).

Just like you import a file or a folder, you can create a module block by using the same keyword:

NPEB@NPEVMF\

QVCTUSVDU'PP

^

And you now created a new module named B@NPEVMF containing a public structure. The rules described previously are applied the same way to this last kind of module.

[ 50 ]





Starting with SDL

Chapter 2

You now know how to use modules to import files and folders. Let's start writing down our game!

Tetris

Okay, we're now ready to start writing down our tetris!

First, let's fulfill our NBJOST file in order to check whether everything is working as expected:

FYUFSODSBUFTEM

VTFTEMQJYFMT$PMPS

VTFTEMFWFOU&WFOU

VTFTEMLFZCPBSE,FZDPEF

VTFTUEUJNF%VSBUJPO

VTFTUEUISFBETMFFQ

QVCGONBJO\

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPO

GBJMFE

MFUWJEFP@TVCTZTUFNTEM@DPOUFYUWJEFPFYQFDU$PVMEO UHFU

4%-WJEFPTVCTZTUFN

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPXSVTUTEMEFNP7JEFP



QPTJUJPO@DFOUFSFE

PQFOHM

CVJME

FYQFDU'BJMFEUPDSFBUFXJOEPX

MFUNVUDBOWBTXJOEPXJOUP@DBOWBTCVJMEFYQFDU'BJMFEUP

DPOWFSUXJOEPXJOUPDBOWBT

DBOWBTTFU@ESBX@DPMPS$PMPS3(#

DBOWBTDMFBS

DBOWBTQSFTFOU

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFEUP

HFU4%-FWFOUQVNQ

SVOOJOHMPPQ\

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

NBUDIFWFOU\

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^

[ 51 ]





Starting with SDL

Chapter 2

\

CSFBL SVOOJOH

^

@ \^

^

^

TMFFQ%VSBUJPOOFX@@@V

^

^

You'll note the following line:

TUEUISFBETMFFQ%VSBUJPOOFX@@@V

It allows you to avoid using all your computer CPU time needlessly and only rendering 60

times every second at most.

Now run the following in your terminal:

$ cargo run

If you have a window filled with red (just as shown in the following screenshot), then everything's fine!

'JHVSF

Creating a window

The previous example created a window and drew into it. Now let's see how it did that!

[ 52 ]

Starting with SDL

Chapter 2

Before going any further, we need to import the SDL2 crate, as follows: FYUFSODSBUFTEM

With this, we now have access to everything it contains.

Now that we've imported TEM, we need to initialize an SDL context: MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPOGBJMFE

Once done, we need to get the video subsystem:

MFUWJEFP@TVCTZTUFNTEM@DPOUFYUWJEFPFYQFDU$PVMEO UHFU4%-

WJEFPTVCTZTUFN

We can now create the window:

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPX5FUSJT

QPTJUJPO@DFOUFSFE

PQFOHM

CVJME

FYQFDU'BJMFEUPDSFBUFXJOEPX

A few notes on these methods:

The parameters for the XJOEPX method are title, width, height QPTJUJPO@DFOUFSFE gets the window in the middle of the screen PQFOHM makes the SDL use PQFOHM to render

CVJME creates the window by applying all previously received parameters FYQFDU panics with the given message if an error occurred If you try to run this sample of code, it'll display a window and close it super quickly. We now need to add an event loop in order to keep it running (and then to manage user inputs).

At the top of the file, you need to add this:

VTFTEMFWFOU&WFOU

VTFTEMLFZCPBSE,FZDPEF

VTFTUEUISFBETMFFQ

VTFTUEUJNF%VSBUJPO

[ 53 ]





Starting with SDL

Chapter 2

Now let's actually write our event manager. First, we need to get the event handler as follows:

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFEUP

HFU4%-FWFOUQVNQ

Then, we create an infinite loop to loop over events: SVOOJOHMPPQ\

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

NBUDIFWFOU\

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^ \

CSFBL SVOOJOH8FCSFBLUIFJOGJOJUFMPPQ

^

@ \^

^

^

TMFFQ%VSBUJPOOFX@@@V

^

To go back on these two lines:

SVOOJOHMPPQ\

CSFBL SVOOJOH

MPPQ is a keyword that allows creating an infinite loop in Rust. An interesting feature though is that you can add a label to your loops (so, XIJMF and GPS as well). In this case, we added the label SVOOJOH to the main loop. The point is to be able to break directly an upper loop without having to set a variable.

Now, if we receive a RVJU event (pressing the cross of the window) or if you press the Esc key, the program quits.

Now you can run this code and you'll have a window.

Drawing

We now have a working window; it'd be nice to draw into it. First, we need to get the window's canvas before starting the main loop:

MFUNVUDBOWBTXJOEPXJOUP@DBOWBT

UBSHFU@UFYUVSF

QSFTFOU@WTZOD

CVJME

[ 54 ]

Starting with SDL

Chapter 2

FYQFDU$PVMEO UHFUXJOEPX TDBOWBT

A few explanations for the preceding code:

JOUP@DBOWBT transforms the window into a canvas so that we can manipulate it more easily

UBSHFU@UFYUVSF activates texture rendering support QSFTFOU@WTZOD enables the v-sync (also known as vertical-synchronization) limit

CVJME creates the canvas by applying all previously set parameters Then we'll create a texture that we'll paste onto the window's canvas. First, let's get the texture creator, but before that, add this include at the top of the file: VTFTEMSFOEFS\$BOWBT5FYUVSF5FYUVSF$SFBUPS^

Now we can get the texture creator:

MFUUFYUVSF@DSFBUPS5FYUVSF$SFBUPS@ DBOWBTUFYUVSF@DSFBUPS

OK! Now we need to create a rectangle. To make things easier to read, we'll create a constant that will be the texture's size (better to put it at the head of the file, just after the imports, for readability reasons):

DPOTU5&9563&@4*;&V

Let's create a texture with a Y size:

MFUNVUTRVBSF@UFYUVSF5FYUVSF

UFYUVSF@DSFBUPSDSFBUF@UFYUVSF@UBSHFU/POF5&9563&@4*;& 5&9563&@4*;&

FYQFDU'BJMFEUPDSFBUFBUFYUVSF

Good! Now let's color it. First, add this import at the top of the file: VTFTEMQJYFMT$PMPS

We use the canvas to draw our square texture:

DBOWBTXJUI@UFYUVSF@DBOWBTNVUTRVBSF@UFYUVSF]UFYUVSF]\ UFYUVSFTFU@ESBX@DPMPS$PMPS3(#

UFYUVSFDMFBS

^

[ 55 ]

Starting with SDL

Chapter 2

An explanation of the preceding code is as follows: TFU@ESBX@DPMPS sets the color to be used when drawing occurs. In our case, it's green.

DMFBS washes/clears the texture so it'll be filled with green.

Now, we just have to draw this square texture onto our window. In order to make it work, we need it to be drawn into the main loop but right after the event loop.

One thing to note before we continue: when drawing with the 4%-, the (0, 0) coordinates are at the top-left of a window, not at the bottom-left. The same goes for all shapes.

Add this import at the top of your file:

VTFTEMSFDU3FDU

Now let's draw. In order to be able to update the rendering of your window, you need to draw inside the main loop (and after the event loop). So firstly, let's fill our window with red:

DBOWBTTFU@ESBX@DPMPS$PMPS3(#

DBOWBTDMFBS

Next, we copy our texture into the window in the top-left corner with a 32x32 size: DBOWBTDPQZTRVBSF@UFYUVSF

/POF

3FDUOFX5&9563&@4*;&5&9563&@4*;& FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

Finally, we update the window's display:

DBOWBTQSFTFOU

So if we take a look at the full code, we now have the following: FYUFSODSBUFTEM

VTFTEMFWFOU&WFOU

VTFTEMLFZCPBSE,FZDPEF

VTFTEMQJYFMT$PMPS

VTFTEMSFDU3FDU

VTFTEMSFOEFS\5FYUVSF5FYUVSF$SFBUPS^

VTFTUEUISFBETMFFQ

VTFTUEUJNF%VSBUJPO

[ 56 ]

Starting with SDL

Chapter 2

GONBJO\

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPO

GBJMFE

MFUWJEFP@TVCTZTUFNTEM@DPOUFYUWJEFPFYQFDU$PVMEO UHFU

4%-WJEFPTVCTZTUFN

1BSBNFUFSTBSFUJUMFXJEUIIFJHIU

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPX5FUSJT

QPTJUJPO@DFOUFSFEUPQVUJUJOUIFNJEEMFPGUIFTDSFFO

CVJMEUPDSFBUFUIFXJOEPX

FYQFDU'BJMFEUPDSFBUFXJOEPX

MFUNVUDBOWBTXJOEPXJOUP@DBOWBT

UBSHFU@UFYUVSF

QSFTFOU@WTZOD5PFOBCMFWTZOD

CVJME

FYQFDU$PVMEO UHFUXJOEPX TDBOWBT

MFUUFYUVSF@DSFBUPS5FYUVSF$SFBUPS@

DBOWBTUFYUVSF@DSFBUPS

5PNBLFUIJOHTFBTJFSUPSFBEXF MMDSFBUFBDPOTUBOU

XIJDIXJMMCFUIFUFYUVSF TTJ[F

DPOTU5&9563&@4*;&V

8FDSFBUFBUFYUVSFXJUIBYTJ[F

MFUNVUTRVBSF@UFYUVSF5FYUVSF

UFYUVSF@DSFBUPSDSFBUF@UFYUVSF@UBSHFU/POF5&9563&@4*;& 5&9563&@4*;&

FYQFDU'BJMFEUPDSFBUFBUFYUVSF

8FVTFUIFDBOWBTUPESBXJOUPPVSTRVBSFUFYUVSF

DBOWBTXJUI@UFYUVSF@DBOWBTNVUTRVBSF@UFYUVSF]UFYUVSF]\ 8FTFUUIFESBXDPMPSUPHSFFO

UFYUVSFTFU@ESBX@DPMPS$PMPS3(#

8FDMFBSPVSUFYUVSFTPJU MMCFGVMGJMMFEXJUIHSFFO

UFYUVSFDMFBS

^FYQFDU'BJMFEUPDPMPSBUFYUVSF

'JSTUXFHFUUIFFWFOUIBOEMFS

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFE

UPHFU4%-FWFOUQVNQ

5IFOXFDSFBUFBOJOGJOJUFMPPQUPMPPQPWFSFWFOUT

SVOOJOHMPPQ\

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

NBUDIFWFOU\

*GXFSFDFJWFB RVJU FWFOUPSJGUIFVTFSQSFTTUIF

&4$ LFZXFRVJU

[ 57 ]





Starting with SDL

Chapter 2

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^ \

CSFBL SVOOJOH8FCSFBLUIFJOGJOJUFMPPQ

^

@ \^

^

^

8FTFUGVMGJMMPVSXJOEPXXJUISFE

DBOWBTTFU@ESBX@DPMPS$PMPS3(#

8FESBXJU

DBOWBTDMFBS

$PQZPVSUFYUVSFJOUPUIFXJOEPX

DBOWBTDPQZTRVBSF@UFYUVSF

/POF

8FDPQZJUBUUIFUPQMFGUPGUIFXJOEPXXJUIBYTJ[F

3FDUOFX5&9563&@4*;&5&9563&@4*;& FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

8FVQEBUFXJOEPX TEJTQMBZ

DBOWBTQSFTFOU

8FTMFFQFOPVHIUPHFU_GQT*GXFEPO UDBMMUIJT

UIFQSPHSBNXJMMUBLF

PGB$16UJNF

TMFFQ%VSBUJPOOFX@@@V

^

^

If you run this code, you should have a red window with a small green rectangle at the top-left (just as shown in the following screenshot):

'JHVSF

[ 58 ]

Starting with SDL

Chapter 2

Now, what about switching the color of our small rectangle every second? Alright, first thing, we need to create another rectangle. To make things easier, we'll write a small function that will create texture.

As usual, add the following import at the top of your file: VTFTEMWJEFP\8JOEPX8JOEPX$POUFYU^

For convenience, we'll create a small enum to indicate the color as well:

<EFSJWF$MPOF$PQZ>

FOVN5FYUVSF$PMPS\

(SFFO

#MVF

^

To make our lives easier, we'll handle errors outside of the next function, so no need to handle them directly here:

GODSFBUF@UFYUVSF@SFDU B DBOWBTNVU$BOWBT8JOEPX

UFYUVSF@DSFBUPS B5FYUVSF$SFBUPS8JOEPX$POUFYU

DPMPS5FYUVSF$PMPSTJ[FV 0QUJPO5FYUVSF B \

8F MMXBOUUPIBOEMFGBJMVSFTPVUTJEFPGUIJTGVODUJPO

JGMFU0LNVUTRVBSF@UFYUVSF

UFYUVSF@DSFBUPSDSFBUF@UFYUVSF@UBSHFU/POFTJ[FTJ[F\

DBOWBTXJUI@UFYUVSF@DBOWBTNVUTRVBSF@UFYUVSF]UFYUVSF]\ NBUDIDPMPS\

5FYUVSF$PMPS(SFFO

UFYUVSFTFU@ESBX@DPMPS$PMPS3(#

5FYUVSF$PMPS#MVF

UFYUVSFTFU@ESBX@DPMPS$PMPS3(#

^

UFYUVSFDMFBS

^FYQFDU'BJMFEUPDPMPSBUFYUVSF

4PNFTRVBSF@UFYUVSF

^FMTF\

/POF

^

^

You'll note that the function returns an 0QUJPO type, wrapping a texture. 0QUJPO is an enum containing two variants: 4PNF and /POF.

[ 59 ]





Starting with SDL

Chapter 2

Playing with Options

To explain briefly how it works, when the 0QUJPO type is 4PNF, it simply means it contains a value whereas /POF doesn't. It has already been explained in $IBQUFS, Basics of Rust, but here's a little recap just in case you need one. We can compare this mechanism with pointers in C-like languages; when the pointer is null, there is no data to access. The same goes for

/POF.

Here's a short example:

GOEJWJEFOCVEJWJEFSV 0QUJPOV \

JGEJWJEFS\

/POF

^FMTF\

4PNFOCEJWJEFS

^

^

So here, if the divider is , we can't divide or we'll get an error. Instead of setting an error or returning a complicated type, we just return an 0QUJPO: MFUYEJWJEF

MFUZEJWJEF

Here, Y is equal to 4PNF and Z is equal to /POF.

The biggest advantage of this type compared to OVMM is that if we have 4PNF, you're sure that the data is valid. And in addition, when it's /POF, you can't accidentally read its content, it's simply impossible in Rust (and if you try to VOXSBQ it, your program will panic immediately, but at least, you'll know what failed and whybno magical segmentation fault).

You can take a look at its documentation at IUUQTEPDSVTUMBOHPSHTUEPQUJPO

FOVN0QUJPOIUNM.

Let's explain what happens here:

1. We create a texture or return /POF if the creation fails.

2. We set the color and then fulfill the texture with it.

3. We return the texture.

If we return /POF, it simply means an error occurred. Also, for now, this function only handles two colors, but it's pretty easy to add more if you want.

[ 60 ]





Starting with SDL

Chapter 2

It might look a bit complicated at the moment, but it'll make our life easier afterward. Now, let's call this function by creating a blue square of size 32x32: MFUNVUCMVF@TRVBSFDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS

5FYUVSF$PMPS#MVF

5&9563&@4*;&FYQFDU'BJMFEUPDSFBUFBUFYUVSF

Easy, right?

Now we can just put pieces together. I'll let you try to handle the color switch. A small tip: take a look at the 4ZTUFN5JNF struct. You can refer to its documentation at IUUQTEPDSVTUMBOHPSHTUBCMFTUEUJNF

TUSVDU4ZTUFN5JNFIUNM.

Solution

I guess you did it without any issues, but in any case, here's the code: FYUFSODSBUFTEM

VTFTEMFWFOU&WFOU

VTFTEMLFZCPBSE,FZDPEF

VTFTEMQJYFMT$PMPS

VTFTEMSFDU3FDU

VTFTEMSFOEFS\$BOWBT5FYUVSF5FYUVSF$SFBUPS^

VTFTEMWJEFP\8JOEPX8JOEPX$POUFYU^

VTFTUEUISFBETMFFQ

VTFTUEUJNF\%VSBUJPO4ZTUFN5JNF^

5PNBLFUIJOHTFBTJFSUPSFBEXF MMDSFBUFBDPOTUBOUXIJDI

XJMMCFUIFUFYUVSF TTJ[F

DPOTU5&9563&@4*;&V

<EFSJWF$MPOF$PQZ>

FOVN5FYUVSF$PMPS\

(SFFO

#MVF

^

GODSFBUF@UFYUVSF@SFDU B DBOWBTNVU$BOWBT8JOEPX

UFYUVSF@DSFBUPS B5FYUVSF$SFBUPS8JOEPX$POUFYU

DPMPS5FYUVSF$PMPS

TJ[FV 0QUJPO5FYUVSF B \

[ 61 ]

Starting with SDL

Chapter 2

8F MMXBOUUPIBOEMFGBJMVSFTPVUTJEFPGUIJTGVODUJPO

JGMFU0LNVUTRVBSF@UFYUVSF

UFYUVSF@DSFBUPSDSFBUF@UFYUVSF@UBSHFU/POFTJ[FTJ[F\

DBOWBTXJUI@UFYUVSF@DBOWBTNVUTRVBSF@UFYUVSF]UFYUVSF]\ NBUDIDPMPS\

'PSOPX5FYUVSF$PMPSPOMZIBOEMFTUXPDPMPST

5FYUVSF$PMPS(SFFO UFYUVSFTFU@ESBX@DPMPS$PMPS3(#



5FYUVSF$PMPS#MVF UFYUVSFTFU@ESBX@DPMPS$PMPS3(#



^

UFYUVSFDMFBS

^FYQFDU'BJMFEUPDPMPSBUFYUVSF

4PNFTRVBSF@UFYUVSF

^

FMTF\

"OFSSPSPDDVSFETPXFSFUVSOOPUIJOHBOEMFUUIFGVODUJPO

DBMMFSIBOEMFUIFFSSPS

/POF

^

^

GONBJO\

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPO

GBJMFE

MFUWJEFP@TVCTZTUFNTEM@DPOUFYUWJEFPFYQFDU$PVMEO UHFU

4%-WJEFPTVCTZTUFN

1BSBNFUFSTBSFUJUMFXJEUIIFJHIU

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPX5FUSJT

QPTJUJPO@DFOUFSFEUPQVUJUJOUIFNJEEMFPGUIFTDSFFO

CVJMEUPDSFBUFUIFXJOEPX

FYQFDU'BJMFEUPDSFBUFXJOEPX

MFUNVUDBOWBTXJOEPXJOUP@DBOWBT

UBSHFU@UFYUVSF

QSFTFOU@WTZOD5PFOBCMFWTZOD

CVJME

FYQFDU$PVMEO UHFUXJOEPX TDBOWBT

MFUUFYUVSF@DSFBUPS5FYUVSF$SFBUPS@

DBOWBTUFYUVSF@DSFBUPS

8FDSFBUFBUFYUVSFXJUIBYTJ[F

MFUHSFFO@TRVBSFDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS

5FYUVSF$PMPS(SFFO

5&9563&@4*;&FYQFDU'BJMFEUPDSFBUFBUFYUVSF

[ 62 ]

Starting with SDL

Chapter 2

MFUCMVF@TRVBSFDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS

5FYUVSF$PMPS#MVF

5&9563&@4*;&FYQFDU'BJMFEUPDSFBUFBUFYUVSF

MFUUJNFS4ZTUFN5JNFOPX

'JSTUXFHFUUIFFWFOUIBOEMFS

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFE

UPHFU4%-FWFOUQVNQ

5IFOXFDSFBUFBOJOGJOJUFMPPQUPMPPQPWFSFWFOUT

SVOOJOHMPPQ\

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

NBUDIFWFOU\

*GXFSFDFJWFB RVJU FWFOUPSJGUIFVTFSQSFTTUIF

&4$ LFZXFRVJU

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^ \

CSFBL SVOOJOH8FCSFBLUIFJOGJOJUFMPPQ

^

@ \^

^

^

8FGJMMPVSXJOEPXXJUISFE

DBOWBTTFU@ESBX@DPMPS$PMPS3(#

8FESBXJU

DBOWBTDMFBS

5IFSFDUBOHMFTXJUDIIBQQFOTIFSF

MFUEJTQMBZ@HSFFONBUDIUJNFSFMBQTFE\

0LFMBQTFE FMBQTFEBT@TFDT

&SS@ \

*ODBTFPGFSSPSXFEPOPUIJOH

USVF

^

^

MFUTRVBSF@UFYUVSFJGEJTQMBZ@HSFFO\

HSFFO@TRVBSF

^FMTF\

CMVF@TRVBSF

^

$PQZPVSUFYUVSFJOUPUIFXJOEPX

DBOWBTDPQZTRVBSF@UFYUVSF

/POF

8FDPQZJUBUUIFUPQMFGUPGUIFXJOEPXXJUIBY

TJ[F

[ 63 ]





Starting with SDL

Chapter 2

3FDUOFX5&9563&@4*;&5&9563&@4*;& FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

8FVQEBUFXJOEPX TEJTQMBZ

DBOWBTQSFTFOU

8FTMFFQFOPVHIUPHFU_GQT*GXFEPO UDBMMUIJT

UIFQSPHSBNXJMMUBLF

PGB$16UJNF

TMFFQ%VSBUJPOOFX@@@V

^

^

You can now see the small rectangle at the top-left switching color every second.

Loading images

Uptill now, we've only created simple textures, but what about loading images instead?

Before trying to go through this, check whether you have installed the 4%-@JNBHF library (it's not included by default with the SDL2 library!). If not, you can install it by following the upcoming sections.

Installing SDL2_image on Mac

Just run the following:

$ brew install SDL2_image

And you're good to go!

Installing SDL2_image on Linux

Depending on your package management tool, run the following to install 4%-@JNBHF on Linux:

For BQUQBDLBHFNBOBHFS use the following command:

$ sudo apt-get install libsdl2-image-2.0-0-dev For EOGQBDLBHFNBOBHFS use the following command:

$ sudo dnf install SDL2_image-devel

[ 64 ]





Starting with SDL

Chapter 2

For ZVNQBDLBHFNBOBHFS use the following command:

$ yum install SDL2_image-devel

And you're good to go!

Installing SDL2_image on Windows

For the Windows platform, the simplest way is to go to IUUQTXXXMJCTEMPSH

QSPKFDUT4%-@JNBHF and download it.

Playing with features

By default, you can't use the JNBHF module with TEM, we need to activate it. To do so, we need to update our $BSHPUPNM file by adding a new section as follows:

<GFBUVSFT>

EFGBVMU<TEMJNBHF>

EFGBVMU means that by default, the following features (TEMJNBHF) will be enabled.

Now, let's explain what TEMJNBHF means; TEM refers to the crate where we want to enable a feature and JNBHF is the feature we want to enable.

Of course, if you want to enable a feature on the current project, you don't need the TEM

part. Consider the following example:

<GFBUVSFT>

OFUXPSL<>

EFGBVMU<OFUXPSL>

As I am sure you understood, it's absolutely possible to chain features activation and even to activate multiple features at once! If you want to enable features depending on a version number, for example:

<GFBUVSFT>

OFUXPSL@W<>

OFUXPSL@W<OFUXPSL@W>

OFUXPSL@W<OFUXPSL@W>

W<OFUXPSL@W>

W<WOFUXPSL@W>

W<WOFUXPSL@W>

[ 65 ]





Starting with SDL

Chapter 2

So if you enable the W feature, all the others will be activated as well! It can be incredibly useful when you need to handle multiple versions at once.

Now let's go back to our images.

Playing with images

Just like textures, we need to initialize the image context. Now that we've activated the JNBHF feature, we can call the linked functions and import them. Let's add some new imports:

VTFTEMJNBHF\-PBE5FYUVSF*/*5@1/(*/*5@+1(^

Then we create the image context:

TEMJNBHFJOJU*/*5@1/(]*/*5@+1(FYQFDU$PVMEO UJOJUJBMJ[F

JNBHFDPOUFYU

Now that the context has been initialized, let's actually load the image: MFUJNBHF@UFYUVSF

UFYUVSF@DSFBUPSMPBE@UFYUVSFBTTFUTNZ@JNBHFQOH

FYQFDU$PVMEO UMPBEJNBHF

A few explanations for the preceding code:

MPBE@UFYUVSF takes a file path as an argument. Be very careful with paths, even more when they're relative!

After that, it's just like we did with other textures. Let's put our image into our Window's background:

DBOWBTDPQZ*NBHF@UFYUVSF/POF/POFFYQFDU3FOEFSGBJMFE

To sum everything up, here's what your project's folder should look like now:

]ZPVS@QSPKFDU

]

]$BSHPUPNM

]TSD

]]

]]NBJOST

]BTTFUT

]

]NZ@JNBHFQOH

[ 66 ]

Starting with SDL

Chapter 2

And that's it!

Here's the full code in case you missed a step:

FYUFSODSBUFTEM

VTFTEMQJYFMT$PMPS

VTFTEMFWFOU&WFOU

VTFTEMLFZCPBSE,FZDPEF

VTFTEMSFOEFS5FYUVSF$SFBUPS

VTFTEMJNBHF\-PBE5FYUVSF*/*5@1/(*/*5@+1(^

VTFTUEUJNF%VSBUJPO

QVCGONBJO\

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPO

GBJMFE

MFUWJEFP@TVCTZTUFNTEM@DPOUFYUWJEFPFYQFDU$PVMEO U

HFU4%-WJEFPTVCTZTUFN

TEMJNBHFJOJU*/*5@1/(]*/*5@+1(FYQFDU$PVMEO U

JOJUJBMJ[F

JNBHFDPOUFYU

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPXSVTUTEMJNBHFEFNP



QPTJUJPO@DFOUFSFE

PQFOHM

CVJME

FYQFDU'BJMFEUPDSFBUFXJOEPX

MFUNVUDBOWBTXJOEPXJOUP@DBOWBTCVJMEFYQFDU'BJMFEUP

DPOWFSUXJOEPXJOUPDBOWBT

MFUUFYUVSF@DSFBUPS5FYUVSF$SFBUPS@

DBOWBTUFYUVSF@DSFBUPS

MFUJNBHF@UFYUVSF

UFYUVSF@DSFBUPSMPBE@UFYUVSFBTTFUTNZ@JNBHFQOH

FYQFDU$PVMEO UMPBEJNBHF

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFEUP

HFU4%-FWFOUQVNQ

SVOOJOHMPPQ\

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

NBUDIFWFOU\

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^

\

[ 67 ]





Starting with SDL

Chapter 2

CSFBL SVOOJOH

^

@ \^

^

^

DBOWBTTFU@ESBX@DPMPS$PMPS3(#

DBOWBTDMFBS

DBOWBTDPQZJNBHF@UFYUVSF/POF/POFFYQFDU3FOEFS

GBJMFE

DBOWBTQSFTFOU

TUEUISFBETMFFQ%VSBUJPOOFX@@@V

^

^

In my case, it gives the following output:

'JHVSF

[ 68 ]





Starting with SDL

Chapter 2

Now that we know how to make Windows and play with events and textures, let's see how to save and load high scores from files!

Handling files

Let's start with the basics. First, let's open and write into a file: VTFTUEGT'JMF

VTFTUEJP\TFMG8SJUF^

GOXSJUF@JOUP@GJMFDPOUFOUTUSGJMF@OBNFTUS JP3FTVMU \ MFUNVUG'JMFDSFBUFGJMF@OBNF

GXSJUF@BMMDPOUFOUBT@CZUFT

^

Now let's explain this code:

VTFTUEGT'JMF

Nothing fancy, we just import the 'JMF type:

VTFTUEJP\TFMG8SJUF^

This set of imports is more interesting: we import the JP module (TFMG) and the 8SJUF trait.

For the second, if we didn't import it, we wouldn't be able to use the XSJUF@BMM method (because you need to import a trait to use its methods): GOXSJUF@JOUP@GJMFDPOUFOUTUSGJMF@OBNFTUS JP3FTVMU \ We declared a function named XSJUF@JOUP@GJMF that takes a filename and the content you want to write into the file as arguments. (Note that the file will be overwritten by this content!) It returns an JP3FTVMU type. It is an alias over the normal 3FTVMU type (its documentation is at IUUQTEPDSVTUMBOHPSHTUBCMFTUESFTVMUFOVN3FTVMUIUNM) declared as follows:

UZQF3FTVMU5 3FTVMU5&SSPS

The only difference is that in case of error, the error type is already defined.

I recommend that you to take a look at its documentation in case you want to go further, at IUUQTEPDSVTUMBOHPSHTUBCMFTUEJPUZQF

3FTVMUIUNM.

[ 69 ]

Starting with SDL

Chapter 2

So if our function worked without errors, it'll return 0L; it's the 0L variant containing an empty tuple which is considered the Rust equivalent of the WPJE type. In case of error, it'll contain an JP&SSPS, and it'll be up to you to handle it (or not). We'll come back to error handling a bit later.

Now let's look at the next line:

MFUNVUG'JMFDSFBUFGJMF@OBNF

Here, we call the static method DSFBUF of the 'JMF type. If the file exists, it'll be truncated and if it doesn't, it'll be created. More information about this method can be found at IUUQTEPDSVTUMBOHPSHTUBCMFTUEGTTUSVDU'JMFIUNMNFUIPEDSFBUF.

Now let's look at this strange symbol. It's a syntactic sugar over the USZ macro. The USZ

macro is very simple to understand and its code can be resumed as this: NBUDISFTVMU\

0LWBMVF WBMVF

&SSFSSPS SFUVSO&SSFSSPS

^

So that's pretty easy, but annoying to rewrite over and over, so the Rust teams decided to first introduce the USZ macro and then after a long consensus, decided to add the syntactic sugar over it (it also works with the 0QUJPO type). However, both code pieces are still working, so you can perfectly do as well:

VTFTUEGT'JMF

VTFTUEJP\TFMG8SJUF^

GOXSJUF@JOUP@GJMFDPOUFOUTUSGJMF@OBNFTUS

JP3FTVMU \

MFUNVUGUSZ'JMFDSFBUFGJMF@OBNF

GXSJUF@BMMDPOUFOUBT@CZUFT

^

It's exactly the same. Alternatively, you can write the full version too: VTFTUEGT'JMF

VTFTUEJP\TFMG8SJUF^

GOXSJUF@JOUP@GJMFDPOUFOUTUSGJMF@OBNFTUS JP3FTVMU

\

MFUNVUGNBUDI'JMFDSFBUFGJMF@OBNF\

0LWBMVF WBMVF

&SSFSSPS SFUVSO&SSFSSPS

^

[ 70 ]

Starting with SDL

Chapter 2

GXSJUF@BMMDPOUFOUBT@CZUFT

^

It's up to you, but now you know what options you have!

Now let's check the last line:

GXSJUF@BMMDPOUFOUBT@CZUFT

Nothing fancy here; we write all our data into the file. We just need to convert (it's not really a conversion in this case, more like getting internal data) our TUS into a slice of V

(so a <V>).

Now that we have a function to write a file, it'd be nice to be able to read from a file as well: VTFTUEGT'JMF

VTFTUEJP\TFMG3FBE^

GOSFBE@GSPN@GJMFGJMF@OBNFTUS JP3FTVMU4USJOH \

MFUNVUG'JMFPQFOGJMF@OBNF

MFUNVUDPOUFOU4USJOHOFX

GSFBE@UP@TUSJOHNVUDPOUFOU

0LDPOUFOU

^

Now let's go over what this function does quickly: GOSFBE@GSPN@GJMFGJMF@OBNFTUS JP3FTVMU4USJOH \

This time, it only takes a filename as an argument and returns a 4USJOH if the reading was successful:

MFUNVUG'JMFPQFOGJMF@OBNF

MFUNVUDPOUFOU4USJOHOFX

GSFBE@UP@TUSJOHNVUDPOUFOU

Just like before, we open the file. Then we create a mutable 4USJOH where the file content will be stored and finally we read all the file content at once with the SFBE@UP@TUSJOH

method (the 4USJOH is reallocated as many times as needed). This method will fail if the string isn't proper UTF-8.

And to finish, if everything went fine, we return our content: 0LDPOUFOU

[ 71 ]





Starting with SDL

Chapter 2

So now, let's see how we can use this in our future tetris.

Saving/loading high scores

To keep things simple, we'll have a very simple file format: On the first line, we store the best scores

On the second line, we store the highest number of lines Let's start by writing the TBWF function:

GOTMJDF@UP@TUSJOHTMJDF<V> 4USJOH\

TMJDFJUFSNBQ]IJHITDPSF]IJHITDPSFUP@TUSJOH

DPMMFDU7FD4USJOH KPJO

^

GOTBWF@IJHITDPSFT@BOE@MJOFTIJHITDPSFT<V>

OVNCFS@PG@MJOFT<V> CPPM\

MFUT@IJHITDPSFTTMJDF@UP@TUSJOHIJHITDPSFT

MFUT@OVNCFS@PG@MJOFTTMJDF@UP@TUSJOHOVNCFS@PG@MJOFT

XSJUF@JOUP@GJMFGPSNBU\^=O\^=OT@IJHITDPSFT

T@OVNCFS@PG@MJOFTJT@PL

^

It was a small lie: there are actually two functions. The first one is just here to make the code smaller and easier to read even though we need to explain what it does, because we're about to talk about a big feature from Rustbiterators!

Iterators

The Rust documentation describes an iterator as Composable external iteration.

They're used a lot in idiomatic Rust code on collection types (TMJDF, 7FD, )BTI.BQ, and so on) so it's very important to learn to master them. This code will allow us to have a nice introduction. Let's look at the code now:

TMJDFJUFSNBQ]IJHITDPSF]IJHITDPSFUP@TUSJOH

DPMMFDU7FD4USJOH KPJO

This is quite difficult to read and understand for the moment, so let's rewrite it as follows: TMJDFJUFS

NBQ]IJHITDPSF]IJHITDPSFUP@TUSJOH

[ 72 ]



Starting with SDL

Chapter 2

DPMMFDU7FD4USJOH

KPJO

Better (or at least more readable!). Now let's go step by step, as follows: TMJDFJUFS

Here, we create an iterator from our slice. A really important and fundamental thing to note about iterators in Rust; they're lazy. Creating an iterator doesn't cost anything more than the size of the type (generally a structure containing a pointer and an index). Until the OFYU

method is called, nothing happens.

So now we have an iterator, awesome! Let's check the next step: NBQ]IJHITDPSF]IJHITDPSFUP@TUSJOH

We call the iterator's NBQ method. What it does is simple: it converts the current type into another one. So here, we convert a V into a 4USJOH.

Really important to note: at this point, the iterator still hasn't done anything. Keep in mind that nothing is done until the OFYU method is called!

DPMMFDU7FD4USJOH

And now we call the DPMMFDU method. It'll call the OFYU method of our iterator as long as it didn't get all elements and store them into a 7FD. This is where the NBQ method will be called on every element of our iterator.

And finally the last step:

KPJO

This method (as its name indicates) joins all the elements of the 7FD into a 4USJOH

separated by the given TUS (so, in our case).

Finally, if we give <> to the TMJDF@UP@TUSJOH function, it'll return a 4USJOH

containing . Pretty convenient, right?

If you want to go a bit deeper with the iterators, you can take a look at the blog post at IUUQTCMPHHVJMMBVNFHPNF[GSBSUJDMFT

-JUUMFUPVSPGNVMUJQMFJUFSBUPSTJNQMFNFOUBUJPOJO3VTU or directly take a look at the iterator official documentation at IUUQTEPD

SVTUMBOHPSHTUBCMFTUEJUFSJOEFYIUNM.

[ 73 ]





Starting with SDL

Chapter 2

It's time to go back to our saving function:

GOTBWF@IJHITDPSFT@BOE@MJOFTIJHITDPSFT<V>

OVNCFS@PG@MJOFT<V> CPPM\

MFUT@IJHITDPSFTTMJDF@UP@TUSJOHIJHITDPSFT

MFUT@OVNCFS@PG@MJOFTTMJDF@UP@TUSJOHOVNCFS@PG@MJOFT

XSJUF@JOUP@GJMFGPSNBU\^=O\^=OT@IJHITDPSFT

T@OVNCFS@PG@MJOFTTDPSFTUYUJT@PL

^

Once we have converted our slices to 4USJOH, we write them into the TDPSFTUYU file. The JT@PL method call just informs the caller of the TBWF@IJHITDPSFT@BOE@MJOFT

function if everything has been saved as expected or not.

Now that we can save scores, it'd be nice to be able to get them back when the tetris game is starting!

Reading formatted data from files

As you will certainly have guessed at this point, we'll use iterators once again. This is what the loading function will look like:

GOMJOF@UP@TMJDFMJOFTUS 7FDV \

MJOFTQMJUGJMUFS@NBQ]OC]

OCQBSTFV PLDPMMFDU

^

GOMPBE@IJHITDPSFT@BOE@MJOFT 0QUJPO7FDV 7FDV \

JGMFU0LDPOUFOUSFBE@GSPN@GJMFTDPSFTUYU\

MFUNVUMJOFTDPOUFOUTQMJUO=ONBQ]MJOF]

MJOF@UP@TMJDFMJOFDPMMFDU7FD@

JGMJOFTMFO\

MFUOVNCFS@MJOFTIJHITDPSFTMJOFTQPQVOXSBQ

MJOFTQPQVOXSBQ

4PNFIJHITDPSFTOVNCFS@MJOFT

^FMTF\

/POF

^

^FMTF\

/POF

^

^

[ 74 ]

Starting with SDL

Chapter 2

Once again, not easy to understand, at first sight. So let's explain all this!

GOMJOF@UP@TMJDFMJOFTUS 7FDV \

Our MJOF@UP@TMJDF function does the opposite of TMJDF@UP@TUSJOH; it transforms a TUS into a slice of V (or <V>). Let's see the iterator now: MJOFTQMJUGJMUFS@NBQ]OC]OCQBSTFV PLDPMMFDU

Just like last time, let's split the calls:

MJOFTQMJU

GJMUFS@NBQ]OC]OCQBSTFV PL

DPMMFDU

A bit better! Now let's explain:

MJOFTQMJU

We create an iterator that will contain all strings between spaces. So BC will contain B and C:

GJMUFS@NBQ]OC]OCQBSTFV PL

This method is particularly interesting since it's the merge of two others: GJMUFS and NBQ. We already know NBQ but what about GJMUFS? If the condition isn't verified (so if the returned value of the closure is GBMTF), the iterator won't pass the value to the next method call. GJMUFS@NBQ works the same at this point: if the closure returns /POF, the value won't be passed to the next method call.

Now let's focus on this part:

OCQBSTFV PL

Here, we try to convert TUS into V. The QBSTF method returns a 3FTVMU but the GJMUFS@NBQ expects an 0QUJPO so we need to convert it. That's what the PL method is for! If your 3FTVMU is an 0LWBMVF, then it'll convert it into a 4PNFWBMVF. However, if it's an &SSFSS, it'll convert it into a /POF (but you'll lose the error value).

To sum this up, this whole line tries to convert a TUS into a number and ignores it if the conversion fails so it's not added to our final 7FD. Amazing how much we can do with such small code!

[ 75 ]

Starting with SDL

Chapter 2

And finally:

DPMMFDU

We DPMMFDU all the successful conversions into a 7FD and return it.

That's it for this function, now let's look at the other one: GOMPBE@IJHITDPSFT@BOE@MJOFT 0QUJPO7FDV 7FDV \

Here, if everything went fine (if the file exists and has two lines), we return an 0QUJPO

containing in the first position the highest scores and in the second position the highest number of lines:

JGMFU0LDPOUFOUSFBE@GSPN@GJMFTDPSFTUYU\

So if the file exists and we can get its content, we parse the data: MFUNVUMJOFTDPOUFOUTQMJUO=ONBQ]MJOF]

MJOF@UP@TMJDFMJOFDPMMFDU7FD@

Another iterator! As usual, let's rewrite it a bit: MFUNVUMJOFTDPOUFOUTQMJUO=O

NBQ]MJOF]MJOF@UP@TMJDFMJOF

DPMMFDU7FD@

I think you're starting to get how they work, but just in case you don't know, here's how: DPOUFOUTQMJUO=O

We make an iterator containing at most two entries (because of the as the first argument) splitting lines:

NBQ]MJOF]MJOF@UP@TMJDFMJOF

We transform each line into a 7FDV by using the function described in the preceding code:

DPMMFDU7FD@

And finally, we collect those 7FDs into a 7FD7FDV , which should only contain two entries.

Let's look at the next line now:

JGMJOFTMFO\

[ 76 ]





Starting with SDL

Chapter 2

As said before, if we don't have two entries inside our 7FD, it means something is wrong with the file:

MFUOVNCFS@MJOFTIJHITDPSFTMJOFTQPQVOXSBQ

MJOFTQPQVOXSBQ

In case our 7FD has two entries, we can get the corresponding values. Since the QPQ method removes the last entry of the 7FD, we get them in reverse (even though we return high scores first then the highest number of lines):

4PNFIJHITDPSFTOVNCFS@MJOFT

Then everything else is just the error handling. As we said previously, if any error occurs, we return /POF. In this case, it's not really important to handle the error since it's just high scores. If we have errors with the TEM libraries, nothing will work as expected, so we need to handle them to avoid a panic.

It's now time to really start the game!

Summary

In this chapter, we saw a lot of important things like how to use $BSHP (through the $BSHPUPNM file), how to import new crates into a project, thanks to $BSHP, and the basics for Rust modules handling. We even covered how to use iterators and read and write files, 4%- basics like how to create a window and fill it with colors, and loading/creating new textures and images (thanks to the 4%-JNBHF library!).

In $IBQUFS, Events and Basic Game Mechanisms, we'll start the implementation of the tetris game, so be sure to master everything explained in this chapter before starting the next one!

[ 77 ]





3

Events and Basic Game

Mechanisms

In the last chapter, we saw how to add dependencies into a project thanks to $BSHP and the basics of the 4%- library.

We now have all the Rust basics in order to write the Tetris game. Time to look at how we will actually write Tetris.

In this chapter, we will cover the following topics: Tetrimino

Creating tetriminos

Generating a tetrimino

Tetris struct

Interacting with the game map

SDL events

Score, level, lines sent

Writing Tetris

First, let's review the Tetris rules (just in case): There is a grid with a height of 16 blocks and a width of 10 blocks.

You have seven different UFUSJNJOP (a tetris piece) that are all composed of four blocks.





Events and Basic Game Mechanisms

Chapter 3

A new UFUSJNJOP appears at the top of the game's grid every time the previous one cannot descend any more (because the block below is already occupied or because you've reached the game's floor).

The game is over when a new UFUSJNJOP cannot appear anymore (because there is already a tetrimino at the top of the grid).

Every time a line is full (all blocks are occupied by a UFUSJNJOP part), it disappears and all lines above descend by one line.

Now that we all agree on the game rules, let's see how to actually write those mechanisms.

First, we need to actually create those UFUSJNJOPs.

Tetrimino

As said previously, every UFUSJNJOP has four blocks. Another thing to note is that they can rotate. So for example you have this UFUSJNJOP:

'JHVSF

It can also rotate in the three following positions:



'JHVSF

Theoretically, every UFUSJNJOP should have four states, but in reality, not all of them do.

For example, this one has no transformation so to speak:

[ 79 ]





Events and Basic Game Mechanisms

Chapter 3

'JHVSF

And these three only have two states:

'JHVSF

We have two ways of handling these rotations: using matrix rotation or storing the different states. To have a code that's easy to read and update, I picked the second option, but don't hesitate to try using matrix on your own, it could help you learn a lot of new things!

[ 80 ]



Events and Basic Game Mechanisms

Chapter 3

So first, let's write down a TUSVDU for UFUSJNJOPs: TUSVDU5FUSJNJOP\

TUBUFT7FD7FD7FDV

YJTJ[F

ZVTJ[F

DVSSFOU@TUBUFV

^

Everything seems fine except this line:

TUBUFT7FD7FD7FDV

Pretty ugly, right? Let's make it look a bit better by using type aliasing!

So what is our TUBUFT field representing? Simply a list of states. Each state represents a piece's transformation. I suppose it's a bit hard to understand all of this. Let's write an example:

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

In here, means the block is empty, otherwise, it's a UFUSJNJOP block. So from reading this code, I suppose you could guess that we were representing the square:

'JHVSF

In case you wondered, we have four lines with four blocks because the biggest UFUSJNJOP

has a height (or a width, depending the transformation) of four:

[ 81 ]



Events and Basic Game Mechanisms

Chapter 3

'JHVSF

This isn't mandatory (we could make it fit the form of each UFUSJNJOP), but it makes our lives easier, so why not?

Coming back to our type aliasing: a piece is basically a vector or vector of numbers. It's long to write it down every time, so let's alias it as follows: UZQF1JFDF7FD7FDV

Now we can rewrite the TUBUFT field declaration as follows: TUBUFT7FD1JFDF

Way better and more explicit, right? But since we'll be using those states as well, why not alias them too?

UZQF4UBUFT7FD1JFDF

And now our TUBUFT field declaration becomes:

TUBUFT4UBUFT

Let's explain the other fields (just in case):

TUSVDU5FUSJNJOP\

TUBUFT4UBUFT

YJTJ[F

ZVTJ[F

DVSSFOU@TUBUFV

^

[ 82 ]





Events and Basic Game Mechanisms Chapter 3

A little explanation of this struct:

TUBUFT (if you didn't already understand it) is the list of possible states of the UFUSJNJOP

Y is the x position of the UFUSJNJOP

Z is the y position of the UFUSJNJOP

DVSSFOU@TUBUF is the state in which the UFUSJNJOP is currently Ok, so far so good. Now how should we handle the creation of this type generically? We don't want to rewrite this for every UFUSJNJOP. This is where USBJUT kick in!

Creating tetriminos

We wrote the type that will be used in our game, but we didn't write its initialization/creation yet. This is where Rust USBJUs will be useful.

Let's start by writing a generator trait that will be implemented on all UFUSJNJOPs: USBJU5FUSJNJOP(FOFSBUPS\

GOOFX 5FUSJNJOP

^

And that's it. This USBJU just provides a function that creates a new 5FUSJNJOP instance. It maybe doesn't like this very much, but thanks to this USBJU, we'll be able to easily create all our UFUSJNJOPs.

Time to write our first UFUSJNJOP:

TUSVDU5FUSJNJOP*

No need to look for more code, this is what a UFUSJNJOP really looks like. It's an empty structure. The interesting part comes just after:

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP*\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

[ 83 ]



Events and Basic Game Mechanisms

Chapter 3

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

Which is:

'JHVSF

In here, a number represents a color and means no color (because there is no block).

And that's it. Now you can create this UFUSJNJOP just by calling: MFUUFUSJNJOP5FUSJNJOP*OFX

It'll return an instance of the 5FUSJNJOP structure and that's the one you'll be using in the game. The other UFUSJNJOP structures (such as 5FUSJNJOP* in here) are just used to generically create the 5FUSJNJOP structure with the related information.

We now need to create all the other UFUSJNJOP as well, so let's do it: TUSVDU5FUSJNJOP+

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP+\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

[ 84 ]



Events and Basic Game Mechanisms

Chapter 3

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

In case you're wondering why the blocks have as values, it's simply so that we can differentiate them when displaying them (having all UFUSJNJOP with the same color wouldn't be very pretty...). It has no other meaning.

This UFUSJNJOP looks like this:

'JHVSF

-FU THPGPSUIFOFYUPOF

TUSVDU5FUSJNJOP-

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP-\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

[ 85 ]



Events and Basic Game Mechanisms

Chapter 3

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

This UFUSJNJOP looks like this:

'JHVSF

"OPUIFSUFUSJNJOP

TUSVDU5FUSJNJOP0

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP0\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

[ 86 ]





Events and Basic Game Mechanisms

Chapter 3

This UFUSJNJOP looks like this:

'JHVSF

Another UFUSJNJOP (will it ever end?!):

TUSVDU5FUSJNJOP4

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP4\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

This UFUSJNJOP looks like this:

'JHVSF

[ 87 ]



Events and Basic Game Mechanisms

Chapter 3

Guess what? Another UFUSJNJOP:

TUSVDU5FUSJNJOP;

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP;\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

This UFUSJNJOP looks like this:

'JHVSF

And the last one (finally!):

TUSVDU5FUSJNJOP5

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP5\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

[ 88 ]





Events and Basic Game Mechanisms

Chapter 3

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

And finally, this UFUSJNJOP looks like this:

'JHVSF

Phew... That was quite a lot of code! Easy code, but still a lot!

It's now time to see how we can generate a new UFUSJNJOP randomly.

Generating a tetrimino

In order to do so, we'll need to import another DSBUFbSBOE. This DSBUF is used to generate random numbers and that is exactly what we need here.

First, add the following line to your $BSHPUPNM file (in the <EFQFOEFODJFT> section): SBOE

Next, add the following line to your NBJOST file:

FYUFSODSBUFSBOE

[ 89 ]

Events and Basic Game Mechanisms Chapter 3

And we're done! Now we can write the generation function of the UFUSJNJOP: GODSFBUF@OFX@UFUSJNJOP 5FUSJNJOP\

MFUSBOE@OCSBOESBOEPNV

NBUDISBOE@OC\

5FUSJNJOP*OFX

5FUSJNJOP+OFX

5FUSJNJOP-OFX

5FUSJNJOP0OFX

5FUSJNJOP4OFX

5FUSJNJOP;OFX

5FUSJNJOP5OFX

@ VOSFBDIBCMF

^

^

Pretty easy, right? Though, please note that this is a bit too random. It'd be problematic if we had the same UFUSJNJOP generated more than twice in a row (which is already a lot!), so let's improve this function a bit by adding a TUBUJD variable: GODSFBUF@OFX@UFUSJNJOP 5FUSJNJOP\

TUBUJDNVU13&7V

MFUNVUSBOE@OCSBOESBOEPNV

JGVOTBGF\13&7^SBOE@OC\

SBOE@OCSBOESBOEPNV

^

VOTBGF\13&7SBOE@OC^

NBUDISBOE@OC\

5FUSJNJOP*OFX

5FUSJNJOP+OFX

5FUSJNJOP-OFX

5FUSJNJOP0OFX

5FUSJNJOP4OFX

5FUSJNJOP;OFX

5FUSJNJOP5OFX

@ VOSFBDIBCMF

^

^

A bit of explanation might be helpful here. First, what is a TUBUJD variable? It's a variable that will keep its value and won't be destroyed when the scope it has been created inside has been left. An example:

GOGPP V\

TUBUJDNVU7"-6&V

VOTBGF\

7"-6&

[ 90 ]





Events and Basic Game Mechanisms Chapter 3

7"-6&

^

^

GPS@JO\

QSJOUMO\^GPP

^

If you execute this code, it'll print out:

13

14

15

16

17

Here are the other properties of the TUBUJD variable: It cannot have a destructor (it's possible to avoid this limitation by using the MB[Z@TUBUJD crate though, but we won't talk about it here) so only simple types that don't implement the %SPQ trait can be used as TUBUJD

Changing the value of a TUBUJD variable is unsafe (that's why there are VOTBGF

blocks) for the simple reason that the TUBUJD is shared between all threads in the program and can be modified and read at the same time Reading the value of a mutable TUBUJD is unsafe (for the reason mentioned previously)

We now have a function that can generate a UFUSJNJOP. We now need to add the following functionalities:

Rotating

Changing position

Let's start with the rotation part!

Rotating a tetrimino

Thanks to how we created the 5FUSJNJOP type, it's quite easy to do: JNQM5FUSJNJOP\

GOSPUBUFNVUTFMG\

TFMGDVSSFOU@TUBUF

JGTFMGDVSSFOU@TUBUFBTVTJ[F TFMGTUBUFTMFO\

TFMGDVSSFOU@TUBUF

[ 91 ]

Events and Basic Game Mechanisms Chapter 3

^

^

^

And we're done. However, we don't check anything: what happens if there is a block already used by another UFUSJNJOP? We'll just overwrite it. Such a thing cannot be accepted!

In order to perform this check, we'll need the game map as well. It's simply a vector line and a line is a vector of V. Or, more simply:

7FD7FDV

Considering that it isn't too hard to read, we'll just keep it this way. Now let's write the method:

GOUFTU@QPTJUJPOTFMGHBNF@NBQ<7FDV >

UNQ@TUBUFVTJ[FYJTJ[FZVTJ[F CPPM\

GPSEFDBM@ZJO\

GPSEFDBM@YJO\

MFUYYEFDBM@Y

JGTFMGTUBUFT<UNQ@TUBUF><EFDBM@Z><EFDBM@YBTVTJ[F> ZEFDBM@Z HBNF@NBQMFO]]

Y]]

YBTVTJ[F HBNF@NBQ<ZEFDBM@Z>MFO]]

HBNF@NBQ<ZEFDBM@Z><YBTVTJ[F>\

SFUVSOGBMTF

^

^

^

SFUVSOUSVF

^

Before explaining this function, it seems important to explain why the game map became a

<7FDV >. When you send a non-mutable reference over a vector (7FD5 ), it is then dereferenced into a <5> slice, which is a constant view over the vector's content.

And we're done (for this method)! Now time for explanations: we loop over every block of our UFUSJNJOP and check whether the block is free in the game map (by checking whether it is equal to ) and if it isn't going out of the game map.

[ 92 ]

Events and Basic Game Mechanisms Chapter 3

Now that we have our UFTU@QPTJUJPO method, we can update the SPUBUF method: GOSPUBUFNVUTFMGHBNF@NBQ<7FDV >\

MFUNVUUNQ@TUBUFTFMGDVSSFOU@TUBUF

JGUNQ@TUBUFBTVTJ[F TFMGTUBUFTMFO\

UNQ@TUBUF

^

MFUY@QPT<>

GPSYJOY@QPTJUFS\

JGTFMGUFTU@QPTJUJPOHBNF@NBQUNQ@TUBUFBTVTJ[F

TFMGYYTFMGZUSVF\

TFMGDVSSFOU@TUBUFUNQ@TUBUF

TFMGYY

CSFBL

^

^

^

A bit longer, indeed. Since we can't be sure that the piece will be put where we want it to go, we need to make temporary variables and then check the possibilities. Let's go through the code:

MFUNVUUNQ@TUBUFTFMGDVSSFOU@TUBUF

JGUNQ@TUBUFBTVTJ[F TFMGTUBUFTMFO\

UNQ@TUBUF

^

This is exactly what our SPUBUF method did before, except that now, we use temporary variables before going further:

MFUY@QPT<>

This line on its own doesn't make much sense but it'll be very useful next: in case the piece cannot be placed where we want, we try to move it on the Y axis to see if it'd work in some other place. It allows you to have a Tetris that is much more flexible and comfortable to play:

GPSYJOY@QPTJUFS\

JGTFMGUFTU@QPTJUJPOHBNF@NBQUNQ@TUBUFBTVTJ[F

TFMGYYTFMGZUSVF\

TFMGDVSSFOU@TUBUFUNQ@TUBUF

TFMGYY

CSFBL

^

^

[ 93 ]

Events and Basic Game Mechanisms Chapter 3

With the explanations given previously, this loop should be really easy to understand. For each Y shift, we check whether the piece can be placed there. If it works, we change the values of our UFUSJNJOP, otherwise we just continue.

If no Y shift worked, we just leave the function without doing anything.

Now that we can rotate and test the position of a UFUSJNJOP, it'd be nice to actually move it as well (when the timer goes to 0 and the UFUSJNJOP needs to go down, for example). The main difference with the SPUBUF method will be that, if the UFUSJNJOP cannot move, we'll return a Boolean value to allow the caller to be aware of it.

So the method looks like this:

GODIBOHF@QPTJUJPONVUTFMGHBNF@NBQ<7FDV >OFX@YJTJ[F

OFX@ZVTJ[F CPPM\

JGTFMGUFTU@QPTJUJPOHBNF@NBQTFMGDVSSFOU@TUBUFBTVTJ[F

OFX@YOFX@ZUSVF\

TFMGYOFX@YBTJTJ[F

TFMGZOFX@Z

USVF

^FMTF\

GBMTF

^

^

Another difference that you have certainly already spotted is that we don't check multiple possible positions, just the one received. The reason is simple; contrary to a rotation, we can't move the UFUSJNJOP around when it receives a move instruction. Imagine asking the UFUSJNJOP to move to the right and it doesn't move, or worse, it moves to the left! We can't allow it and so we're not doing it.

Now about the method's code: it's very simple. If we can put the UFUSJNJOP in a place, we update the position of the UFUSJNJOP and return true, otherwise, we do nothing other than return false.

Most of the work is performed in the UFTU@QPTJUJPO method, allowing our method to be really small.

With these three methods, we have almost everything we need. But for even more simplicity in the future, let's add one more:

GOUFTU@DVSSFOU@QPTJUJPOTFMGHBNF@NBQ<7FDV > CPPM\ TFMGUFTU@QPTJUJPOHBNF@NBQTFMGDVSSFOU@TUBUFBTVTJ[F

TFMGYTFMGZ

^

[ 94 ]





Events and Basic Game Mechanisms Chapter 3

We'll use it when we generate a new UFUSJNJOP: if it cannot be placed where it appeared because another UFUSJNJOP is already there, it means the game is over.

We can now say that our 5FUSJNJOP type is fully implemented. Congratulations! Time to start the game type!

Tetris struct

This type will be the one holding all the game's information: Game map

Current level

Score

Number of lines

The current UFUSJNJOP

Some potential other information (such as a ghost, or the preview of the next UFUSJNJOP!)

Let's write down this type:

TUSVDU5FUSJT\

HBNF@NBQ7FD7FDV

DVSSFOU@MFWFMV

TDPSFV

OC@MJOFTV

DVSSFOU@QJFDF0QUJPO5FUSJNJOP

^

Once again, pretty simple. I don't think any additional information is required so let's continue!

Let's start by writing the OFX method for this new type: JNQM5FUSJT\

GOOFX 5FUSJT\

MFUNVUHBNF@NBQ7FDOFX

GPS@JO\

HBNF@NBQQVTIWFD<>

^

5FUSJT\

HBNF@NBQHBNF@NBQ

DVSSFOU@MFWFM

TDPSF

[ 95 ]

Events and Basic Game Mechanisms Chapter 3

OC@MJOFT

DVSSFOU@QJFDF/POF

^

^

^

Nothing really complicated except maybe the loop. Let's look at how it works: MFUNVUHBNF@NBQ7FDOFX

GPS@JO\

HBNF@NBQQVTIWFD<>

^

We know that a UFUSJT map has a width of 10 blocks and a height of 16 blocks. This loop creates our game map by looping over the number of lines and generating an empty vector of 10 blocks, which will be a line.

Apart from this, everything else is very straightforward: You start at level 1

With your score at 0

With 0 lines sent

No current UFUSJNJOP

Let's start by generating a new UFUSJNJOP randomly. For this, you'll require the SBOE crate.

Add the following to your $BSHPUPNM file:

SBOE

Then add this at the top of your NBJO file:

FYUFSODSBUFSBOE

Then we can write the method:

GODSFBUF@OFX@UFUSJNJOPTFMG 5FUSJNJOP\

TUBUJDNVU13&7V

MFUNVUSBOE@OCSBOESBOEPNV

JGVOTBGF\13&7^SBOE@OC\

SBOE@OCSBOESBOEPNV

^

VOTBGF\13&7SBOE@OC^

NBUDISBOE@OC\

5FUSJNJOP*OFX

5FUSJNJOP+OFX

5FUSJNJOP-OFX

[ 96 ]



Events and Basic Game Mechanisms

Chapter 3

5FUSJNJOP0OFX

5FUSJNJOP4OFX

5FUSJNJOP;OFX

5FUSJNJOP5OFX

@ VOSFBDIBCMF

^

^

Explanations:

TUBUJDNVU13&7V

The TUBUJD keyword is the same in 3VTU as it is in $ and $ for variables: the value set to the variable will be kept between the function calls. So for example, if you write the following function:

GOJODS V\

TUBUJDNVU/#V

VOTBGF\

/#

/#

^

^

And you then call it, as follows:

GPS@JO\

QSJOUMO\^JODS

^

You'll get the following output:

1

2

3

4

5

So now, why do we have these VOTBGF blocks? The reason is quite simple: in case the static variable is accessed and modified from different threads, you can't be sure that you won't have data race, concurrency errors, or even memory errors.

In this case, since we don't have threads, it's fine. However, keep in mind that you should ALWAYS try to avoid unsafe at all costs and use it ONLY

when nothing else can be done.

[ 97 ]

Events and Basic Game Mechanisms Chapter 3

However, if our static variable wasn't mutable, then we could access its value without needing the VOTBGF blocks. The reason once again is simple: even if multiple threads try to access its value at the same time, since this value cannot change, you can't have data race and therefore it is safe.

Let's continue with our function's code explanations: MFUNVUSBOE@OCSBOESBOEPNV

This line generates a random V and then limits its value between 0 (included) and 6

(included) because we have seven different UFUSJNJOP: JGVOTBGF\13&7^SBOE@OC\

SBOE@OCSBOESBOEPNV

^

If the generated UFUSJNJOP is the same as the previous one, we generate another one. It enables you to prevent having the same UFUSJNJOP too many times at once. It isn't the best way to do it, having a specific balancing for each UFUSJNJOP would be better, but this solution is acceptable enough (and a lot easier to write!): VOTBGF\13&7SBOE@OC^

We now set the generated UFUSJNJOP ID to our TUBUJD variable: NBUDISBOE@OC\

5FUSJNJOP*OFX

5FUSJNJOP+OFX

5FUSJNJOP-OFX

5FUSJNJOP0OFX

5FUSJNJOP4OFX

5FUSJNJOP;OFX

5FUSJNJOP5OFX

@ VOSFBDIBCMF

^

Nothing much to say about this pattern matching. Every ID matches a UFUSJNJOP and then we call the corresponding constructor. The only really interesting thing about this construction is the following line:

@ VOSFBDIBCMF

This macro is really useful. It allows us to add a security over the matched value. If the code ever enters this pattern matching, it'll panic right away (because, as the macro's name suggests, it's not supposed to happen).

[ 98 ]





Events and Basic Game Mechanisms Chapter 3

Interacting with the game map

Ok, we can now move all the UFUSJNJOP and generate them. Two mechanisms are still missing: checking lines to see whether one can be sent (that is, removed since complete) and making a UFUSJNJOP permanent (that is, not movable anymore).

Let's start with the line check:

GODIFDL@MJOFTNVUTFMG\

MFUNVUZ

XIJMFZTFMGHBNF@NBQMFO\

MFUNVUDPNQMFUFUSVF

GPSYJOTFMGHBNF@NBQ<Z>\

JGY\

DPNQMFUFGBMTF

CSFBL

^

^

JGDPNQMFUFUSVF\

TFMGHBNF@NBQSFNPWFZ

Z

JODSFBTFUIFOVNCFSPGTFMGMJOFT

^

Z

^

XIJMFTFMGHBNF@NBQMFO\

TFMGHBNF@NBQJOTFSUWFD<

>

^

^

For now, I didn't add the score, lines sent counting, nor level handling but this is here that'll do it later.

Now time to explain this method a bit. Its purpose is to remove lines when they're full (meaning when every block is occupied by a UFUSJNJOP block). So we just go through the game map line by line and run the check on each.

The code itself doesn't use much of the Rust-specific syntax, but you might wonder why we did it like this. I'm talking about this loop:

XIJMFZTFMGHBNF@NBQMFO\

[ 99 ]

Events and Basic Game Mechanisms Chapter 3

When we could have just used:

GPSMJOFJOTFMGHBNF@NBQ\

This is actually a good question and the answer is simple, but maybe hard to understand, if you're used to how Rust ownership works.

All the problems actually come from this line:

TFMGHBNF@NBQSFNPWFZ

In here, we mutably borrow TFMGHBNF@NBQ in order to remove a line. However, TFMGHBNF@NBQ would already be non-mutably borrowed by the GPS loop! A quick reminder on how the borrowing rules work:

You can non-mutably borrow a variable as many times as you want You can mutably borrow a variable only if there are no other borrows (either mutable or non-mutable)

So in our case, the GPS loop would break the second rule since we'd have a non-mutable borrow when trying to get mutable access to TFMGHBNF@NBQ.

In this case, we have two solutions:

Iterate over the game map "by hand" (with an index variable) Store lines to remove into a second vector and then remove them after we get out of the loop

Both solutions are more or less equivalent in this case so I just picked the first one.

Once the first loop is finished, we have filled the game map with empty lines to replace the one(s) we deleted:

XIJMFTFMGHBNF@NBQMFO\

TFMGHBNF@NBQJOTFSUWFD<>

^

And we're done with this method! Let's write the other one.

So now it's time to write the NBLF@QFSNBOFOU method. Just like the previous one, it won't be a complete version, but in the future, this is where we'll update the score (we update it when a UFUSJNJOP is made permanent).

[ 100 ]

Events and Basic Game Mechanisms Chapter 3

So let's write it:

GONBLF@QFSNBOFOUNVUTFMG\

JGMFU4PNFSFGNVUQJFDFTFMGDVSSFOU@QJFDF\

MFUNVUTIJGU@Z

XIJMFTIJGU@ZQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F>MFO

QJFDFZTIJGU@ZTFMGHBNF@NBQMFO\

MFUNVUTIJGU@Y

XIJMFTIJGU@YQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F><TIJGU@Z>MFO

QJFDFYTIJGU@YBTJTJ[F

TFMGHBNF@NBQ<QJFDFZ

TIJGU@Z>MFOBTJTJ[F\

JGQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBTVTJ[F>

<TIJGU@Z><TIJGU@Y>\

MFUYQJFDFYTIJGU@YBTJTJ[F

TFMGHBNF@NBQ<QJFDFZTIJGU@Z><YBTVTJ[F>

QJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBTVTJ[F>

<TIJGU@Z><TIJGU@Y>

^

TIJGU@Y

^

TIJGU@Z

^

^

TFMGDIFDL@MJOFT

TFMGDVSSFOU@QJFDF/POF

^

This code doesn't seem very encouraging... Brace yourselves, explanations are coming: JGMFU4PNFSFGNVUQJFDFTFMGDVSSFOU@QJFDF\

It's simple pattern matching. If TFMGDVSSFOU@QJFDF is 4PNF, then we enter the condition and the value contained by 4PNF that is bound into the QJFDF variable: XIJMFTIJGU@ZQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBTVTJ[F>MFO

QJFDFZTIJGU@ZTFMGHBNF@NBQMFO\

This loop and its condition allow us to avoid a buffer overflow error by checking whether we're not outside of the game map limit for the current rotation (that is, TFMGDVSSFOU@TUBUF).

[ 101 ]





Events and Basic Game Mechanisms Chapter 3

The same goes for the inner loop (which iterates over the blocks of a line): XIJMFTIJGU@YQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F><TIJGU@Z>MFO

QJFDFYTIJGU@YBTJTJ[FTFMGHBNF@NBQ<QJFDFZ

TIJGU@Z>MFOBTJTJ[F\

It is in this loop that we write the blocks of the current UFUSJNJOP into the game map: JGQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBTVTJ[F><TIJGU@Z><TIJGU@Y>

\

MFUYQJFDFYTIJGU@YBTJTJ[F

TFMGHBNF@NBQ<QJFDFZTIJGU@Z><YBTVTJ[F>

QJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F><TIJGU@Z><TIJGU@Y>

^

If the current block of the current UFUSJNJOP isn't empty, then we put it into the game map (it's as simple as that).

Once done, this is where we call the DIFDL@MJOFT method. But now you'll certainly wonder why we don't call it directly inside the JGMFU condition. Well, it's for the exact same reason that we didn't use the GPS loop inside the DIFDL@MJOFT method, TFMG is already mutably borrowed by the following line:

JGMFU4PNFSFGNVUQJFDFTFMGDVSSFOU@QJFDF\

That's right: if an element of a type is borrowed, then its parent is mutably borrowed as well!

With these two methods, our 5FUSJT type is now fully implemented (minus the small required modifications that will come later). Time to add the 4%- events handling!

SDL events

There aren't many different events to handle:

Left and right arrow keys to move the UFUSJNJOP to the right or the left Up arrow key to make the UFUSJNJOP rotate

Down arrow key to make the UFUSJNJOP descend one block Spacebar to make the UFUSJNJOP descend to the bottom instantly Escape to quit the game

[ 102 ]

Events and Basic Game Mechanisms Chapter 3

It's still possible to add some later on (such as pausing the game with the return key, for example) but for now, let's focus on these ones. For this, go back inside the main loop of the game (inside the NBJO function) and replace the current event handling with the following function:

GOIBOEMF@FWFOUTUFUSJTNVU5FUSJTRVJUNVUCPPMUJNFSNVU

4ZTUFN5JNF

FWFOU@QVNQNVUTEM&WFOU1VNQ CPPM\

MFUNVUNBLF@QFSNBOFOUGBMTF

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

MFUNVUUNQ@YQJFDFY

MFUNVUUNQ@ZQJFDFZ

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

NBUDIFWFOU\

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^

\

RVJUUSVF

CSFBL

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF%PXO^

\

UJNFS4ZTUFN5JNFOPX

UNQ@Z

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF3JHIU^

\

UNQ@Y

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF-FGU^

\

UNQ@Y

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF6Q^

\

QJFDFSPUBUFUFUSJTHBNF@NBQ

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF4QBDF^

\

MFUYQJFDFY

MFUNVUZQJFDFZ

XIJMFQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQYZ

USVF\

Z

^

NBLF@QFSNBOFOUUSVF

[ 103 ]

Events and Basic Game Mechanisms Chapter 3

^

@ \^

^

^

JGNBLF@QFSNBOFOU\

JGQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQUNQ@YUNQ@Z



GBMTF

UNQ@ZQJFDFZ\

NBLF@QFSNBOFOUUSVF

^

^

^

JGNBLF@QFSNBOFOU\

UFUSJTNBLF@QFSNBOFOU

UJNFS4ZTUFN5JNFOPX

^

NBLF@QFSNBOFOU

^

Quite a big one:

MFUNVUNBLF@QFSNBOFOUGBMTF

This variable will tell us whether the current UFUSJNJOP is still falling. If not, then it becomes USVF, the UFUSJNJOP is then put into the game map and we generate a new one.

Luckily for us, we already wrote all the needed functions to perform these operations: JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

This is simple pattern binding. If our game doesn't have a current piece (for some reason), then we don't do anything and just leave:

MFUNVUUNQ@YQJFDFY

MFUNVUUNQ@ZQJFDFZ

If there is a move on the Y or on the Z axis, we'll write it into these variables and then we'll test whether the UFUSJNJOP can actually go there:

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

As there can be multiple events that happened since the last time we came into this function, we need to loop over all of them.

[ 104 ]

Events and Basic Game Mechanisms Chapter 3

Now we're arriving at the interesting part:

NBUDIFWFOU\

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^ \

RVJUUSVF

CSFBL

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF%PXO^ \

UJNFS4ZTUFN5JNFOPX

UNQ@Z

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF3JHIU^ \

UNQ@Y

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF-FGU^ \

UNQ@Y

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF6Q^ \

QJFDFSPUBUFUFUSJTHBNF@NBQ

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF4QBDF^ \

MFUYQJFDFY

MFUNVUZQJFDFZ

XIJMFQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQYZ

USVF\

Z

^

NBLF@QFSNBOFOUUSVF

^

@ \^

^

We can almost consider this small code as the core of our application, without it, no interaction with the program is possible. If you want more interactions, this is where you'll add them:

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF^ \

RVJUUSVF

CSFBL

^

[ 105 ]

Events and Basic Game Mechanisms Chapter 3

If we receive a quit event from TEM or if we receive an &TDBQF, ,FZ%PXO event, we set the RVJU variable to USVF. It'll be used outside of this function to then leave the main loop--and therefore leave the program itself. Then we break; no need to go further since we know that we're leaving the game:

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF%PXO^ \

UJNFS4ZTUFN5JNFOPX

UNQ@Z

^

If the down arrow is pressed, we need to make our UFUSJNJOP descend by one block and also put the UJNFS value to now. UJNFS is used to know at what speed the UFUSJNJOP blocks are falling. The shorter the time, the faster they'll descend.

For now, it isn't used in this function, so we'll see how to handle it outside of it:

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF3JHIU^ \

UNQ@Y

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF-FGU^ \

UNQ@Y

^

In here, we handle the right and left arrow keys. It's just like the down arrow key, except we don't need to change the UJNFS variable:

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF6Q^ \

QJFDFSPUBUFUFUSJTHBNF@NBQ

^

If we receive an up arrow key pressed event, we rotate the UFUSJNJOP:

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF4QBDF^ \

MFUYQJFDFY

MFUNVUZQJFDFZ

XIJMFQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQYZUSVF\

Z

^

NBLF@QFSNBOFOUUSVF

^

And finally the last of our events: the spacebar key pressed event. Here, we move the UFUSJNJOP down as much as we can and then set the NBLF@QFSNBOFOU variable to USVF.

[ 106 ]

Events and Basic Game Mechanisms Chapter 3

With this, that's it for our events. However, like we said before if you want to add more events, this is where you should put them.

Time to put all this into our main loop:

GOQSJOU@HBNF@JOGPSNBUJPOUFUSJT5FUSJT\

QSJOUMO(BNFPWFS

QSJOUMO4DPSF\^UFUSJTTDPSF

QSJOUMO/VNCFSPGMJOFT\^UFUSJTOC@MJOFT

QSJOUMO$VSSFOUMFWFM\^UFUSJTDVSSFOU@MFWFM

$IFDLIJHITDPSFTIFSFBOEVQEBUFJGOFFEFE

^

MFUNVUUFUSJT5FUSJTOFX

MFUNVUUJNFS4ZTUFN5JNFOPX

MPPQ\

JGNBUDIUJNFSFMBQTFE\

0LFMBQTFE FMBQTFEBT@TFDT

&SS@ GBMTF

^\

MFUNVUNBLF@QFSNBOFOUGBMTF

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

MFUYQJFDFY

MFUZQJFDFZ

NBLF@QFSNBOFOU

QJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQ

YZ

^

JGNBLF@QFSNBOFOU\

UFUSJTNBLF@QFSNBOFOU

^

UJNFS4ZTUFN5JNFOPX

^

8FOFFEUPESBXUIFUFUSJTHSJEJOIFSF

JGUFUSJTDVSSFOU@QJFDFJT@OPOF\

MFUDVSSFOU@QJFDFUFUSJTDSFBUF@OFX@UFUSJNJOP

JGDVSSFOU@QJFDFUFTU@DVSSFOU@QPTJUJPOUFUSJTHBNF@NBQ\ QSJOU@HBNF@JOGPSNBUJPOUFUSJT

CSFBL

^

UFUSJTDVSSFOU@QJFDF4PNFDVSSFOU@QJFDF

^

MFUNVURVJUGBMTF

JGIBOEMF@FWFOUTNVUUFUSJTNVURVJUNVUUJNFSNVU

[ 107 ]

Events and Basic Game Mechanisms Chapter 3

FWFOU@QVNQ\

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

8FOFFEUPESBXPVSDVSSFOUUFUSJNJOPJOIFSF

^

^

JGRVJU\

QSJOU@HBNF@JOGPSNBUJPOUFUSJT

CSFBL

^

8FOFFEUPESBXUIFHBNFNBQJOIFSF

TMFFQ%VSBUJPOOFX@@@V

^

Doesn't seem that long, right? Just a few comments where we're supposed to draw our 5FUSJT, but otherwise everything is in there, which means that our 5FUSJT is now fully functional (even though it isn't displayed).

Let's explain what's happening in there:

MFUNVUUFUSJT5FUSJTOFX

MFUNVUUJNFS4ZTUFN5JNFOPX

In here, we initialize both our 5FUSJT object and the UJNFS. The timer will be used to let us know when the UFUSJNJOP is supposed to descend by one block: JGNBUDIUJNFSFMBQTFE\

0LFMBQTFE FMBQTFEBT@TFDT

&SS@ GBMTF

^\

MFUNVUNBLF@QFSNBOFOUGBMTF

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

MFUYQJFDFY

MFUZQJFDFZ

NBLF@QFSNBOFOUQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQ

YZ

^

JGNBLF@QFSNBOFOU\

UFUSJTNBLF@QFSNBOFOU

^

UJNFS4ZTUFN5JNFOPX

^

[ 108 ]

Events and Basic Game Mechanisms Chapter 3

This code checks whether it's been one second or more since the last time the UFUSJNJOP descended by one block. If we want to handle levels, we'll need to replace the following line:

0LFMBQTFE FMBQTFEBT@TFDT

Its replacement will need to be something more generic and we'll add an array to store the different levels' speed of descent.

So coming back to the code, if it's been one second or more then we try to make the UFUSJNJOP descend by one block. If it cannot, then we put it into the game map and re-initialize the UJNFS variable.

Once again, you might wonder why we had to create the NBLF@QFSNBOFOU variable instead of directly checking the output of:

QJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQYZ

It has an JG condition, right? Well, just like the previous times, it's because of the borrow checker. We borrow UFUSJT here:

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

So as long as we're in this condition, we can't use UFUSJT mutably, which is why we store the result of the condition in NBLF@QFSNBOFOU so we can use the NBLF@QFSNBOFOU method after:

JGUFUSJTDVSSFOU@QJFDFJT@OPOF\

MFUDVSSFOU@QJFDFUFUSJTDSFBUF@OFX@UFUSJNJOP

JGDVSSFOU@QJFDFUFTU@DVSSFOU@QPTJUJPOUFUSJTHBNF@NBQ\ QSJOU@HBNF@JOGPSNBUJPOUFUSJT

SFUVSO

^

UFUSJTDVSSFOU@QJFDF4PNFDVSSFOU@QJFDF

^

If there is no current UFUSJNJOP, we need to generate a new one, which we do by calling the DSFBUF@OFX@UFUSJNJOP method. Then we check whether it can be put into the game on the top line by calling the UFTU@DVSSFOU@QPTJUJPO method. If not, then it means the game is over and we quit. Otherwise, we store the newly-generated UFUSJNJOP

in UFUSJTDVSSFOU@QJFDF and we move on.

[ 109 ]





Events and Basic Game Mechanisms Chapter 3

Two things are missing here:

Since we don't handle the increase of lines sent, nor the score, nor the level, there's no need to print them

We didn't add yet the highscores loading/overwrite Of course, we'll add all this later on:

MFUNVURVJUGBMTF

JGIBOEMF@FWFOUTNVUUFUSJTNVURVJUNVUUJNFSNVU

FWFOU@QVNQ\

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

8FOFFEUPESBXPVSDVSSFOUUFUSJNJOPJOIFSF

^

^

JGRVJU\

QSJOU@HBNF@JOGPSNBUJPOUFUSJT

CSFBL

^

This code calls the IBOEMF@FWFOUT function and acts according to its output. It returns whether the current UFUSJNJOP has been put into the game map or not. If it is the case, then there is no need to draw it.

We now need to do the following remaining things:

Add the score, levels, and number of lines sent

Load/overwrite the highscores if needed

Actually draw the 5FUSJT

Seems like we're getting very close to the end! Let's start by adding the score, number of lines sent, and levels!

Score, level, lines sent

The biggest required change will be the level handling. You need to create an array with different times to increase the UFUSJNJOP's speed of descent and to check whether the level needs to be changed or not (based on the number of lines).

[ 110 ]

Events and Basic Game Mechanisms Chapter 3

The score will be updated in the following cases:

When the UFUSJNJOP is made permanent

When a line is sent

When the player makes a 5FUSJT (no more blocks in the game map) Let's start with the easiest changebthe score.

First, let's add the following method into our 5FUSJT type: GOVQEBUF@TDPSFNVUTFMGUP@BEEV\

TFMGTDPSFUP@BEE

^

We can suppose that no additional explanations are required here.

Next, let's update a few methods:

GODIFDL@MJOFTNVUTFMG\

MFUNVUZ

MFUNVUTDPSF@BEE

XIJMFZTFMGHBNF@NBQMFO\

MFUNVUDPNQMFUFUSVF

GPSYJOTFMGHBNF@NBQ<Z>\

JGY\

DPNQMFUFGBMTF

CSFBL

^

^

JGDPNQMFUFUSVF\

TDPSF@BEETFMGDVSSFOU@MFWFM

TFMGHBNF@NBQSFNPWFZ

Z

^

Z

^

JGTFMGHBNF@NBQMFO\

"UFUSJT

TDPSF@BEE

^

TFMGVQEBUF@TDPSFTDPSF@BEE

XIJMFTFMGHBNF@NBQMFO\

XF MMBEEUIJTNFUIPEKVTUBGUFS

TFMGJODSFBTF@MJOF

[ 111 ]

Events and Basic Game Mechanisms Chapter 3

TFMGHBNF@NBQJOTFSUWFD<

>

^

^

As usual, we create a temporary variable (here, TDPSF@BEE) and once the borrow of TFMG is over, we call the VQEBUF@TDPSF method. There is also the usage of the JODSFBTF@MJOF

method. We haven't defined it yet; it'll come just after.

The second method is NBLF@QFSNBOFOU:

GONBLF@QFSNBOFOUNVUTFMG\

MFUNVUUP@BEE

JGMFU4PNFSFGNVUQJFDFTFMGDVSSFOU@QJFDF\

MFUNVUTIJGU@Z

XIJMFTIJGU@ZQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F>MFO

QJFDFZTIJGU@ZTFMGHBNF@NBQMFO\

MFUNVUTIJGU@Y

XIJMFTIJGU@YQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBTVTJ[F>

<TIJGU@Z>MFO

QJFDFYTIJGU@YBTJTJ[FTFMGHBNF@NBQ<QJFDFZ

TIJGU@Z>MFOBTJTJ[F\

JGQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBTVTJ[F><TIJGU@Z>

<TIJGU@Y>\

MFUYQJFDFYTIJGU@YBTJTJ[F

TFMGHBNF@NBQ<QJFDFZTIJGU@Z><YBTVTJ[F>

QJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBTVTJ[F>

<TIJGU@Z><TIJGU@Y>

^

TIJGU@Y

^

TIJGU@Z

^

UP@BEETFMGDVSSFOU@MFWFM

^

TFMGVQEBUF@TDPSFUP@BEE

TFMGDIFDL@MJOFT

TFMGDVSSFOU@QJFDF/POF

^

Include this just above the TFMGDIFDL@MJOFT call.

With these two methods updated, we now have the score handling fully implemented.

[ 112 ]





Events and Basic Game Mechanisms Chapter 3

Levels and lines sent

The next two being strongly bound (the level depends directly on the number of lines sent), we'll implement them at the same time.

Before doing anything else, let's define the two following DPOTU: DPOTU-&7&-@5*.&4<V><

>

DPOTU-&7&-@-*/&4<V><

>

The first one corresponds to the times before the current UFUSJNJOP descends by one block.

Each case being a different level.

The second one corresponds to how many lines the player needs before getting to the next level.

Next, let's add the following method in our 5FUSJT type: GOJODSFBTF@MJOFNVUTFMG\

TFMGOC@MJOFT

JGTFMGOC@MJOFT -&7&-@-*/&4<TFMGDVSSFOU@MFWFMBTVTJ[F>

\

TFMGDVSSFOU@MFWFM

^

^

Nothing complicated. Just be careful when reading the -&7&-@-*/&4 const because our DVSSFOU@MFWFM variable starts at and not 0.

Next, we'll need to update how we determine whether the time is up or not. To do so, let's write another function:

GOJT@UJNF@PWFS\

NBUDIUJNFSFMBQTFE\

0LFMBQTFE \

MFUNJMMJTFMBQTFEBT@TFDTBTV

FMBQTFETVCTFD@OBOPT@@

NJMMJT -&7&-@5*.&4<UFUSJTDVSSFOU@MFWFMBTVTJ[F>

^

&SS@ GBMTF

^

^

[ 113 ]





Events and Basic Game Mechanisms Chapter 3

A small but tricky one. The problem is that the type returned by UJNFSFMBQTFE (which is

%VSBUJPO) doesn't provide a method to get the number of milliseconds, so we need to get it ourselves.

First, we get the number of seconds elapsed and then multiply it by 1,000 (because 1 second

= 1,000 milliseconds). Finally, we get the number of nanoseconds (in the current second) and divide it by 1,000,000 (because 1 millisecond = 1 million nanoseconds).

We can now compare the results to see whether the UFUSJNJOP should descend or not and return the result:

JGJT@UJNF@PWFSUFUSJTUJNFS\

MFUNVUNBLF@QFSNBOFOUGBMTF

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

MFUYQJFDFY

MFUZQJFDFZ

NBLF@QFSNBOFOUQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQ

YZ

^

JGNBLF@QFSNBOFOU\

UFUSJTNBLF@QFSNBOFOU

^

UJNFS4ZTUFN5JNFOPX

^

And with this, we've finished this part. Let's make the last one now: the highscore loading/overwriting!

Highscores loading/overwriting

We already saw how to perform the I/O operations in the previous chapter, so it'll be very quick to do:

DPOTU/#@)*()4$03&4VTJ[F

GOVQEBUF@WFDWNVU7FDV WBMVFV CPPM\

JGWMFO/#@)*()4$03&4\

WQVTIWBMVF

WTPSU

USVF

^FMTF\

GPSFOUSZJOWJUFS@NVU\

JGWBMVF FOUSZ\

FOUSZWBMVF

SFUVSOUSVF

[ 114 ]

Events and Basic Game Mechanisms Chapter 3

^

^

GBMTF

^

^

GOQSJOU@HBNF@JOGPSNBUJPOUFUSJT5FUSJT\

MFUNVUOFX@IJHIFTU@IJHITDPSFUSVF

MFUNVUOFX@IJHIFTU@MJOFT@TFOUUSVF

JGMFU4PNFNVUIJHITDPSFTNVUMJOFT@TFOU

MPBE@IJHITDPSFT@BOE@MJOFT\

OFX@IJHIFTU@IJHITDPSFVQEBUF@WFDNVUIJHITDPSFT

UFUSJTTDPSF

OFX@IJHIFTU@MJOFT@TFOUVQEBUF@WFDNVUMJOFT@TFOU

UFUSJTOC@MJOFT

JGOFX@IJHIFTU@IJHITDPSF]]OFX@IJHIFTU@MJOFT@TFOU\

TBWF@IJHITDPSFT@BOE@MJOFTIJHITDPSFTMJOFT@TFOU

^

^FMTF\

TBWF@IJHITDPSFT@BOE@MJOFT<UFUSJTTDPSF>

<UFUSJTOC@MJOFT>

^

QSJOUMO(BNFPWFS

QSJOUMO4DPSF\^\^

UFUSJTTDPSF

JGOFX@IJHIFTU@IJHITDPSF\</&8)*()4$03&>^FMTF\

^

QSJOUMO/VNCFSPGMJOFT\^\^

UFUSJTOC@MJOFT

JGOFX@IJHIFTU@MJOFT@TFOU\</&8)*()4$03&>^FMTF\

^

QSJOUMO$VSSFOUMFWFM\^UFUSJTDVSSFOU@MFWFM

^

Not much to explain with this code. For the moment, we limited the number of each highscore to . Just update it as you want.

And with this code, all the mechanisms are implemented. All that's left is to actually draw the game!

[ 115 ]

Events and Basic Game Mechanisms Chapter 3

Here is the full code for this chapter:

FYUFSODSBUFSBOE

FYUFSODSBUFTEM

VTFTEMFWFOU&WFOU

VTFTEMLFZCPBSE,FZDPEF

VTFTEMQJYFMT$PMPS

VTFTEMSFDU3FDU

VTFTEMSFOEFS\$BOWBT5FYUVSF5FYUVSF$SFBUPS^

VTFTEMWJEFP\8JOEPX8JOEPX$POUFYU^

VTFTUEGT'JMF

VTFTUEJP\TFMG3FBE8SJUF^

VTFTUEUISFBETMFFQ

VTFTUEUJNF\%VSBUJPO4ZTUFN5JNF^

DPOTU5&53*4@)&*()5VTJ[F

DPOTU)*()4$03&@'*-& TUBUJDTUSTDPSFTUYU

DPOTU-&7&-@5*.&4<V><

>

DPOTU-&7&-@-*/&4<V><

>

DPOTU/#@)*()4$03&4VTJ[F

UZQF1JFDF7FD7FDV

UZQF4UBUFT7FD1JFDF

USBJU5FUSJNJOP(FOFSBUPS\

GOOFX 5FUSJNJOP

^

TUSVDU5FUSJNJOP*

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP*\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

[ 116 ]

Events and Basic Game Mechanisms Chapter 3

^

^

^

TUSVDU5FUSJNJOP+

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP+\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

TUSVDU5FUSJNJOP-

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP-\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

[ 117 ]

Events and Basic Game Mechanisms Chapter 3

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

TUSVDU5FUSJNJOP0

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP0\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

TUSVDU5FUSJNJOP4

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP4\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

[ 118 ]

Events and Basic Game Mechanisms Chapter 3

TUSVDU5FUSJNJOP;

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP;\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

TUSVDU5FUSJNJOP5

JNQM5FUSJNJOP(FOFSBUPSGPS5FUSJNJOP5\

GOOFX 5FUSJNJOP\

5FUSJNJOP\

TUBUFTWFD<WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>

WFD<WFD<>

WFD<>

WFD<>

WFD<>>>

Y

Z

DVSSFOU@TUBUF

^

^

^

[ 119 ]

Events and Basic Game Mechanisms Chapter 3

TUSVDU5FUSJNJOP\

TUBUFT4UBUFT

YJTJ[F

ZVTJ[F

DVSSFOU@TUBUFV

^

JNQM5FUSJNJOP\

GOSPUBUFNVUTFMGHBNF@NBQ<7FDV >\

MFUNVUUNQ@TUBUFTFMGDVSSFOU@TUBUF

JGUNQ@TUBUFBTVTJ[F TFMGTUBUFTMFO\

UNQ@TUBUF

^

MFUY@QPT<>

GPSYJOY@QPTJUFS\

JGTFMGUFTU@QPTJUJPOHBNF@NBQUNQ@TUBUFBTVTJ[F

TFMGYYTFMGZUSVF\

TFMGDVSSFOU@TUBUFUNQ@TUBUF

TFMGYY

CSFBL

^

^

^

GOUFTU@QPTJUJPOTFMGHBNF@NBQ<7FDV >

UNQ@TUBUFVTJ[FYJTJ[FZVTJ[F CPPM

\

GPSTIJGU@ZJO\

GPSTIJGU@YJO\

MFUYYTIJGU@Y

JGTFMGTUBUFT<UNQ@TUBUF><TIJGU@Z><TIJGU@YBT

VTJ[F>

ZTIJGU@Z HBNF@NBQMFO]]

Y]]

YBTVTJ[F HBNF@NBQ<ZTIJGU@Z>MFO]]

HBNF@NBQ<ZTIJGU@Z><YBTVTJ[F>\

SFUVSOGBMTF

^

^

^

SFUVSOUSVF

^

GOUFTU@DVSSFOU@QPTJUJPOTFMGHBNF@NBQ<7FDV > CPPM\ TFMGUFTU@QPTJUJPOHBNF@NBQTFMGDVSSFOU@TUBUFBTVTJ[F

TFMGYTFMGZ

^

[ 120 ]

Events and Basic Game Mechanisms Chapter 3

GODIBOHF@QPTJUJPONVUTFMGHBNF@NBQ<7FDV >OFX@Y

JTJ[FOFX@ZVTJ[F CPPM\

JGTFMGUFTU@QPTJUJPOHBNF@NBQTFMGDVSSFOU@TUBUFBT

VTJ[FOFX@YOFX@ZUSVF\

TFMGYOFX@YBTJTJ[F

TFMGZOFX@Z

USVF

^FMTF\

GBMTF

^

^

^

TUSVDU5FUSJT\

HBNF@NBQ7FD7FDV

DVSSFOU@MFWFMV

TDPSFV

OC@MJOFTV

DVSSFOU@QJFDF0QUJPO5FUSJNJOP

^

JNQM5FUSJT\

GOOFX 5FUSJT\

MFUNVUHBNF@NBQ7FDOFX

GPS@JO\

HBNF@NBQQVTIWFD<>

^

5FUSJT\

HBNF@NBQHBNF@NBQ

DVSSFOU@MFWFM

TDPSF

OC@MJOFT

DVSSFOU@QJFDF/POF

^

^

GOVQEBUF@TDPSFNVUTFMGUP@BEEV\

TFMGTDPSFUP@BEE

^

GOJODSFBTF@MFWFMNVUTFMG\

TFMGDVSSFOU@MFWFM

^

GOJODSFBTF@MJOFNVUTFMG\

TFMGOC@MJOFT

JGTFMGOC@MJOFT -&7&-@-*/&4<TFMGDVSSFOU@MFWFMBTVTJ[F

>\

[ 121 ]

Events and Basic Game Mechanisms Chapter 3

TFMGJODSFBTF@MFWFM

^

^

GODIFDL@MJOFTNVUTFMG\

MFUNVUZ

MFUNVUTDPSF@BEE

XIJMFZTFMGHBNF@NBQMFO\

MFUNVUDPNQMFUFUSVF

GPSYJOTFMGHBNF@NBQ<Z>\

JGY\

DPNQMFUFGBMTF

CSFBL

^

^

JGDPNQMFUFUSVF\

TDPSF@BEETFMGDVSSFOU@MFWFM

TFMGHBNF@NBQSFNPWFZ

Z

^

Z

^

JGTFMGHBNF@NBQMFO\

"UFUSJT

TDPSF@BEE

^

TFMGVQEBUF@TDPSFTDPSF@BEE

XIJMFTFMGHBNF@NBQMFO\

TFMGJODSFBTF@MJOF

TFMGHBNF@NBQJOTFSUWFD<

>

^

^

GODSFBUF@OFX@UFUSJNJOPTFMG 5FUSJNJOP\

TUBUJDNVU13&7V

MFUNVUSBOE@OCSBOESBOEPNV

JGVOTBGF\13&7^SBOE@OC\

SBOE@OCSBOESBOEPNV

^

VOTBGF\13&7SBOE@OC^

NBUDISBOE@OC\

5FUSJNJOP*OFX

5FUSJNJOP+OFX

5FUSJNJOP-OFX

5FUSJNJOP0OFX

[ 122 ]

Events and Basic Game Mechanisms Chapter 3

5FUSJNJOP4OFX

5FUSJNJOP;OFX

5FUSJNJOP5OFX

@ VOSFBDIBCMF

^

^

GONBLF@QFSNBOFOUNVUTFMG\

MFUNVUUP@BEE

JGMFU4PNFSFGNVUQJFDFTFMGDVSSFOU@QJFDF\

MFUNVUTIJGU@Z

XIJMFTIJGU@ZQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F>MFO

QJFDFZTIJGU@ZTFMGHBNF@NBQMFO\

MFUNVUTIJGU@Y

XIJMFTIJGU@YQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F>

<TIJGU@Z>MFO

QJFDFYTIJGU@YBTJTJ[F

TFMGHBNF@NBQ<QJFDFZ

TIJGU@Z>MFOBTJTJ[F\

JGQJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F><TIJGU@Z><TIJGU@Y>

\

MFUYQJFDFYTIJGU@YBTJTJ[F

TFMGHBNF@NBQ<QJFDFZTIJGU@Z><YBT

VTJ[F>

QJFDFTUBUFT<QJFDFDVSSFOU@TUBUFBT

VTJ[F><TIJGU@Z>

<TIJGU@Y>

^

TIJGU@Y

^

TIJGU@Z

^

UP@BEETFMGDVSSFOU@MFWFM

^

TFMGVQEBUF@TDPSFUP@BEE

TFMGDIFDL@MJOFT

TFMGDVSSFOU@QJFDF/POF

^

^

GOIBOEMF@FWFOUTUFUSJTNVU5FUSJTRVJUNVUCPPMUJNFSNVU

4ZTUFN5JNF

FWFOU@QVNQNVUTEM&WFOU1VNQ CPPM\

[ 123 ]

Events and Basic Game Mechanisms Chapter 3

MFUNVUNBLF@QFSNBOFOUGBMTF

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

MFUNVUUNQ@YQJFDFY

MFUNVUUNQ@ZQJFDFZ

GPSFWFOUJOFWFOU@QVNQQPMM@JUFS\

NBUDIFWFOU\

&WFOU2VJU\^]

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF&TDBQF

^ \

RVJUUSVF

CSFBL

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF%PXO^

\

UJNFS4ZTUFN5JNFOPX

UNQ@Z

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF3JHIU

^ \

UNQ@Y

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF-FGU^

\

UNQ@Y

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF6Q^

\

QJFDFSPUBUFUFUSJTHBNF@NBQ

^

&WFOU,FZ%PXO\LFZDPEF4PNF,FZDPEF4QBDF

^ \

MFUYQJFDFY

MFUNVUZQJFDFZ

XIJMFQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQ

YZUSVF

\

Z

^

NBLF@QFSNBOFOUUSVF

^

@ \^

^

^

JGNBLF@QFSNBOFOU\

JGQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQUNQ@Y

UNQ@ZGBMTF

UNQ@ZQJFDFZ\

[ 124 ]

Events and Basic Game Mechanisms Chapter 3

NBLF@QFSNBOFOUUSVF

^

^

^

JGNBLF@QFSNBOFOU\

UFUSJTNBLF@QFSNBOFOU

UJNFS4ZTUFN5JNFOPX

^

NBLF@QFSNBOFOU

^

GOXSJUF@JOUP@GJMFDPOUFOUTUSGJMF@OBNFTUS

JP3FTVMU \

MFUNVUG'JMFDSFBUFGJMF@OBNF

GXSJUF@BMMDPOUFOUBT@CZUFT

^

GOSFBE@GSPN@GJMFGJMF@OBNFTUS JP3FTVMU4USJOH \

MFUNVUG'JMFPQFOGJMF@OBNF

MFUNVUDPOUFOU4USJOHOFX

GSFBE@UP@TUSJOHNVUDPOUFOU

0LDPOUFOU

^

GOTMJDF@UP@TUSJOHTMJDF<V> 4USJOH\

TMJDFJUFSNBQ]IJHITDPSF]

IJHITDPSFUP@TUSJOHDPMMFDU7FD4USJOH KPJO

^

GOTBWF@IJHITDPSFT@BOE@MJOFTIJHITDPSFT<V>OVNCFS@PG@MJOFT

<V> CPPM\

MFUT@IJHITDPSFTTMJDF@UP@TUSJOHIJHITDPSFT

MFUT@OVNCFS@PG@MJOFTTMJDF@UP@TUSJOHOVNCFS@PG@MJOFT

XSJUF@JOUP@GJMFGPSNBU\^=O\^=OT@IJHITDPSFT

T@OVNCFS@PG@MJOFT)*()4$03&@'*-&JT@PL

^

GOMJOF@UP@TMJDFMJOFTUS 7FDV \

MJOFTQMJUGJMUFS@NBQ]OC]

OCQBSTFV PLDPMMFDU

^

GOMPBE@IJHITDPSFT@BOE@MJOFT 0QUJPO7FDV 7FDV \

JGMFU0LDPOUFOUSFBE@GSPN@GJMF)*()4$03&@'*-&\ MFUNVUMJOFTDPOUFOUTQMJUO=ONBQ]MJOF]

MJOF@UP@TMJDFMJOFDPMMFDU7FD@

JGMJOFTMFO\

MFUMJOFT@TFOUIJHITDPSFTMJOFTQPQVOXSBQ

[ 125 ]

Events and Basic Game Mechanisms Chapter 3

MJOFTQPQVOXSBQ

4PNFIJHITDPSFTMJOFT@TFOU

^FMTF\

/POF

^

^FMTF\

/POF

^

^

GOVQEBUF@WFDWNVU7FDV WBMVFV CPPM\

JGWMFO/#@)*()4$03&4\

WQVTIWBMVF

USVF

^FMTF\

GPSFOUSZJOWJUFS@NVU\

JGWBMVF FOUSZ\

FOUSZWBMVF

SFUVSOUSVF

^

^

GBMTF

^

^

GOQSJOU@HBNF@JOGPSNBUJPOUFUSJT5FUSJT\

MFUNVUOFX@IJHIFTU@IJHITDPSFUSVF

MFUNVUOFX@IJHIFTU@MJOFT@TFOUUSVF

JGMFU4PNFNVUIJHITDPSFTNVUMJOFT@TFOU

MPBE@IJHITDPSFT@BOE@MJOFT\

OFX@IJHIFTU@IJHITDPSFVQEBUF@WFDNVUIJHITDPSFT

UFUSJTTDPSF

OFX@IJHIFTU@MJOFT@TFOUVQEBUF@WFDNVUMJOFT@TFOU

UFUSJTOC@MJOFT

JGOFX@IJHIFTU@IJHITDPSF]]OFX@IJHIFTU@MJOFT@TFOU\

TBWF@IJHITDPSFT@BOE@MJOFTIJHITDPSFTMJOFT@TFOU

^

^FMTF\

TBWF@IJHITDPSFT@BOE@MJOFT<UFUSJTTDPSF>

<UFUSJTOC@MJOFT>

^

QSJOUMO(BNFPWFS

QSJOUMO4DPSF\^\^

UFUSJTTDPSF

JGOFX@IJHIFTU@IJHITDPSF\</&8)*()4$03&>^FMTF\

^

QSJOUMO/VNCFSPGMJOFT\^\^

UFUSJTOC@MJOFT

[ 126 ]

Events and Basic Game Mechanisms Chapter 3

JGOFX@IJHIFTU@MJOFT@TFOU\</&8)*()4$03&>^FMTF\

^

QSJOUMO$VSSFOUMFWFM\^UFUSJTDVSSFOU@MFWFM

^

GOJT@UJNF@PWFSUFUSJT5FUSJTUJNFS4ZTUFN5JNF CPPM\

NBUDIUJNFSFMBQTFE\

0LFMBQTFE \

MFUNJMMJTFMBQTFEBT@TFDTBTV

FMBQTFETVCTFD@OBOPT

@@

NJMMJT -&7&-@5*.&4<UFUSJTDVSSFOU@MFWFMBTVTJ[F>

^

&SS@ GBMTF

^

^

GONBJO\

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPO

GBJMFE

MFUNVUUFUSJT5FUSJTOFX

MFUNVUUJNFS4ZTUFN5JNFOPX

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFEUP

HFU4%-FWFOU

QVNQ

MFUHSJE@YXJEUI5&53*4@)&*()5BTVBTJ

MFUHSJE@ZIFJHIU5&53*4@)&*()5BTVBTJ

MPPQ\

JGJT@UJNF@PWFSUFUSJTUJNFS\

MFUNVUNBLF@QFSNBOFOUGBMTF

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

MFUYQJFDFY

MFUZQJFDFZ

NBLF@QFSNBOFOU

QJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQYZ

^

JGNBLF@QFSNBOFOU\

UFUSJTNBLF@QFSNBOFOU

^

UJNFS4ZTUFN5JNFOPX

^

8FOFFEUPESBXUIFUFUSJTHSJEJOIFSF

JGUFUSJTDVSSFOU@QJFDFJT@OPOF\

[ 127 ]





Events and Basic Game Mechanisms Chapter 3

MFUDVSSFOU@QJFDFUFUSJTDSFBUF@OFX@UFUSJNJOP

JG

DVSSFOU@QJFDFUFTU@DVSSFOU@QPTJUJPOUFUSJTHBNF@NBQ\

QSJOU@HBNF@JOGPSNBUJPOUFUSJT

CSFBL

^

UFUSJTDVSSFOU@QJFDF4PNFDVSSFOU@QJFDF

^

MFUNVURVJUGBMTF

JGIBOEMF@FWFOUTNVUUFUSJTNVURVJUNVUUJNFSNVU

FWFOU@QVNQ\

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

8FOFFEUPESBXPVSDVSSFOUUFUSJNJOPJOIFSF

^

^

JGRVJU\

QSJOU@HBNF@JOGPSNBUJPOUFUSJT

CSFBL

^

8FOFFEUPESBXUIFHBNFNBQJOIFSF

TMFFQ%VSBUJPOOFX@@@V

^

^

Summary

Phew! That was quite the chapter! But now, all the game's mechanisms are here so adding the last remaining parts (such as the drawing) will be a piece of cake.

Once again, be sure to understand this chapter before starting to read the next one.

[ 128 ]





4

Adding All Game Mechanisms

In the previous chapters, $IBQUFS, Basics of Rust, $IBQUFS, Starting with SDL, and $IBQUFS, Events and Basic Game Mechanisms, we wrote all the mechanisms that we needed.

The only missing parts are the UI rendering and the font management. In short, the easy parts So in this chapter, we'll add the drawing of the game and some fonts handling as well.

Let's go!

Getting started with game mechanisms

Let's start with the UI rendering first and then add the font management in order to display the game information in real time.

Rendering UI

With the current code base, very few changes are required in order to be able to have a fully working Tetris.





Adding All Game Mechanisms

Chapter 4

Rendering initialization

For now, the NBJO function is very small. First, let's add the following lines at the top of the function:

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPO

GBJMFE

MFUWJEFP@TVCTZTUFNTEM@DPOUFYUWJEFPFYQFDU$PVMEO UHFU

4%-WJEFPTVCTZTUFN

MFUXJEUI

MFUIFJHIU

No need for explanations, we've already explained everything in the previous chapters, so let's continue.

Just after the following lines:

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPO

GBJMFE

MFUNVUUFUSJT5FUSJTOFX

MFUNVUUJNFS4ZTUFN5JNFOPX

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFEUP

HFU4%-FWFOUQVNQ

MFUHSJE@YXJEUI5&53*4@)&*()5BTVBTJ

MFUHSJE@ZIFJHIU5&53*4@)&*()5BTVBTJ

Let's add the following ones:

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPX5FUSJTXJEUIIFJHIU

QPTJUJPO@DFOUFSFEUPQVUJUJOUIFNJEEMFPGUIFTDSFFO

CVJMEUPDSFBUFUIFXJOEPX

FYQFDU'BJMFEUPDSFBUFXJOEPX

MFUNVUDBOWBTXJOEPXJOUP@DBOWBT

UBSHFU@UFYUVSF

QSFTFOU@WTZOD5PFOBCMFWTZOD

CVJME

FYQFDU$PVMEO UHFUXJOEPX TDBOWBT

MFUUFYUVSF@DSFBUPS5FYUVSF$SFBUPS@ DBOWBTUFYUVSF@DSFBUPS

MFUHSJEDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS



5&53*4@)&*()5BTV

[ 130 ]

Adding All Game Mechanisms

Chapter 4

5&53*4@)&*()5BTVFYQFDU'BJMFEUPDSFBUF

BUFYUVSF

MFUCPSEFSDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS



5&53*4@)&*()5BTV

5&53*4@)&*()5BTVFYQFDU'BJMFEUPDSFBUF

BUFYUVSF

NBDSP@SVMFTUFYUVSF\

SFYQSHFYQSCFYQS

DSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS

SHC

5&53*4@)&*()5BTV

5&53*4@)&*()5BTVVOXSBQ



^

MFUUFYUVSFT<UFYUVSFUFYUVSF

UFYUVSFUFYUVSFUFYUVSF

UFYUVSFUFYUVSF>

There's even a macro in the middle, so yes, a few explanations are required!

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPX5FUSJTXJEUIIFJHIU

QPTJUJPO@DFOUFSFE

CVJME

FYQFDU'BJMFEUPDSFBUFXJOEPX

MFUNVUDBOWBTXJOEPXJOUP@DBOWBT

UBSHFU@UFYUVSF

QSFTFOU@WTZOD

CVJME

FYQFDU$PVMEO UHFUXJOEPX TDBOWBT

MFUUFYUVSF@DSFBUPS5FYUVSF$SFBUPS@ DBOWBTUFYUVSF@DSFBUPS

We've already seen all this, so we'll just go very quickly through each: 1. We create the window.

2. We initialize the area where we'll draw.

3. We initialize the texture engine.

[ 131 ]





Adding All Game Mechanisms

Chapter 4

The two next calls are more interesting and are the start of the actual UI rendering: MFUHSJEDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS



5&53*4@)&*()5BTV

5&53*4@)&*()5BTVFYQFDU'BJMFEUPDSFBUFBUFYUVSF

MFUCPSEFSDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS



5&53*4@)&*()5BTV

5&53*4@)&*()5BTVFYQFDU'BJMFEUPDSFBUFB

UFYUVSF

They both call a function defined in $IBQUFS, Starting with SDL. HSJE is where we'll draw the tetriminoes and border to represent the borders of the game area. The first one is black, whereas the other one is white. The following is a screenshot of what they'll look like:

'JHVSF

[ 132 ]





Adding All Game Mechanisms

Chapter 4

So now let's write down the code to load more easily: NBDSP@SVMFTUFYUVSF\

SFYQSHFYQSCFYQS

DSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS

SHC

5&53*4@)&*()5BTV

5&53*4@)&*()5BTVVOXSBQ



^

We already introduced macros in $IBQUFS, Basics of Rust, so we will assume you'll understand pretty easily what this one is doing. (It calls the DSFBUF@UFYUVSF@SFDU

function with S, H, and C being the color we want the texture to be.) MFUUFYUVSFT<UFYUVSFUFYUVSF

UFYUVSFUFYUVSFUFYUVSF

UFYUVSFUFYUVSF>

In here, we create the textures for our tetriminoes blocks. So seven textures for seven types of tetrimino blocks.

We initialized everything we needed for the rendering. So now, let's render!

Rendering

Still in the NBJO function, but this time we're going into the main loop (no wordplay!). Just after the JT@UJNF@PWFS if condition, let's add:

DBOWBTTFU@ESBX@DPMPS$PMPS3(#

DBOWBTDMFBS

DBOWBTDPQZCPSEFS

/POF

3FDUOFXXJEUI5&53*4@)&*()5BTVBTJ

IFJHIU5&53*4@)&*()5BTVBTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

DBOWBTDPQZHSJE

/POF

3FDUOFXXJEUI5&53*4@)&*()5BTVBTJ

IFJHIU5&53*4@)&*()5BTVBTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

[ 133 ]

Adding All Game Mechanisms

Chapter 4

If we want to change the background depending on the player's actual level, we can just change the first line. No sweat.

About the following formulas:

3FDUOFXXJEUI5&53*4@)&*()5BTVBTJ

IFJHIU5&53*4@)&*()5BTVBTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

I think a small explanation might come in handy here. As you certainly remember, 3FDUOFX takes the four following arguments:

x position

y position

width

height

For the first two, we center our game map. For example, for the x position, we need to first compute how much width it'll take (so a width of tetriminoes): 5&53*4@)&*()5BTV

Then we subtract this from the total width:

XJEUI5&53*4@)&*()5BTV

What remains is what isn't the game map. So if we use it as x position, the game map will be fully on the left. Not pretty. Luckily, centering is quite easy, we just have to divide this result by 2, which is shown as follows:

XJEUI5&53*4@)&*()5BTVBTJ

And here we go! Now, about the subtraction of 10; it's because of the borders. It has a width of , so we need to subtract it as well to be really centered: XJEUI5&53*4@)&*()5BTVBTJ

Not very complicated, but it can be hard to read the first time. The same goes for the height, so we won't make the same explanations twice. Time to speak about the width and height computation! I think that you already got it from the previous explanations, but just in case: 5&53*4@)&*()5BTV

[ 134 ]

Adding All Game Mechanisms

Chapter 4

A 5FUSJT has a width of ten blocks. Therefore, our game map must have the same as well.

5&53*4@)&*()5BTV

We've now added the width of the total borders as well (since there is a border on each side and a border has a width of 10 pixels, ).

The same goes for the height.

Once you get how these formulas work, you'll get how all the others are working as well.

Since we've drawn the game environment, it's time to draw the tetriminoes. First, let's draw the current one! In order to do this, we need to update the GPS loop inside the IBOEMF@FWFOUT condition:

JGIBOEMF@FWFOUTNVUUFUSJTNVURVJUNVUUJNFSNVU

FWFOU@QVNQ\

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

GPSMJOF@OCMJOFJOQJFDFTUBUFT<QJFDFDVSSFOU@TUBUF

BTVTJ[F>JUFSFOVNFSBUF\

GPSDBTF@OCDBTFJOMJOFJUFSFOVNFSBUF\

JGDBTF\

DPOUJOVF

^

5IFOFXQBSUJTIFSF

DBOWBTDPQZUFYUVSFT<DBTFBTVTJ[F>

/POF

3FDUOFXHSJE@YQJFDFYDBTF@OCBTJTJ[FBT

J5&53*4@)&*()5BTJHSJE@ZQJFDFZ

MJOF@OCBTJ5&53*4@)&*()5BTJ5&53*4@)&*()5

BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

^

^

^

^

For each block of the current tetrimino, we paste a texture corresponding to its ID. From the explanations of the preceding formulas, we can suppose it's not necessary to go back on those new ones.

[ 135 ]

Adding All Game Mechanisms

Chapter 4

With this, only the last part is remaining; drawing all the other tetriminoes blocks: GPSMJOF@OCMJOFJOUFUSJTHBNF@NBQJUFSFOVNFSBUF\

GPSDBTF@OCDBTFJOMJOFJUFSFOVNFSBUF\

JGDBTF\

DPOUJOVF

^

DBOWBTDPQZUFYUVSFT<DBTFBTVTJ[F>

/POF3FDUOFXHSJE@YDBTF@OCBTJ5&53*4@)&*()5

BTJHSJE@ZMJOF@OCBTJ5&53*4@)&*()5BTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

^

^

DBOWBTQSFTFOU

In this code, we iterate over a block of each line of the game map and paste the corresponding texture, if the game map's occupied.

Once done, we apply all the changes to the display, with: DBOWBTQSFTFOU

With this, our 5FUSJT is now complete! You can now play by launching the command: cargo run --release

The SFMFBTF is for starting the program in non-debug mode.

The full code of the NBJO function is now the following: GONBJO\

MFUTEM@DPOUFYUTEMJOJUFYQFDU4%-JOJUJBMJ[BUJPOGBJMFE

MFUWJEFP@TVCTZTUFNTEM@DPOUFYUWJEFPFYQFDU$PVMEO UHFU

4%-WJEFPTVCTZTUFN

MFUXJEUI

MFUIFJHIU

MFUNVUUJNFS4ZTUFN5JNFOPX

MFUNVUFWFOU@QVNQTEM@DPOUFYUFWFOU@QVNQFYQFDU'BJMFEUPHFU

4%-FWFOUQVNQ

MFUHSJE@YXJEUI5&53*4@)&*()5BTVBTJ

MFUHSJE@ZIFJHIU5&53*4@)&*()5BTVBTJ

MFUNVUUFUSJT5FUSJTOFX

MFUXJOEPXWJEFP@TVCTZTUFNXJOEPX5FUSJTXJEUIIFJHIU

QPTJUJPO@DFOUFSFE

CVJME

[ 136 ]

Adding All Game Mechanisms

Chapter 4

FYQFDU'BJMFEUPDSFBUFXJOEPX

MFUNVUDBOWBTXJOEPXJOUP@DBOWBT

UBSHFU@UFYUVSF

QSFTFOU@WTZOD

CVJME

FYQFDU$PVMEO UHFUXJOEPX TDBOWBT

MFUUFYUVSF@DSFBUPS5FYUVSF$SFBUPS@ DBOWBTUFYUVSF@DSFBUPS

MFUHSJEDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS



5&53*4@)&*()5BTV

5&53*4@)&*()5BTVFYQFDU'BJMFEUPDSFBUF

BUFYUVSF

MFUCPSEFSDSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS



5&53*4@)&*()5BTV

5&53*4@)&*()5BTVFYQFDU'BJMFEUPDSFBUF

BUFYUVSF

NBDSP@SVMFTUFYUVSF\

SFYQSHFYQSCFYQS

DSFBUF@UFYUVSF@SFDUNVUDBOWBT

UFYUVSF@DSFBUPS

SHC

5&53*4@)&*()5BTV

5&53*4@)&*()5BTVVOXSBQ



^

MFUUFYUVSFT<UFYUVSFUFYUVSF

UFYUVSFUFYUVSF

UFYUVSFUFYUVSF

UFYUVSF>

MPPQ\

JGJT@UJNF@PWFSUFUSJTUJNFS\

MFUNVUNBLF@QFSNBOFOUGBMTF

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

MFUYQJFDFY

MFUZQJFDFZ

NBLF@QFSNBOFOUQJFDFDIBOHF@QPTJUJPOUFUSJTHBNF@NBQ

YZ

^

[ 137 ]

Adding All Game Mechanisms

Chapter 4

JGNBLF@QFSNBOFOU\

UFUSJTNBLF@QFSNBOFOU

^

UJNFS4ZTUFN5JNFOPX

^

DBOWBTTFU@ESBX@DPMPS$PMPS3(#

DBOWBTDMFBS

DBOWBTDPQZCPSEFS

/POF

3FDUOFXXJEUI5&53*4@)&*()5BTVBTJ

IFJHIU5&53*4@)&*()5BTVBTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

DBOWBTDPQZHSJE

/POF

3FDUOFXXJEUI5&53*4@)&*()5BTVBTJ

IFJHIU5&53*4@)&*()5BTVBTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

JGUFUSJTDVSSFOU@QJFDFJT@OPOF\

MFUDVSSFOU@QJFDFUFUSJTDSFBUF@OFX@UFUSJNJOP

JGDVSSFOU@QJFDFUFTU@DVSSFOU@QPTJUJPOUFUSJTHBNF@NBQ\ QSJOU@HBNF@JOGPSNBUJPOUFUSJT

CSFBL

^

UFUSJTDVSSFOU@QJFDF4PNFDVSSFOU@QJFDF

^

MFUNVURVJUGBMTF

JGIBOEMF@FWFOUTNVUUFUSJTNVURVJUNVUUJNFS

NVUFWFOU@QVNQ\

JGMFU4PNFSFGNVUQJFDFUFUSJTDVSSFOU@QJFDF\

GPSMJOF@OCMJOFJOQJFDFTUBUFT<QJFDFDVSSFOU@TUBUF

BTVTJ[F>JUFSFOVNFSBUF\

GPSDBTF@OCDBTFJOMJOFJUFSFOVNFSBUF\

JGDBTF\

DPOUJOVF

^

DBOWBTDPQZUFYUVSFT<DBTFBTVTJ[F>

/POF

3FDUOFXHSJE@YQJFDFYDBTF@OCBTJTJ[F

BTJ5&53*4@)&*()5BTJ

HSJE@ZQJFDFZMJOF@OCBTJ5&53*4@)&*()5

BTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

[ 138 ]

Adding All Game Mechanisms

Chapter 4

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

^

^

^

^

JGRVJU\

QSJOU@HBNF@JOGPSNBUJPOUFUSJT

CSFBL

^

GPSMJOF@OCMJOFJOUFUSJTHBNF@NBQJUFSFOVNFSBUF\

GPSDBTF@OCDBTFJOMJOFJUFSFOVNFSBUF\

JGDBTF\

DPOUJOVF

^

DBOWBTDPQZUFYUVSFT<DBTFBTVTJ[F>

/POF

3FDUOFXHSJE@YDBTF@OCBTJ5&53*4@)&*()5BTJ

HSJE@ZMJOF@OCBTJ5&53*4@)&*()5BTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

^

^

DBOWBTQSFTFOU

TMFFQ%VSBUJPOOFX@@@V

^

^

[ 139 ]





Adding All Game Mechanisms

Chapter 4

And here is an example of the current output of this code:

'JHVSF

It's now working, but what about displaying the game information, such as the current score, level, or the number of lines sent?

Playing with fonts

To display these pieces of information, we'll need to use fonts. No additional external dependencies are required, however, we'll need to use a feature, so we need to update our $BSHPUPNM:

<GFBUVSFT>

EFGBVMU<TEMUUG>

[ 140 ]





Adding All Game Mechanisms

Chapter 4

By default, the TEM crate doesn't provide the UUG module, you need to enable it by adding the UUG feature to the compilation process. That's what we did by saying to DBSHP: by default, I want the UUG feature of the TEM crate enabled. You can try with and without it to see the difference, after adding this new context initialization: MFUUUG@DPOUFYUTEMUUGJOJUFYQFDU4%-55'JOJUJBMJ[BUJPO

GBJMFE

If you get a missing library compilation error, it means you didn't install the corresponding library. To fix this issue, you need to install it through your favorite package manager.

Install on OS X

Run the following command:

brew install sdl2_ttf

Install on Linux

Run the following command (depending on your package manager, of course): sudo apt-get install libsdl2-ttf-dev

Other system/package manager

You can download the library at IUUQTXXXMJCTEMPSHQSPKFDUT4%-@UUG

Follow the instructions and install it on your system, then just run the projects. If no errors appear, then it means you installed it correctly.

Time to start the real thing!

[ 141 ]





Adding All Game Mechanisms

Chapter 4

Loading font

Before going any further, we actually need a font. I chose Lucida console, but pick the one you prefer, it doesn't really matter. Once downloaded, put it in the BTTFUT folder as well.

Now, time to actually load the font:

MFUGPOUUUG@DPOUFYUMPBE@GPOUBTTFUTMVDJEBUUGFYQFDU

$PVMEO UMPBEUIFGPOU

Note that if you want to apply a style to your font (such as bold, italic, strikethrough, or underline), that's the object on which you need to apply it. Here is an example: GPOUTFU@TUZMFTEMUUG45:-&@#0-%

Now, two steps are remaining to be able to actually display text: 1. Render the text.

2. Create a texture from it.

Let's write a function in order to do so:

GODSFBUF@UFYUVSF@GSPN@UFYU B UFYUVSF@DSFBUPS B

5FYUVSF$SFBUPS8JOEPX$POUFYU

GPOUTEMUUG'POU

UFYUTUS

SVHVCV

0QUJPO5FYUVSF B \

JGMFU0LTVSGBDFGPOUSFOEFSUFYU

CMFOEFE$PMPS3(#SHC\

UFYUVSF@DSFBUPSDSFBUF@UFYUVSF@GSPN@TVSGBDFTVSGBDFPL

^FMTF\

/POF

^

^

Looks a lot like DSFBUF@UFYUVSF@SFDU, right?

Why not test it? Let's call the function and paste the texture onto the screen to see: MFUSFOEFSFE@UFYUDSFBUF@UFYUVSF@GSPN@UFYUUFYUVSF@DSFBUPS

GPOUUFTUFYQFDU$BOOPUSFOEFSUFYU

DBOWBTDPQZSFOEFSFE@UFYU/POF4PNF3FDUOFXXJEUIBTJ



FYQFDU$PVMEO UDPQZUFYU

[ 142 ]





Adding All Game Mechanisms

Chapter 4

And it looks like this:

'JHVSF

For the texture rectangle, I use the following rule: one character is a block of 10 x 30 pixels.

So in this example, since UFTU has 4 letters, we need a block of 40 x 30 pixels. Let's write a function to make this easier:

GOHFU@SFDU@GSPN@UFYUUFYUTUSYJZJ 0QUJPO3FDU \

4PNF3FDUOFXYZUFYUMFOBTV

^

[ 143 ]

Adding All Game Mechanisms

Chapter 4

Ok, so now is the time to render the game information and write a new function to do it: GOEJTQMBZ@HBNF@JOGPSNBUJPO B UFUSJT5FUSJT

DBOWBTNVU$BOWBT8JOEPX

UFYUVSF@DSFBUPS B5FYUVSF$SFBUPS8JOEPX$POUFYU

GPOUTEMUUG'POU

TUBSU@Y@QPJOUJ\

MFUTDPSF@UFYUGPSNBU4DPSF\^UFUSJTTDPSF

MFUMJOFT@TFOU@UFYUGPSNBU-JOFTTFOU\^UFUSJTOC@MJOFT

MFUMFWFM@UFYUGPSNBU-FWFM\^UFUSJTDVSSFOU@MFWFM

MFUTDPSFDSFBUF@UFYUVSF@GSPN@UFYUUFYUVSF@DSFBUPSGPOU

TDPSF@UFYU

FYQFDU$BOOPUSFOEFSUFYU

MFUMJOFT@TFOUDSFBUF@UFYUVSF@GSPN@UFYUUFYUVSF@DSFBUPSGPOU

MJOFT@TFOU@UFYU

FYQFDU$BOOPUSFOEFSUFYU

MFUMFWFMDSFBUF@UFYUVSF@GSPN@UFYUUFYUVSF@DSFBUPSGPOU

MFWFM@UFYU

FYQFDU$BOOPUSFOEFSUFYU

DBOWBTDPQZTDPSF/POFHFU@SFDU@GSPN@UFYUTDPSF@UFYU

TUBSU@Y@QPJOU

FYQFDU$PVMEO UDPQZUFYU

DBOWBTDPQZMJOFT@TFOU/POFHFU@SFDU@GSPN@UFYUTDPSF@UFYU

TUBSU@Y@QPJOU

FYQFDU$PVMEO UDPQZUFYU

DBOWBTDPQZMFWFM/POFHFU@SFDU@GSPN@UFYUTDPSF@UFYU

TUBSU@Y@QPJOU

FYQFDU$PVMEO UDPQZUFYU

^

And then we call it, as follows:

EJTQMBZ@HBNF@JOGPSNBUJPOUFUSJTNVUDBOWBTUFYUVSF@DSFBUPSGPOU

XJEUIBTJHSJE@Y

[ 144 ]





Adding All Game Mechanisms

Chapter 4

And now it looks like this:

'JHVSF

Wonderful, we have the game information in real time! Isn't it awesome? What? It's ugly and overlaps the game? Let's move the game then! Instead of centering it, we'll give it a fixed Y position (which will make our formula way simpler).

First, let's update our HSJE@Y variable:

MFUHSJE@Y

Then, let's update so DBOWBTDPQZ calls:

DBOWBTDPQZCPSEFS

/POF

3FDUOFX

IFJHIU5&53*4@)&*()5BTVBTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

[ 145 ]





Adding All Game Mechanisms

Chapter 4



FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

DBOWBTDPQZHSJE

/POF

3FDUOFX

IFJHIU5&53*4@)&*()5BTVBTJ

5&53*4@)&*()5BTV5&53*4@)&*()5BTV

FYQFDU$PVMEO UDPQZUFYUVSFJOUPXJOEPX

And that's it. You now have a nice Tetris playing:

'JHVSF

[ 146 ]





Adding All Game Mechanisms

Chapter 4

We could improve the display a bit by adding a border around the text, or even display a preview of the next piece, or even add a ghost, but I think that, from this point, you can add them easily.

That's it for this Tetris, have fun while playing with the TEM!

Summary

We now have a fully working Tetris. In the last three chapters, we saw how to use the TEM

crate, how to add dependencies to Rust projects, how to handle I/O (with files), and how modules were working.

Even if we stop here for this Tetris project, you can continue this project (and it'd be even a good idea to improve yourself in TEM!). A few ideas of missing things you could add: Change the background depending on the current level Asking the players, once the game is over, if they want to start a new game Adding the next tetrimino preview

Adding a ghost (to see where the tetrimino will fall) And so much more. Just have fun while adding new features!

As you can see, a lot of things are possible. Have fun!

[ 147 ]





5

Creating a Music Player

In previous chapters you created an awesome game, so now let's move on to another exciting topicbdesktop applications. We'll use the Rust bindings of the GTK+ library in order to code an MP3 music player. We'll have the opportunity to learn about threads to code the music player itself in the next chapter. But, in this chapter, we'll focus on the graphical interface, how to manage the layout of the interface, and how to manage user events.

We will cover the following topics in this chapter: Windows

Widgets

Events

Closures

Event loops

Containers

Installing the prerequisite

Since GTK+ is a C library, we'll need to install it first. The Rust bindings use GTK+ version 3, so make sure you do not install the old version 2.





Creating a Music Player

Chapter 5

Installing GTK+ on Linux

On Linux, GTK+ can be installed through the package manager of your distribution.

On Ubuntu (or other Debian derivatives):

sudo apt-get install libgtk-3-dev

Installing GTK+ on Mac

On OSX, you just need to run the following command: brew install gtk+3 gnome-icon-theme

Installing GTK+ on Windows

On Windows, you'll need to first download and install MSYS2, which provides a Unix-like environment on Windows. After it is installed, issue the following command in a MSYS2

shell:

pacman -S mingw-w64-x86_64-gtk3

Creating your first window

Now we're ready to start using GTK+ from Rust. Let's create a new project for our music player:

cargo new rusic --bin

Add the dependency on the HJP and HUL crates in your $BSHPUPNM file: HJP?

HUL?

[ 149 ]



Creating a Music Player

Chapter 5

Replace the content of the TSDNBJOST file with this: FYUFSODSBUFHJP

FYUFSODSBUFHUL

VTFTUEFOW

VTFHJP\"QQMJDBUJPO&YU"QQMJDBUJPO&YU.BOVBM"QQMJDBUJPO'MBHT^

VTFHUL\

"QQMJDBUJPO

"QQMJDBUJPO8JOEPX

8JEHFU&YU

(UL8JOEPX&YU

^

GONBJO\

MFUBQQMJDBUJPO"QQMJDBUJPOOFXDPNHJUIVCSVTUCZ

FYBNQMF"QQMJDBUJPO'MBHTFNQUZ

FYQFDU"QQMJDBUJPOJOJUJBMJ[BUJPOGBJMFE

BQQMJDBUJPODPOOFDU@TUBSUVQ]BQQMJDBUJPO]\

MFUXJOEPX"QQMJDBUJPO8JOEPXOFXBQQMJDBUJPO

XJOEPXTFU@UJUMF3VTJD

XJOEPXTIPX

^

BQQMJDBUJPODPOOFDU@BDUJWBUF]@]\^

BQQMJDBUJPOSVOFOWBSHTDPMMFDU7FD@

^

Then, run the application with DBSHPSVO. You should see a small and empty window:

'JHVSF

[ 150 ]

Creating a Music Player

Chapter 5

If you saw this window, it means you have installed GTK+ correctly.

Let's explain this code in smaller chunks:

FYUFSODSBUFHJP

FYUFSODSBUFHUL

As usual, when using an external crate, we need to declare it.

Then, we import the types and modules we'll use from the standard library, HJP, and HUL: VTFTUEFOW

VTFHJP\"QQMJDBUJPO&YU"QQMJDBUJPO&YU.BOVBM"QQMJDBUJPO'MBHT^

VTFHUL\

"QQMJDBUJPO

"QQMJDBUJPO8JOEPX

8JEHFU&YU

(UL8JOEPX&YU

^

After that, we start the NBJO function:

GONBJO\

MFUBQQMJDBUJPO"QQMJDBUJPOOFXDPNHJUIVCSVTUCZ

FYBNQMF

"QQMJDBUJPO'MBHTFNQUZ

FYQFDU"QQMJDBUJPOJOJUJBMJ[BUJPOGBJMFE

The first line of this function creates a new HJP application. We provide an application ID

that can be used to make sure the application is only run once. An "QQMJDBUJPO makes it easier to manage applications and its windows.

Next, we create the window, set its title, and show it to the screen: BQQMJDBUJPODPOOFDU@TUBSUVQ]BQQMJDBUJPO]\

MFUXJOEPX"QQMJDBUJPO8JOEPXOFXBQQMJDBUJPO

XJOEPXTFU@UJUMF3VTJD

XJOEPXTIPX

^

BQQMJDBUJPODPOOFDU@BDUJWBUF]@]\^

After creating a new window, we set its title and show it.

[ 151 ]





Creating a Music Player

Chapter 5

Here, we're actually handling an event; the TUBSUVQ is a signal that is emitted when the application is registered- so, when it is ready to be used. As you can see in the documentation on GTK+ (IUUQTEFWFMPQFSHOPNFPSHHJPTUBCMF("QQMJDBUJPO

IUNM("QQMJDBUJPOTUBSUVQ), signals are represented by strings. This signal is actually called TUBSUVQ, but the Rust method we used to connect this signal is DPOOFDU@TUBSUVQ.

So, we need to add DPOOFDU@ before the signal name and change the dashes to underscores.

Closure

The argument of this method is somewhat special:

]BQQMJDBUJPO]\

MFUXJOEPX"QQMJDBUJPO8JOEPXOFXBQQMJDBUJPO

XJOEPXTFU@UJUMF3VTJD

XJOEPXTIPX

^

This is what we call a closure. A closure is a concise way of declaring a function that does not have a name and can capture the environment. Capturing the environment means that it can access the variables from outside the closure, something which is not possible to do with normal functions. The methods to connect a signal will run the function (in this case, a closure) passed as an argument. Here, create the window.

We could have decided to create a normal function, as the following code does: GOTUBSUVQ@IBOEMFSBQQMJDBUJPO"QQMJDBUJPO\

MFUXJOEPX"QQMJDBUJPO8JOEPXOFXBQQMJDBUJPO

XJOEPXTFU@UJUMF3VTJD

XJOEPXTIPX

^

*OUIFNBJOGVODUJPO

BQQMJDBUJPODPOOFDU@TUBSUVQTUBSUVQ@IBOEMFS

But that is less convenient than using a closure. Besides the fact that you might need to import other crates and types, you need to specify the types of the parameters and the return type. Indeed, type inference is available for closures but not for functions. Also, the function must be declared elsewhere, so it can become less readable than using a closure.

The rest of the NBJO function is:

BQQMJDBUJPOSVOFOWBSHTDPMMFDU7FD@

^

[ 152 ]





Creating a Music Player

Chapter 5

This starts the HUL event loop. This is an infinite loop that processes the user events like a button click or a request to close a window. It also manages other things like timeouts and asynchronous, IO-like network requests.

Some event handlers require you to return a value, which is the case for the signal EFMFUF@FWFOU where we need to return *OIJCJUGBMTF.

Preventing the default behavior of an event

The *OIJCJU type is only a wrapper over the CPPM type. It is used to indicate whether we should stop propagating the event to the default handler or not. To see what this means, let's add an event handler for the window:

XJOEPXDPOOFDU@EFMFUF@FWFOU]@@]\

*OIJCJUUSVF

^

If you run it, you'll note that we cannot close the window anymore. That's because we returned *OIJCJUUSVF to indicate that we want to prevent the default behavior of the EFMFUF@FWFOU signal, which is to close the window.

Now let's try a slight variant of the previous code: XJOEPXDPOOFDU@EFMFUF@FWFOU]@@]\

*OIJCJUGBMTF

^

In this case, we do not prevent the default handler from being run, so the window will be closed.

Creating a toolbar

We'll start our music player by adding a toolbar with the buttons needed for such software: Open a file

Play

Pause

Stop

Previous/next song

Remove song from playlist

[ 153 ]



Creating a Music Player

Chapter 5

That'll be a good start for our first non-empty window.

First of all, we'll need some additional import statements: VTFHUL\

$POUBJOFS&YU

4FQBSBUPS5PPM*UFN

5PPMCBS

5PPM#VUUPO

^

Then, we'll declare a constant because we'll use this value elsewhere: DPOTU1-":@450$,TUSHULNFEJBQMBZ

We'll explain what this is very soon.

We'll now create a toolbar and add it to the window: GONBJO\

4BNFDPEFUPJOJUJBMJ[FHULDSFBUFUIFXJOEPX

BQQMJDBUJPODPOOFDU@TUBSUVQ]BQQMJDBUJPO]\

d

MFUUPPMCBS5PPMCBSOFX

XJOEPXBEEUPPMCBS

Note: Don't call XJOEPXTIPX yet, as we'll use another method ahead.

This code is pretty straightforward. The only thing to note is that the HULST API requires a reference to values in most cases; in this case, we send a reference to the toolbar as a parameter to the BEE method.

You'll see this BEE method called literally everywhere. It allows you to add a widget to another. A widget is a component (visual or not) of a user interface. It can be a button, a menu, a separator, but it can also be an invisible component such as a box allowing you to place the widgets horizontally. We'll talk about containers like HUL#PY and how to lay out our widgets later in this chapter.

Let's add a button to this toolbar:

MFUPQFO@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULPQFO

UPPMCBSBEEPQFO@CVUUPO

[ 154 ]





Creating a Music Player

Chapter 5

This creates a toolbar button and adds it to the toolbar.

Stock item

Instead of using the usual OFX constructor, we decided to use the OFX@GSPN@TUPDL

one here. This takes a string as an argument. This string is an identifier for the item that represents a built-in menu or toolbar item, such as 0QFO or 4BWF. These items have an icon and a label that is translated according to the user locale. By using stock items, you can quickly create a beautiful application that will look the same as other applications built with GTK+.

Let's show this window containing the toolbar:

XJOEPXTIPX@BMM

^

This goes right at the end of the startup event handler. Here, we use TIPX@BMM instead of only TIPX because we have more widgets to show. Instead of using TIPX@BMM, we could call TIPX on every single widget, but this can become cumbersome; that's why TIPX@BMM exists.

If you run this application, you'll see the following window with an open button:

'JHVSF

Let's add the open buttons we'll need:

UPPMCBSBEE4FQBSBUPS5PPM*UFNOFX

MFUQSFWJPVT@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULNFEJBQSFWJPVT

UPPMCBSBEEQSFWJPVT@CVUUPO

MFUQMBZ@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDL1-":@450$, UPPMCBSBEEQMBZ@CVUUPO

MFUTUPQ@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULNFEJBTUPQ

UPPMCBSBEETUPQ@CVUUPO

[ 155 ]





Creating a Music Player

Chapter 5

MFUOFYU@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULNFEJBOFYU

UPPMCBSBEEOFYU@CVUUPO

UPPMCBSBEE4FQBSBUPS5PPM*UFNOFX

MFUSFNPWF@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULSFNPWF

UPPMCBSBEESFNPWF@CVUUPO

UPPMCBSBEE4FQBSBUPS5PPM*UFNOFX

MFURVJU@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULRVJU

UPPMCBSBEERVJU@CVUUPO

This code should go right before the call to XJOEPXTIPX@BMM. 4FQBSBUPS5PPM*UFN , which was added several times to separate the buttons logically so that buttons for similar actions are grouped together.

Now we have an application that is starting to look like a music player, as follows:

'JHVSF

Improving the organization of the application

The NBJO function is starting to get bigger, so we'll refactor our code a little to make it easier to update in the upcoming sections and chapters.

First, we'll create a new module called UPPMCBS. As a reminder, here's how to do so: 1. Create a new file: TSDUPPMCBSST.

2. Add a statement, NPEUPPMCBS, at the top of the file NBJOST.

[ 156 ]

Creating a Music Player

Chapter 5

This new module UPPMCBS will start with the import statement and the DPOTU declaration: VTFHUL\

$POUBJOFS&YU

4FQBSBUPS5PPM*UFN

5PPMCBS

5PPM#VUUPO

^

DPOTU1-":@450$,TUSHULNFEJBQMBZ

We'll then create a new structure holding all the widgets that compose the toolbar: QVCTUSVDU.VTJD5PPMCBS\

PQFO@CVUUPO5PPM#VUUPO

OFYU@CVUUPO5PPM#VUUPO

QMBZ@CVUUPO5PPM#VUUPO

QSFWJPVT@CVUUPO5PPM#VUUPO

RVJU@CVUUPO5PPM#VUUPO

SFNPWF@CVUUPO5PPM#VUUPO

TUPQ@CVUUPO5PPM#VUUPO

UPPMCBS5PPMCBS

^

We use the QVC keyword here because we want to be able to use this type from other modules.

Then, we'll create a constructor for this TUSVDU that will create all the buttons, like we did earlier:

JNQM.VTJD5PPMCBS\

QVCGOOFX 4FMG\

MFUUPPMCBS5PPMCBSOFX

MFUPQFO@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULPQFO

UPPMCBSBEEPQFO@CVUUPO



MFURVJU@CVUUPO5PPM#VUUPOOFX@GSPN@TUPDLHULRVJU

UPPMCBSBEERVJU@CVUUPO

.VTJD5PPMCBS\

PQFO@CVUUPO

OFYU@CVUUPO

QMBZ@CVUUPO

QSFWJPVT@CVUUPO

[ 157 ]

Creating a Music Player

Chapter 5

RVJU@CVUUPO

SFNPWF@CVUUPO

TUPQ@CVUUPO

UPPMCBS

^

^

^

The only difference with the previous code is that we now return a TUSVDU

.VTJD5PPMCBS. We'll also add a method in this JNQM to be able to access the HUL5PPMCBS widget from the outside:

QVCGOUPPMCBSTFMG 5PPMCBS\

TFMGUPPMCBS

^

That's all for now for this UPPMCBS module. Let's go back to the NBJO module. First, we need to import our new .VTJD5PPMCBS type:

VTFUPPMCBS.VTJD5PPMCBS

Next, we'll create a structure like we did for our toolbar: TUSVDU"QQ\

UPPMCBS.VTJD5PPMCBS

XJOEPX"QQMJDBUJPO8JOEPX

^

And we will also create a constructor for it:

JNQM"QQ\

GOOFXBQQMJDBUJPO"QQMJDBUJPO 4FMG\

MFUXJOEPX"QQMJDBUJPO8JOEPXOFXBQQMJDBUJPO

XJOEPXTFU@UJUMF3VTJD

MFUUPPMCBS.VTJD5PPMCBSOFX

XJOEPXBEEUPPMCBSUPPMCBS

XJOEPXTIPX@BMM

MFUBQQ"QQ\

UPPMCBS

XJOEPX

^

BQQDPOOFDU@FWFOUT

[ 158 ]





Creating a Music Player

Chapter 5

BQQ

^

^

Here, we created the window as we did before and then created our own .VTJD5PPMCBS

structure. We add the wrapped toolbar widget by sending the result of the UPPMCBS

method (which returns the HUL widget) to the BEE method.

After that, we used a little trick that enabled us to call a method on the TUSVDU yet to be created; we first assign the TUSVDU to a variable, then call the method and return the variable. This method is defined next, within the same JNQM block: GODPOOFDU@FWFOUTTFMG\

^

We'll fill in this method in the next chapter.

Adding tool button events

We'll continue by adding event handlers to some of the buttons.

First of all, we'll need new VTF statements:

VTFHUL\

5PPM#VUUPO&YU

8JEHFU&YU

^

VTF"QQ

We import 5PPM#VUUPO&YU, which provides methods to be called on 5PPM#VUUPO and "QQ

from the NBJO module, because we'll add a new method to this type: JNQM"QQ\

QVCGODPOOFDU@UPPMCBS@FWFOUTTFMG\

MFUXJOEPXTFMGXJOEPXDMPOF

TFMGUPPMCBSRVJU@CVUUPODPOOFDU@DMJDLFENPWF]@]\

XJOEPXEFTUSPZ

^

^

^

[ 159 ]

Creating a Music Player

Chapter 5

In Rust, it's perfectly valid to declare a method in a module different to where the type was created. Here, we say that clicking the quit button will destroy the window, which will effectively exit the application.

Let's add another event that will toggle the play button image with the pause image: MFUQMBZ@CVUUPOTFMGUPPMCBSQMBZ@CVUUPODMPOF

TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGQMBZ@CVUUPOHFU@TUPDL@JE4PNF1-":@450$,UP@TUSJOH\ QMBZ@CVUUPOTFU@TUPDL@JE1"64&@450$,

^FMTF\

QMBZ@CVUUPOTFU@TUPDL@JE1-":@450$,

^

^

This code requires a new constant to be added next to 1-":@450$,: DPOTU1"64&@450$,TUSHULNFEJBQBVTF

Let's first look at the body of the closure before looking at the peculiarities of this code.

Here, we use a condition to check whether the button is showing the play imagebif it is, we switch to the pause stock item. Otherwise, we switch back to the play icon.

But why do we need to clone the button and use this NPWF keyword before the closure?

Let's try the normal way, that is, how you would do that in most programming languages: TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFE]@]\

JGTFMGUPPMCBSQMBZ@CVUUPOHFU@TUPDL@JE

4PNF1-":@450$,UP@TUSJOH\

TFMGUPPMCBSQMBZ@CVUUPOTFU@TUPDL@JE1"64&@450$,

^FMTF\

TFMGUPPMCBSQMBZ@CVUUPOTFU@TUPDL@JE1-":@450$,

^

^

If we do that, we get the following compilation error: error[E0477]: the typÃ¨[closure@src/toolbar.rs:79:50: 85:10 self:&&App]`

does not fulfill the required lifetime

--> src/toolbar.rs:79:34

|

79 | self.toolbar.play_button.connect_clicked(|_| {

| ^^^^^^^^^^^^^^^

|

= note: type must satisfy the static lifetime error[E0495]: cannot infer an appropriate lifetime for capture of `self` by

[ 160 ]





Creating a Music Player

Chapter 5

closure due to conflicting requirements

--> src/toolbar.rs:79:50

|

79 | self.toolbar.play_button.connect_clicked(|_| {

| __________________________________________________^

80 | | if self.toolbar.play_button.get_stock_id() ==

Some(PLAY_STOCK.to_string()) {

81 | | self.toolbar.play_button.set_stock_id(PAUSE_STOCK); 82 | | } else {

83 | | self.toolbar.play_button.set_stock_id(PLAY_STOCK); 84 | | }

85 | | });

| |_________^

And it continues even further to explain why the lifetime cannot be inferred.

Let's look at the signature of the DPOOFDU@DMJDLFE method to understand what's going on:

GODPOOFDU@DMJDLFE''O4FMG TUBUJD TFMGG' V

The 'O4FMG part means the function requires something that looks like a function that takes a parameter that is a reference to 4FMG (5PPM#VUUPO in this case). The TUBUJD part is a lifetime annotation.

Lifetime

Lifetime is one of the Rust features that the compiler uses to ensure memory safety. The lifetime specifies the minimum duration an object must live to be used safely. Let's try to do something that is allowed in certain programming languages, but is actually an error to do so:

GOHFU@FMFNFOU@JODFMFNFOUT<J>JOEFYVTJ[F J\

MFUFMFNFOUFMFNFOUT<JOEFY>

FMFNFOU

^

[ 161 ]



Creating a Music Player

Chapter 5

Here, we try to return a reference from a stack-allocated value. The problem is that this value will be deallocated when the function returns and the caller will try to access this deallocated value. In other programming languages, this code will compile fine and produce (hopefully) a segmentation fault at runtime. But Rust is a safe programming language and refuses to compile such code:

error[E0597]: Ã¨lement` does not live long enough

--> src/main.rs:3:6

|

3 | &element

| ^^^^^^^ does not live long enough

4 | }

| - borrowed value only lives until here

The compile noticed that the value FMFNFOU will be deallocated at the end of the function; that's what the sentence on the last line means. This is right, because the lifetime of FMFNFOU

starts from its declaration until the end of the scope where it is declared; here, the scope is the function. Here's an illustration of the lifetime of FMFNFOU:

'JHVSF

But how does the compiler know what the required lifetime is for the returned value? To answer this question, let's add the lifetime annotations that were added by the compiler: GOHFU@FMFNFOU@JOD B FMFNFOUT B<J>JOEFYVTJ[F B

J\

MFUFMFNFOUFMFNFOUT<JOEFY>

FMFNFOU

^

As you can see, the syntax for lifetimes is the same as the one used for labelsb MBCFM.

When we want to specify the lifetimes, we need to declare the lifetime names between angle brackets, in a similar way to how we declare generic types. In this case, we specified that the lifetime of the returned value must be the same as the one from the parameter FMFNFOUT.

[ 162 ]



Creating a Music Player

Chapter 5

Let's annotate the code again with lifetimes:

'JHVSF

Here, we clearly see that the lifetime of the returned value is smaller than the required one; that's why the compiler rejected our code.

In this case, there are two ways to fix this code (without changing the signature). One way to get a value that satisfies the lifetime B is to get a reference to a value of the same lifetime; the parameter FMFNFOUT also has the lifetime B , so we can write the following code:

GOHFU@FMFNFOU B FMFNFOUT B<J>JOEFYVTJ[F BJ\ FMFNFOUT<JOEFY>

^

Another way is to return a reference to a value of lifetime TUBUJD. This special lifetime is equal to the duration of the program, that is, the value must live until the end of the program. One way to get such a lifetime is to use a literal: GOHFU@FMFNFOU B FMFNFOUT B<J>JOEFYVTJ[F BJ\



^

The lifetime TUBUJD satisfies the constraint B because TUBUJD lives longer than the latter.

In both of these examples, the lifetime annotations were not required. We didn't have to specify the lifetime in the first place, thanks to a feature called lifetime elision; the compiler can infer what the required lifetimes are in most cases by following these simple rules: A different lifetime parameter is assigned to each parameter

[ 163 ]



Creating a Music Player

Chapter 5

If there's only one parameter that needs a lifetime, that lifetime is assigned to every lifetime in the return value (as for our HFU@FMFNFOU function) If there are multiple parameters that need a lifetime, but one of them is for TFMG, the lifetime for TFMG is assigned to every lifetime in the return value Let's go back to the method signature:

GODPOOFDU@DMJDLFE''O4FMG TUBUJD TFMGG' V

Here, we notice that the parameter G has the TUBUJD lifetime. We now know that this means that this parameter must live until the end of the program. That's why we cannot use the normal version of the closure: because the lifetime of TFMG is not TUBUJD , meaning the BQQ will get deallocated when the NBJO function ends. To make this work, we cloned the QMBZ@CVUUPO variable:

MFUQMBZ@CVUUPOTFMGUPPMCBSQMBZ@CVUUPODMPOF

Now we can use this new variable in the closure.

Note: Take note that cloning a GTK+ widget is really cheap; only a pointer is cloned.

However, trying to do the following will still result in a compilation error: MFUQMBZ@CVUUPOTFMGUPPMCBSQMBZ@CVUUPODMPOF

TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFE]@]\

JGQMBZ@CVUUPOHFU@TUPDL@JE4PNF1-":@450$,UP@TUSJOH\ QMBZ@CVUUPOTFU@TUPDL@JE1"64&@450$,

^FMTF\

QMBZ@CVUUPOTFU@TUPDL@JE1-":@450$,

^

^

Here's the error:

error[E0373]: closure may outlive the current function, but it borrows

`play_button`, which is owned by the current function

--> src/toolbar.rs:80:50

|

80 | self.toolbar.play_button.connect_clicked(|_| {

| ^^^ may outlive borrowed valuÃ¨play_button`

81 | if play_button.get_stock_id() ==

Some(PLAY_STOCK.to_string()) {

[ 164 ]





Creating a Music Player

Chapter 5

| ----------- `play_buttonÃ¬s borrowed here

|

help: to force the closure to take ownership of `play_button` (and any other referenced variables), use thÃ¨movÃ¨ keyword

|

80 | self.toolbar.play_button.connect_clicked(move |_| {

| ^^^^^^^^

The problem with this code is that the closure can (and will) be called after the function returns, but the variable button is declared in the method DPOOFDU@UPPMCBS@FWFOUT

and will be deallocated when it returns. Again, Rust prevents us from having a segmentation fault by checking if we correctly use references. The compiler talks about ownership; let's look at what that is.

Ownership

In Rust, there's no garbage collector to deallocate the memory when it's not needed anymore. Also, there's no need for the programmer to specify where the memory should be deallocated. But how can this work? The compiler is able to determine when to deallocate the memory thanks to the concept of ownership; only one variable can own a value. By this simple rule, the matter of when to deallocate the value is simple: when the owner goes out of scope, the value is deallocated.

Let's see an example of how deallocation is related to scope: MFUNVUWFDWFD<TUSJOHUP@TUSJOH>

JGWFDJT@FNQUZ\

MFUFMFNFOUWFDSFNPWF

FMFNFOUJTEFBMMPDBUFEBUUIFFOEPGUIJTTDPQF

^

Here, we remove an element from the vector in a new scopebthe block for the condition.

The variable FMFNFOU will own the value that was removed from the vector (we also say that the value was moved from the vector to the variable FMFNFOU). Since it owns the value, the variable is not responsible for deallocating it when it goes out of scope. Thus, after the condition, the value TUSJOH will be freed and cannot be accessed anymore.

[ 165 ]





Creating a Music Player

Chapter 5

Let's get back to our code:

TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGQMBZ@CVUUPOHFU@TUPDL@JE4PNF1-":@450$,UP@TUSJOH\ QMBZ@CVUUPOTFU@TUPDL@JE1"64&@450$,

^FMTF\

QMBZ@CVUUPOTFU@TUPDL@JE1-":@450$,

^

^

We added the keyword NPWF to closure to indicate that the value must be moved into the closure. (That's actually what the compiler told us to do, if you remember the error message.) By doing so, we satisfy the borrow checker because the value is not borrowed anymore. This was causing a lifetime error, but has now been moved into the closure and will thus live as long as the closure itself.

Don't forget to add the call to this method in the method "QQOFX, right after the call to DPOOFDU@FWFOUT:

BQQDPOOFDU@FWFOUT

BQQDPOOFDU@UPPMCBS@FWFOUT

Containers

We'll now add other widgets to our window: an image to show the cover of the song that is currently being played and a cursor to see the progression of the music. However, it is not possible to add multiple widgets to a window. To do so, we need to use containers.

Containers are a way to manage how multiple widgets will be shown.

Types of containers

Here are simple non-visual containers:

HUL#PY: disposes widgets either horizontally or vertically HUL(SJE: disposes widgets in rows and columns, like a table HUL'JYFE: displays widgets at a very specific position in pixels HUL4UBDL: displays only one widget at a time

All of these widgets, except HUL'JYFE , automatically rearrange the widgets when the window is resized. That's why you should avoid using this one.

[ 166 ]





Creating a Music Player

Chapter 5

Here are some more fancy containers:

HUL/PUFCPPL: displays only one widget at a time, but the user can select which one to show by clicking on a tab

HUL1BOFE: displays two widgets, separated by a handle that the user can drag to adjust the division between the widgets

The Box container

We'll use a HUL#PY to arrange our widgets. First of all, remove the call to 8JOEPXBEE that we added before:

XJOEPXBEEUPPMCBSUPPMCBS

We remove this call because we'll instead add the toolbar to the box and the box to the window. Let's do that, but before we do, we'll add a couple of new imports: VTFHUL\

"EKVTUNFOU

*NBHF

*NBHF&YU

4DBMF

4DBMF&YU

^

VTFHUL0SJFOUBUJPO\)PSJ[POUBM7FSUJDBM^

Then, we create the box:

MFUWCPYHUL#PYOFX7FSUJDBM

XJOEPXBEEWCPY

(This code goes into the "QQOFX method.)

Here, we fully qualified HUL#PY because #PY is a type from the standard library that is automatically imported. We specified that the orientation of the box is vertical and there's no spacing () between the children widgets of the container.

[ 167 ]



Creating a Music Player

Chapter 5

Now we're ready to add widgets to this box:

MFUUPPMCBS.VTJD5PPMCBSOFX

WCPYBEEUPPMCBSUPPMCBS

MFUDPWFS*NBHFOFX

DPWFSTFU@GSPN@GJMFDPWFSKQH

WCPYBEEDPWFS

We first add our toolbar, then add an image and load a cover from a static file because we haven't yet written the code to extract the cover from an MP3 file.

Let's also add the cursor widget:

MFUBEKVTUNFOU"EKVTUNFOUOFX

MFUTDBMF4DBMFOFX)PSJ[POUBMBEKVTUNFOU

TDBMFTFU@ESBX@WBMVFGBMTF

WCPYBEETDBMF

The cursor widget is named 4DBMF. This widget needs an "EKVTUNFOU, which is an object that represents which values the cursor can take, and also contains the current value and the increment values. Again, since we don't know how to fetch the duration of a song from an MP3 file, we hardcode values for "EKVTUNFOU. We also disable the feature to show the actual value of the cursor by calling TFU@ESBX@WBMVFGBMTF.

If you run the application, you'll see the following:

'JHVSF

(We can almost hear the music when looking at it.)

[ 168 ]





Creating a Music Player

Chapter 5

To conclude this section, we'll add a few fields to the "QQ structure so that it becomes: TUSVDU"QQ\

BEKVTUNFOU"EKVTUNFOU

DPWFS*NBHF

UPPMCBS.VTJD5PPMCBS

XJOEPX"QQMJDBUJPO8JOEPX

^

The end of the "QQ constructor is then updated to: JNQM"QQ\

GOOFXBQQMJDBUJPO"QQMJDBUJPO 4FMG\



XJOEPXTIPX@BMM

MFUBQQ"QQ\

BEKVTUNFOU

DPWFS

UPPMCBS

XJOEPX

^

BQQDPOOFDU@FWFOUT

BQQDPOOFDU@UPPMCBS@FWFOUT

BQQ

^

^

Adding a playlist

We're now ready to add the playlist widget to our music player.

We'll use new crates, so add the following to the NBJOST file: FYUFSODSBUFHEL@QJYCVG

FYUFSODSBUFJE

[ 169 ]

Creating a Music Player

Chapter 5

The crate HEL@QJYCVG will be used to show and manipulate the cover and the JE crate to get the metadata from MP3 files.

Also, add the following to $BSHPUPNM:

HELQJYCVG?

JE?

Next, we'll create a new module to contain this new widget: NPEQMBZMJTU

We'll start this module by adding a bunch of VTF statements: VTFTUEQBUI1BUI

VTFHEL@QJYCVG\*OUFSQ5ZQF1JYCVG1JYCVG-PBEFS^

VTFHUL\

$FMM-BZPVU&YU

$FMM3FOEFSFS1JYCVG

$FMM3FOEFSFS5FYU

-JTU4UPSF

-JTU4UPSF&YU

-JTU4UPSF&YU.BOVBM

4UBUJD5ZQF

5P7BMVF

5SFF*UFS

5SFF.PEFM&YU

5SFF4FMFDUJPO&YU

5SFF7JFX

5SFF7JFX$PMVNO

5SFF7JFX$PMVNO&YU

5SFF7JFX&YU

5ZQF

8JEHFU&YU

^

VTFJE5BH

These will be followed by some constants:

DPOTU5)6.#/"*-@$0-6./V

DPOTU5*5-&@$0-6./V

DPOTU"35*45@$0-6./V

DPOTU"-#6.@$0-6./V

DPOTU(&/3&@$0-6./V

DPOTU:&"3@$0-6./V

DPOTU53"$,@$0-6./V

DPOTU1"5)@$0-6./V

[ 170 ]





Creating a Music Player

Chapter 5

DPOTU1*9#6'@$0-6./V

DPOTU*."(&@4*;&J

DPOTU5)6.#/"*-@4*;&J

The @$0-6./ constant represents the column we'll show in the playlist. The last one, 1*9#6'@$0-6./, is a bit special: it will be a hidden column holding the cover of a bigger size so that we can show this image in the DPWFS widget we created earlier.

Next, we'll create a new structure to hold the widget and its model: QVCTUSVDU1MBZMJTU\

NPEFM-JTU4UPSF

USFFWJFX5SFF7JFX

^

The MVC pattern

For the list and tree widgets, GTK+ follows the MVC pattern. MVC stands for Model-View-Controller.

Now we can add a constructor for our playlist:

JNQM1MBZMJTU\

QVCGOOFX 4FMG\

MFUNPEFM-JTU4UPSFOFX<

1JYCVGTUBUJD@UZQF

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

1JYCVGTUBUJD@UZQF

>

MFUUSFFWJFX5SFF7JFXOFX@XJUI@NPEFMNPEFM

USFFWJFXTFU@IFYQBOEUSVF

USFFWJFXTFU@WFYQBOEUSVF

4FMGDSFBUF@DPMVNOTUSFFWJFX

1MBZMJTU\

NPEFM

USFFWJFX

[ 171 ]

Creating a Music Player

Chapter 5

^

^

^

The HUL-JTU4UPSF type is a model to represent the data as a list. Its constructor needs the types of the columns; in this case, most of the types are strings for the metadata of the MP3 files, such as the song title and author name. The first 1JYCVG is for the thumbnail image and the last one is for the bigger image only shown for the music currently playing.

Next, we create a 5SFF7JFX, which will actually be a view for a list since we initialize it with our list model. We then modify the widget so that it expands both vertically and horizontally, meaning that the widget will use as much space as possible. Finally, just before we return the TUSVDU1MBZMJTU, we call the DSFBUF@DPMVNOT method, which will create the columns to be shown in this view. Let's see this new method: GODSFBUF@DPMVNOTUSFFWJFX5SFF7JFX\

4FMGBEE@QJYCVG@DPMVNOUSFFWJFX5)6.#/"*-@$0-6./BTJ

7JTJCMF

4FMGBEE@UFYU@DPMVNOUSFFWJFX5JUMF5*5-&@$0-6./BTJ

4FMGBEE@UFYU@DPMVNOUSFFWJFX"SUJTU"35*45@$0-6./BTJ

4FMGBEE@UFYU@DPMVNOUSFFWJFX"MCVN"-#6.@$0-6./BTJ

4FMGBEE@UFYU@DPMVNOUSFFWJFX(FOSF(&/3&@$0-6./BTJ

4FMGBEE@UFYU@DPMVNOUSFFWJFX:FBS:&"3@$0-6./BTJ

4FMGBEE@UFYU@DPMVNOUSFFWJFX5SBDL53"$,@$0-6./BTJ

4FMGBEE@QJYCVG@DPMVNOUSFFWJFX1*9#6'@$0-6./BTJ*OWJTJCMF

^

Here, we call two methods to create the different types of columnsbwe specify the header label and the column number of every column. As for the last parameter of the BEE@QJYCVG@DPMVNO method, it indicates whether the column is visible or not. This parameter is of a custom type, so let's declare it: VTFTFMG7JTJCJMJUZ

<EFSJWF1BSUJBM&R>

FOVN7JTJCJMJUZ\

*OWJTJCMF

7JTJCMF

^

We also added a VTF statement to be able to directly use 7JTJCMF instead of having to fully qualify it (7JTJCJMJUZ7JTJCMF).

[ 172 ]

Creating a Music Player

Chapter 5

Let's write the BEE@UFYU@DPMVNO method:

GOBEE@UFYU@DPMVNOUSFFWJFX5SFF7JFXUJUMFTUSDPMVNOJ\

MFUWJFX@DPMVNO5SFF7JFX$PMVNOOFX

WJFX@DPMVNOTFU@UJUMFUJUMF

MFUDFMM$FMM3FOEFSFS5FYUOFX

WJFX@DPMVNOTFU@FYQBOEUSVF

WJFX@DPMVNOQBDL@TUBSUDFMMUSVF

WJFX@DPMVNOBEE@BUUSJCVUFDFMMUFYUDPMVNO

USFFWJFXBQQFOE@DPMVNOWJFX@DPMVNO

^

We start by creating the column itself and setting the label of the header by calling TFU@UJUMF. Then, we create a $FMM3FOEFSFS, which indicates how the data from the model should be rendered in the view; here, we only want to show some text, so we chose $FMM3FOEFSFS5FYU, we set it to take up as much space as possible, and added the renderer to the column. Next comes a very important line:

WJFX@DPMVNOBEE@BUUSJCVUFDFMMUFYUDPMVNO

This line specifies that the view will set the UFYU attribute from the data that comes from the model at the specified column.

At the end, we add the column to the view.

Now we'll write a similar function for the QJYCVG: GOBEE@QJYCVG@DPMVNOUSFFWJFX5SFF7JFXDPMVNOJWJTJCJMJUZ

7JTJCJMJUZ\

MFUWJFX@DPMVNO5SFF7JFX$PMVNOOFX

JGWJTJCJMJUZ7JTJCMF\

MFUDFMM$FMM3FOEFSFS1JYCVGOFX

WJFX@DPMVNOQBDL@TUBSUDFMMUSVF

WJFX@DPMVNOBEE@BUUSJCVUFDFMMQJYCVGDPMVNO

^

USFFWJFXBQQFOE@DPMVNOWJFX@DPMVNO

^

[ 173 ]

Creating a Music Player

Chapter 5

Here, we create a new type of renderer ($FMM3FOEFSFS1JYCVG), which will show an image instead of text. This time, we set the QJYCVG attribute because we want to show an image.

The renderer is only created if the column is visible.

Now, all that's left is to write a function to get the actual widget to be able to add the widget in the NBJO module:

QVCGOWJFXTFMG 5SFF7JFX\

TFMGUSFFWJFX

^

Let's go back to the method "QQOFX and create the playlist: MFUQMBZMJTU1MBZMJTUOFX

WCPYBEEQMBZMJTUWJFX

(Add this code right before creating the *NBHF.)

We'll also add a QMBZMJTU attribute in the structure: TUSVDU"QQ\

BEKVTUNFOU"EKVTUNFOU

DPWFS*NBHF

QMBZMJTU1MBZMJTU

UPPMCBS.VTJD5PPMCBS

XJOEPX8JOEPX

^

Also, don't forget to edit the creation of the structure to include the following new field: MFUBQQ"QQ\

BEKVTUNFOU

DPWFS

QMBZMJTU

UPPMCBS

XJOEPX

^

[ 174 ]





Creating a Music Player

Chapter 5

We're now ready to launch our application again to see an empty playlist:

'JHVSF

Opening MP3 files

Let's finish this chapter by adding the ability to open MP3 files and show their metadata in the playlist widget we just created.

First of all, we'll remove this line:

DPWFSTFU@GSPN@GJMFDPWFSKQH

This is because the image will be set from the data of the MP3 files we play.

We'll use a new crate, so add this line in the <EFQFOEFODJFT> section of your $BSHPUPNM: HULTZT?

Also, add the following line to your NBJOST:

FYUFSODSBUFHUL@TZT

The TZT crates of the HULST ecosystem are low-level crates, the ones that directly bind to the GTK+ C library. Since they're very low-level and require the use of unsafe code, wrappers have been made; these are crates without the TZT suffix, such as HUL and HEL.

[ 175 ]





Creating a Music Player

Chapter 5

Reference-counting pointer

We'll also change some code before we continue. Since we'll want to share our 1MBZMJTU

widget with different parts of our code, including some event handlers, we need a way of sharing a reference that will last long enough (remember the issue we had with the lifetime). One easy way of doing so is to use a reference-counting pointer typeb3D. So, in our "QQ structure, let's change the QMBZMJTU field to use an 3D: TUSVDU"QQ\

BEKVTUNFOU"EKVTUNFOU

DPWFS*NBHF

QMBZMJTU3D1MBZMJTU

UPPMCBS.VTJD5PPMCBS

XJOEPX8JOEPX

^

This requires a new import at the top of the NBJO module: VTFTUESD3D

Also, the creation of the playlist needs to be updated: MFUQMBZMJTU3DOFX1MBZMJTUOFX

We now wrap the 1BZMJTU inside an 3D. We can still use the playlist like before, as long as we're calling immutable methods, that is, methods that take TFMG but not NVUTFMG. So, the next line is still valid:

WCPYBEEQMBZMJTUWJFX

Before we create the method to add an MP3 file to the playlist, we'll need another method to set the QJYCVG values in the model from the MP3 metadata. In the JNQM1MBZMJTU, add the following method:

DPOTU*/5&31@):1&3*OUFSQ5ZQF

GOTFU@QJYCVGTFMGSPX5SFF*UFSUBH5BH\

JGMFU4PNFQJDUVSFUBHQJDUVSFTOFYU\

MFUQJYCVG@MPBEFS1JYCVG-PBEFSOFX

QJYCVG@MPBEFSTFU@TJ[F*."(&@4*;&*."(&@4*;& QJYCVG@MPBEFSMPBEFS@XSJUFQJDUVSFEBUBVOXSBQ

JGMFU4PNFQJYCVGQJYCVG@MPBEFSHFU@QJYCVG\

MFUUIVNCOBJMQJYCVGTDBMF@TJNQMF5)6.#/"*-@4*;& 5)6.#/"*-@4*;&*/5&31@):1&3VOXSBQ

TFMGNPEFMTFU@WBMVFSPX5)6.#/"*-@$0-6./

UIVNCOBJMUP@WBMVF

[ 176 ]





Creating a Music Player

Chapter 5

TFMGNPEFMTFU@WBMVFSPX1*9#6'@$0-6./

QJYCVGUP@WBMVF

^

QJYCVG@MPBEFSDMPTFVOXSBQ

^

^

The type 5BH represents the metadata of an MP3 file. We get the first picture contained in the file and we load it. If the loading was successful, we resize it to get a thumbnail and then we set the values in the model.

ID3d MP3 metadata

We're now ready to get all the relevant metadata from the MP3 files and add them to the playlist. Let's start the 1MBZMJTUBEE method by fetching the metadata: QVCGOBEETFMGQBUI1BUI\

MFUGJMFOBNF

QBUIGJMF@TUFNVOXSBQ@PS@EFGBVMUUP@TUSVOXSBQ@PS@EFGBVMU

MFUSPXTFMGNPEFMBQQFOE

JGMFU0LUBH5BHSFBE@GSPN@QBUIQBUI\

MFUUJUMFUBHUJUMFVOXSBQ@PSGJMFOBNF

MFUBSUJTUUBHBSUJTUVOXSBQ@PSOPBSUJTU

MFUBMCVNUBHBMCVNVOXSBQ@PSOPBMCVN

MFUHFOSFUBHHFOSFVOXSBQ@PSOPHFOSF

MFUZFBSUBHZFBSNBQ]ZFBS]

ZFBSUP@TUSJOHVOXSBQ@PSOP

ZFBSUP@TUSJOH

MFUUSBDLUBHUSBDLNBQ]USBDL]

USBDLUP@TUSJOHVOXSBQ@PSUP@TUSJOH

MFUUPUBM@USBDLTUBHUPUBM@USBDLTNBQ]UPUBM@USBDLT]

UPUBM@USBDLTUP@TUSJOHVOXSBQ@PSUP@TUSJOH

MFUUSBDL@WBMVFGPSNBU\^\^USBDLUPUBM@USBDLT

We first get the filename without the extension and convert it to a string; we'll show this if there's no song title in the file. Then, we read the metadata from the file and assign a default value such as OPBSUJTU in case a value is missing by calling VOXSBQ@PS, which gets the value from 0QUJPO if or returns the argument if the value is /POF.

[ 177 ]





Creating a Music Player

Chapter 5

Now let's see the rest of the method:

TFMGTFU@QJYCVGSPXUBH

TFMGNPEFMTFU@WBMVFSPX5*5-&@$0-6./UJUMFUP@WBMVF

TFMGNPEFMTFU@WBMVFSPX"35*45@$0-6./BSUJTUUP@WBMVF

TFMGNPEFMTFU@WBMVFSPX"-#6.@$0-6./BMCVNUP@WBMVF

TFMGNPEFMTFU@WBMVFSPX(&/3&@$0-6./HFOSFUP@WBMVF

TFMGNPEFMTFU@WBMVFSPX:&"3@$0-6./ZFBSUP@WBMVF

TFMGNPEFMTFU@WBMVFSPX53"$,@$0-6./

USBDL@WBMVFUP@WBMVF

^

FMTF\

TFMGNPEFMTFU@WBMVFSPX5*5-&@$0-6./GJMFOBNFUP@WBMVF

^

MFUQBUIQBUIUP@TUSVOXSBQ@PS@EFGBVMU

TFMGNPEFMTFU@WBMVFSPX1"5)@$0-6./QBUIUP@WBMVF

^

Here, we create a new row in the model and call the TFU@QJYCVG we created just before.

After that, we set the value in the new row. One special value is the path, which will be useful later when we want to play the selected song from the playlist; we'll only need to fetch the path and then play it.

Opening files with a file dialog

There's another function we'll need before we can handle the click event of the open button.

We need a function that'll show a file dialog to allow the user to select a file: VTFTUEQBUI1BUI#VG

VTFHUL\'JMF$IPPTFS"DUJPO'JMF$IPPTFS%JBMPH'JMF'JMUFS^

GOTIPX@PQFO@EJBMPHQBSFOU"QQMJDBUJPO8JOEPX 0QUJPO1BUI#VG

\

MFUNVUGJMF/POF

MFUEJBMPH'JMF$IPPTFS%JBMPHOFX4PNF4FMFDUBO.1BVEJP

GJMF

4PNFQBSFOU'JMF$IPPTFS"DUJPO0QFO

MFUGJMUFS'JMF'JMUFSOFX

GJMUFSBEE@NJNF@UZQFBVEJPNQ

GJMUFSTFU@OBNF.1BVEJPGJMF

EJBMPHBEE@GJMUFSGJMUFS

EJBMPHBEE@CVUUPO$BODFM3&410/4&@$"/$&-

[ 178 ]

Creating a Music Player

Chapter 5

EJBMPHBEE@CVUUPO"DDFQU3&410/4&@"$$&15

MFUSFTVMUEJBMPHSVO

JGSFTVMU3&410/4&@"$$&15\

GJMFEJBMPHHFU@GJMFOBNF

^

EJBMPHEFTUSPZ

GJMF

^

This function starts by creating a new file dialog of the type PQFO. Afterwards, it adds a filter to this dialog so that it only shows MP3 files. Then, we add two buttons using some constants that we'll define later. At the moment, we can show the dialog by calling SVO; this function blocks until the dialog is closed and returns which button was clicked. After that, we check whether the accept button was clicked to save the filename that was selected by the user and we return that filename.

Here are the constants needed by the previous function: VTFHUL@TZT\(5,@3&410/4&@"$$&15(5,@3&410/4&@$"/$&-^

DPOTU3&410/4&@"$$&15J(5,@3&410/4&@"$$&15BTJ

DPOTU3&410/4&@$"/$&-J(5,@3&410/4&@$"/$&-BTJ

We're now ready to handle the click event of the open button. Add the following in the method "QQDPOOFDU@UPPMCBS@FWFOUT:

MFUQBSFOUTFMGXJOEPXDMPOF

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

TFMGUPPMCBSPQFO@CVUUPODPOOFDU@DMJDLFENPWF]@]\

MFUGJMFTIPX@PQFO@EJBMPHQBSFOU

JGMFU4PNFGJMFGJMF\

QMBZMJTUBEEGJMF

^

^

In the event handler, we call the function we just defined and, if a file was selected, we call the BEE method of the playlist.

[ 179 ]





Creating a Music Player

Chapter 5

You can now try the application and open an MP3 file. Here's what you'll see:

'JHVSF

Let's add two more features before we end this chapter. The first one is to remove a song from the playlist.

Deleting a song

We need to add a method to the 1MBZMJTU struct to remove the selected item: QVCGOSFNPWF@TFMFDUJPOTFMG\

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

TFMGNPEFMSFNPWFJUFS

^

^

This first starts by getting the selection and, if there was one, we remove it from the model.

We can now add an event handler for the remove button in the

"QQDPOOFDU@UPPMCBS@FWFOUT method:

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

TFMGUPPMCBSSFNPWF@CVUUPODPOOFDU@DMJDLFENPWF]@]\

QMBZMJTUSFNPWF@TFMFDUJPO

^

There's nothing new in this code; we simply clone the reference-counted playlist and call a method on it when the button is clicked.

[ 180 ]





Creating a Music Player

Chapter 5

Displaying the cover when playing a song

The other feature to add is to show a bigger cover when we click the play button. We'll start by adding a function to get the image from the selection in the playlist: QVCGOQJYCVGTFMG 0QUJPO1JYCVG \

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

MFUWBMVFTFMGNPEFMHFU@WBMVFJUFS1*9#6'@$0-6./BTJ

SFUVSOWBMVFHFU1JYCVG

^

/POF

^

This method to be added to the 1MBZMJTU structure starts by getting the selection; if there's one, it simply gets the QJYCVG from the model and returns it. Otherwise, it returns /POF.

We can now write a function that will fetch the cover from the playlist and show the image: VTFHUL*NBHF

VTFQMBZMJTU1MBZMJTU

GOTFU@DPWFSDPWFS*NBHFQMBZMJTU1MBZMJTU\

DPWFSTFU@GSPN@QJYCVGQMBZMJTUQJYCVGBT@SFG

DPWFSTIPX

^

Add this function in the UPPMCBS module. And, finally, we can call this function from the click event handler of the play button:

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUDPWFSTFMGDPWFSDMPOF

TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGQMBZ@CVUUPOHFU@TUPDL@JE4PNF1-":@450$,UP@TUSJOH\ QMBZ@CVUUPOTFU@TUPDL@JE1"64&@450$,

TFU@DPWFSDPWFSQMBZMJTU

^FMTF\

QMBZ@CVUUPOTFU@TUPDL@JE1-":@450$,

^

^

[ 181 ]





Creating a Music Player

Chapter 5

Here's the result after adding a song and clicking play:

'JHVSF

Summary

This chapter started by showing you how to install GTK+ on your machine. You then learned how to use HULST to create windows, to manage user events like mouse click, to add different types of widgets to your window, to arrange your widgets with containers, and to show beautiful icons with stock items. You also saw how to use complex GTK+

widgets that use the MVC pattern.

You also gained more knowledge of Rust in the areas of closures, lifetimes, and ownerships, which are key concepts in this language.

Finally, you learned how to extract the metadata of an MP3 file by getting the ID3 tags.

In the next chapter, we'll improve the music player so that it can actually play a song.

[ 182 ]





6

Implementing the Engine of the

Music Player

In the previous chapter, we implemented the user interface of the music player, but it is unable to play any music. We'll tackle that challenge in this chapter. We'll create the engine of the music player so that it can play MP3 files. To do this, we'll need to use threads so that playing a song does not freeze the interface, so it will be a good opportunity to learn about concurrency in Rust.

We will cover the following topics in this chapter: MP3 decoder

Threads

Mutex and Mutex guards

Send/Sync traits

RAII

Thread safety

Interior mutability





Implementing the Engine of the Music Player Chapter 6

Installing the dependencies

For this chapter, we'll need two libraries: QVMTFBVEJP and MJCNBE.

The former will be used to play the music, while the latter is for decoding MP3 files.

Installing dependencies on Linux

On Linux, these dependencies can be installed through the package manager of your distribution.

On Ubuntu (or other Debian derivatives):

sudo apt-get install libmad0-dev libpulse-dev

Installing dependencies on Mac

On OSX, the required dependencies can be installed through the system package manager, as follows:

brew install libmad pulseaudio

Installing dependencies on Windows

On Windows, run the following command in a MSYS2 shell: pacman -S mingw-w64-libmad

Think, click the link to download the zip file from this page: IUUQTXXXGSFFEFTLUPQ

PSHXJLJ4PGUXBSF1VMTF"VEJP1PSUT8JOEPXT4VQQPSU (When the book was written, the link for the current version was IUUQCPTNBOTDIQVMTFBVEJPQVMTFBVEJP[JQ).

Then, follow the same instructions as the ones from $IBQUFS, Starting with SDL, to use the library from Rust.

[ 184 ]





Implementing the Engine of the Music Player Chapter 6

Decoding MP3 files

We'll start this chapter by learning how to decode an MP3 file to a format suitable to be played by the operating system using the TJNQMFNBE crate, a binding for MJCNBE.

Adding dependencies

Let's add the following to $BSHPUPNM:

DSPTTCFBN?

QVMTFTJNQMF?

TJNQMFNBE?

We also added the QVMTFTJNQMF and DSPTTCFBN crates because we'll need them later.

The former will be used to play the songs with QVMTFBVEJP and the latter will be used to implement the event loop of the music player engine.

We also need to add the following statements in NBJOST: FYUFSODSBUFDSPTTCFBN

FYUFSODSBUFQVMTF@TJNQMF

FYUFSODSBUFTJNQMFNBE

NPENQ

In addition to the FYUFSODSBUF statements, we have a NPE statement since we'll create a new module for the MP3 decoder.

Implementing an MP3 decoder

We're now ready to create this new module. Create a new NQST file with the following content:

VTFTUEJP\3FBE4FFL4FFL'SPN^

VTFTUEUJNF%VSBUJPO

VTFTJNQMFNBE

[ 185 ]

Implementing the Engine of the Music Player Chapter 6

We start this module with some import statements as usual. The important one is TJNQMFNBE, which will be used to decode the frames of an MP3 file: QVCTUSVDU.Q%FDPEFS3 XIFSF33FBE\

SFBEFSTJNQMFNBE%FDPEFS3

DVSSFOU@GSBNFTJNQMFNBE'SBNF

DVSSFOU@GSBNF@DIBOOFMVTJ[F

DVSSFOU@GSBNF@TBNQMF@QPTVTJ[F

DVSSFOU@UJNFV

^

We saw in $IBQUFS, Basics of Rust, that we can add trait bounds to generic parameters in a function. We can also add them to the generic parameters of a type. Here we see an alternative syntax using a XIFSF clause. The previous structure declaration is the same as the following:

QVCTUSVDU.Q%FDPEFS33FBE \

d

^

The XIFSF clause is useful when we have a lot a generic parameters.

This structure contains information about the current frame and time as well as the decoder itself, which comes from the TJNQMFNBE crate. This %FDPEFS also requires a generic parameter that implements the 3FBE trait, so we just use our own 3 parameter since we specified that it must implement this trait.

Before we move on to the constructor of this type, we'll implement a couple of VUJMJUZ

functions. Let's start with a function that converts %VSBUJPO to a number of milliseconds (this function will go in the NBJOST file since we'll use it in another module): GOUP@NJMMJTEVSBUJPO%VSBUJPO V\

EVSBUJPOBT@TFDTEVSBUJPOTVCTFD@OBOPTBTV

@@

^

Here, we simply multiply the number of seconds by and divide the number of nanoseconds by . This function requires you to add an import statement for

%VSBUJPO:

VTFTUEUJNF%VSBUJPO

[ 186 ]

Implementing the Engine of the Music Player Chapter 6

Next, we'll write a function to check whether a stream of data is an MP3 file: GOJT@NQ3 NVUEBUB3 CPPMXIFSF33FBE4FFL\

MFUTUSFBN@QPTEBUBTFFL4FFL'SPN$VSSFOUVOXSBQ

MFUJT@NQTJNQMFNBE%FDPEFSEFDPEFEBUBCZ@SFGJT@PL

EBUBTFFL4FFL'SPN4UBSUTUSFBN@QPTVOXSBQ

JT@NQ

^

To do so, we try to decode the stream and if the result is 0L, then the data is an MP3 file. We then go back to the beginning of the file before returning whether it is an MP3 file or not.

The next function we'll need is one to decode the next frame of an MP3 file: GOOFYU@GSBNF33FBE EFDPEFSNVUTJNQMFNBE%FDPEFS3

TJNQMFNBE'SBNF\

EFDPEFSGJMUFS@NBQ]G]GPLOFYU

VOXSBQ@PS@FMTF]]\

TJNQMFNBE'SBNF\

CJU@SBUF

MBZFS%FGBVMUEFGBVMU

NPEF%FGBVMUEFGBVMU

TBNQMF@SBUF

TBNQMFTWFD<7FDOFX>

QPTJUJPO%VSBUJPOGSPN@TFDT

EVSBUJPO%VSBUJPOGSPN@TFDT

^

^

^

Here, we simply get the next frame from the decoder and flatten the 0QUJPO3FTVMU'SBNF to 0QUJPO'SBNF by calling BOE@UIFO3FTVMUPL. If there's no frame, we return a default frame.

Now, let's implement the constructor of our MP3 decoder: JNQM3 .Q%FDPEFS3 XIFSF33FBE4FFL\

QVCGOOFXNVUEBUB3 3FTVMU.Q%FDPEFS3 3 \

JGJT@NQEBUBCZ@SFG\

SFUVSO&SSEBUB

^

MFUNVUSFBEFSTJNQMFNBE%FDPEFSEFDPEFEBUBVOXSBQ

MFUDVSSFOU@GSBNFOFYU@GSBNFNVUSFBEFS

MFUDVSSFOU@UJNFUP@NJMMJTDVSSFOU@GSBNFEVSBUJPO

[ 187 ]

Implementing the Engine of the Music Player Chapter 6

0L.Q%FDPEFS\

SFBEFS

DVSSFOU@GSBNF

DVSSFOU@GSBNF@DIBOOFM

DVSSFOU@GSBNF@TBNQMF@QPT

DVSSFOU@UJNF

^

^

^

You need to add an import statement at the top of this file to be able to use the UP@NJMMJT

function, which is in the NBJO module:

VTFUP@NJMMJT

Since the VTF statements are relative to the root of the crate, we only need to write the function name because this function is at the crate's root.

The constructor first checks whether the stream contains MP3 data, if not, we return an error. Otherwise, we create a %FDPEFS from the TJNQMFNBE crate. Then, we read the first frame and get its time in milliseconds.

Next, we write two methods to get the current time and the rate of the MP3 file: QVCGODVSSFOU@UJNFTFMG V\

TFMGDVSSFOU@UJNF

^

QVCGOTBNQMFT@SBUFTFMG V\

TFMGDVSSFOU@GSBNFTBNQMF@SBUF

^

These methods are to be added in the JNQM.Q%FDPEFS block. The last method to be added to this structure is a method to compute the duration of a song: QVCGODPNQVUF@EVSBUJPONVUEBUB3 0QUJPO%VSBUJPO \

JGJT@NQEBUBCZ@SFG\

SFUVSO/POF

^

MFUEFDPEFSTJNQMFNBE%FDPEFSEFDPEF@IFBEFSTEBUBVOXSBQ

4PNFEFDPEFSGJMUFS@NBQ]GSBNF]\

NBUDIGSBNF\

0LGSBNF 4PNFGSBNFEVSBUJPO

&SS@ /POF

^

^

[ 188 ]





Implementing the Engine of the Music Player Chapter 6

TVN

^

Here we create an associated function: it first checks whether it is MP3 data. Here, instead of using %FDPEFSEFDPEF, we use %FDPEFSEFDPEF@IFBEFST because we only need the frame duration and it is faster to only decode the headers. The EFDPEFS is an iterator and we call GJMUFS@NBQ on it. As you saw in $IBQUFS, Starting with SDL, GJMUFS@NBQ transforms and filters the elements of an iterator. Transforming a value is done by returning 4PNFOFX@WBMVF, while filtering out a value is done by returning

/POF. After that, we call TVN on the resulting iterator to get the sum of all the durations.

Getting the frame samples

The only remaining feature needed for our MP3 decoder is to be able to iterate over the samples. We'll first write a function to get the next sample: GOOFYU@TBNQMF33FBE EFDPEFSNVU.Q%FDPEFS3 0QUJPOJ

\

JGEFDPEFSDVSSFOU@GSBNFTBNQMFT<>MFO\

SFUVSO/POF

^

HFUUJOHUIFTBNQMFBOEDPOWFSUJOHJUGSPNGJYFETUFQUPJ

MFUTBNQMF

EFDPEFSDVSSFOU@GSBNFTBNQMFT<EFDPEFSDVSSFOU@GSBNF@DIBOOFM>

<EFDPEFSDVSSFOU@GSBNF@TBNQMF@QPT>

MFUTBNQMFTBNQMFUP@J

MFUTBNQMFJGTBNQMF Y\Y^FMTFJG

TBNQMF

Y\Y^FMTF\TBNQMF^

MFUTBNQMFTBNQMF

MFUTBNQMFTBNQMFBTJ

EFDPEFSDVSSFOU@GSBNF@DIBOOFM

JGEFDPEFSDVSSFOU@GSBNF@DIBOOFM

EFDPEFSDVSSFOU@GSBNFTBNQMFTMFO\

SFUVSO4PNFTBNQMF

^

EFDPEFSDVSSFOU@GSBNF@DIBOOFM

EFDPEFSDVSSFOU@GSBNF@TBNQMF@QPT

JGEFDPEFSDVSSFOU@GSBNF@TBNQMF@QPT

[ 189 ]





Implementing the Engine of the Music Player Chapter 6

EFDPEFSDVSSFOU@GSBNFTBNQMFT<>MFO\

SFUVSO4PNFTBNQMF

^

EFDPEFSDVSSFOU@GSBNFOFYU@GSBNFNVUEFDPEFSSFBEFS

EFDPEFSDVSSFOU@GSBNF@DIBOOFM

EFDPEFSDVSSFOU@GSBNF@TBNQMF@QPT

EFDPEFSDVSSFOU@UJNF

UP@NJMMJTEFDPEFSDVSSFOU@GSBNFEVSBUJPO

SFUVSO4PNFTBNQMF

^

This function is doing some bit shifting to get the sample and then fetch the next frame.

We're now ready to implement an iterator that will use this function: JNQM3 *UFSBUPSGPS.Q%FDPEFS3 XIFSF33FBE\

UZQF*UFNJ

GOOFYUNVUTFMG 0QUJPOJ \

OFYU@TBNQMFTFMG

^

GOTJ[F@IJOUTFMG VTJ[F0QUJPOVTJ[F \

TFMGDVSSFOU@GSBNFTBNQMFT<>MFO/POF

^

^

As you can see, we can implement our own iterator by implementing the *UFSBUPS trait.

The only required method is OFYU. By implementing this simple method, we get a whole bunch of features because this trait has a lot of default methods. The UZQF*UFN is also required. We implement the TJ[F@IJOU method, even though it is an optional one.

Playing music

With the MP3 decoder done, we're now ready to play some music. We'll create a new module, called player, which we will add at the top of NBJOST: NPEQMBZFS

[ 190 ]





Implementing the Engine of the Music Player Chapter 6

We'll start this module by creating a new QMBZFSST file with the following import statements:

VTFTUEGT'JMF

VTFTUEJP#VG3FBEFS

VTFTUEQBUI\1BUI1BUI#VG^

VTFTUETZOD\"SD$POEWBS.VUFY^

VTFTUEUISFBE

VTFDSPTTCFBNTZOD4FH2VFVF

VTFQVMTF@TJNQMF1MBZCBDL

VTFNQ.Q%FDPEFS

VTFTFMG"DUJPO

We'll also create some constants:

DPOTU#6''&3@4*;&VTJ[F

DPOTU%&'"6-5@3"5&V

The buffer size is the number of samples we'll decode and play to avoid having slowdowns when playing the song and also to avoid using 100% of the CPU by constantly reading and decoding the data at the same time as playing. The default rate will be used when we cannot find one in the MP3 file.

Event loop

To simplify the development of our playing engine, we'll use the concept of an event loop.

Some actions will be sent to the thread playing the music through this event loop. For instance, we will be able to emit a -PBEGJMFNQ event, the thread will decode this MP3 file, and start playing it. Another example of an event is 4UPQ, which will stop playing and unload the data.

Let's create an enumeration for the possible actions: FOVN"DUJPO\

-PBE1BUI#VG

4UPQ

^

[ 191 ]





Implementing the Engine of the Music Player Chapter 6

We're now ready to create the structure of the event loop:

<EFSJWF$MPOF>

TUSVDU&WFOU-PPQ\

RVFVF"SD4FH2VFVF"DUJPO

QMBZJOH"SD.VUFYCPPM

^

There's a lot of unknown stuff in this structure, so let's break it down.

Atomic reference counting

First of all, we use the "SD type. It is similar to the 3D type that we used in the previous chapter, in that it is a type providing reference counting. The difference between these two types is that "SD uses atomic operations to increment its counter. By being atomic, it is safe to be used by multiple threads while 3D cannot be safely used across threads (and the compiler prevents us from trying to do so). The standard library provides these two types so that you can choose the cost you want to pay. If you don't need to share a reference-counted value with multiple threads, choose 3D as it is more efficient than "SD. If you try to send an 3D to another thread, the compiler will trigger an error: error[E0277]: the trait bound `std::rc::Rc<i32>: std::marker::SendÃ¬s not satisfied in `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc<i32>]`

--> src/main.rs:6:5

|

6 | thread::spawn(move || {

| ^^^^^^^^^^^^^ `std::rc::Rc<i32>` cannot be sent between threads safely

|

= help: within `[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc<i32>]`, the trait `std::marker::SendÃ¬s not implemented for `std::rc::Rc<i32>`

= note: required because it appears within the type

`[closure@src/main.rs:6:19: 8:6 rc:std::rc::Rc<i32>]`

= note: required by `std::thread::spawn`

In this case, you'll need to switch to an "SD. This error will make more sense when we see what the 4FOE trait is.

[ 192 ]





Implementing the Engine of the Music Player Chapter 6

Mutual exclusion

In the QMBZJOH field, the "SD contains a .VUFY. A mutex provides mutual exclusion, meaning that it allows us to lock its inner value (in this case, a CPPM) preventing other threads from manipulating the same value at the same time. It prevents data races, which is a cause of undefined behavior, by preventing concurrent reads and writes on a value.

Send trait

But how can the compiler prevent us from doing data races? This is thanks to the 4FOE and 4ZOD marker traits. A type that implements the 4FOE trait is safe to be sent to another thread. As you may have guessed, 3D does not implement 4FOE. Since it does not use atomic operations to increment its counter, if two threads were to increment it at the same time, that would be a data race.

Sync trait

Let's discuss the second of these marker traits: 4ZOD. A type that implements the 4ZOD trait is safe to be shared with multiple threads. An example of a 4ZOD type is .VUFY. It is safe because the only way to get a value from .VUFY is to lock it, which is mutually exclusive (another thread cannot access the same value at the same time).

Lock-free data structures

The only remaining type to explain is 4FH2VFVF, from the DSPTTCFBN crate. This type is a lock-free queue, meaning that it can be used concurrently by multiple threads without a lock. The implementation of lock-free data structures is beyond the scope of this book, but it suffices to say that it uses atomic operations behind the scenes so that we don't need to use a .VUFY to mutate this value in mutable threads at the same time. We still need to wrap this queue in an "SD to be able to share it with multiple threads.

We're using a lock-free data structure because we'll be constantly checking whether there's a new element in this queue while possibly adding new elements to this queue from another thread. If we were to use .VUFY7FD%FRVF"DUJPO , it would be less efficient because calling MPDL on .VUFY waits if the lock is held by another thread.

[ 193 ]

Implementing the Engine of the Music Player Chapter 6

Let's get back to our event loop. Let's add a constructor for &WFOU-PPQ: JNQM&WFOU-PPQ\

GOOFX 4FMG\

&WFOU-PPQ\

RVFVF"SDOFX4FH2VFVFOFX

QMBZJOH"SDOFX.VUFYOFXGBMTF

^

^

^

This constructor simply creates the queue and the Boolean wrapped in a .VUFY.

Before we use it, we'll create a 4UBUF structure that will contain various data shared between the GUI thread and the music player thread, put this code in the NBJO module: TUSVDU4UBUF\

TUPQQFECPPM

^

Also, add a TUBUF field in the "QQ structure: TUSVDU"QQ\

BEKVTUNFOU"EKVTUNFOU

DPWFS*NBHF

QMBZMJTU3D1MBZMJTU

TUBUF"SD.VUFY4UBUF

UPPMCBS.VTJD5PPMCBS

XJOEPX8JOEPX

^

This requires a new import statement:

VTFTUETZOD\"SD.VUFY^

Since this value will be shared with another thread, we need to wrap it in "SD.VUFY .

Then, in the constructor, create this value and assign it to this new field, while also sending it to the 1MBZMJTU constructor:

JNQM"QQ\

GOOFX 4FMG\

d

MFUTUBUF"SDOFX.VUFYOFX4UBUF\

TUPQQFEUSVF

^

[ 194 ]

Implementing the Engine of the Music Player Chapter 6

MFUQMBZMJTU3DOFX1MBZMJTUOFXTUBUFDMPOF

d

MFUBQQ"QQ\

BEKVTUNFOU

DPWFS

QMBZMJTU

TUBUF

UPPMCBS

XJOEPX

^

d

^

^

Let's update the 1MBZMJTU constructor:

JNQM1MBZMJTU\

QVCDSBUFGOOFXTUBUF"SD.VUFY4UBUF 4FMG\

MFUNPEFM-JTU4UPSFOFX<

1JYCVGTUBUJD@UZQF

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

1JYCVGTUBUJD@UZQF

>

MFUUSFFWJFX5SFF7JFXOFX@XJUI@NPEFMNPEFM

USFFWJFXTFU@IFYQBOEUSVF

USFFWJFXTFU@WFYQBOEUSVF

4FMGDSFBUF@DPMVNOTUSFFWJFX

1MBZMJTU\

NPEFM

QMBZFS1MBZFSOFXTUBUFDMPOF

USFFWJFX

^

^

^

[ 195 ]





Implementing the Engine of the Music Player Chapter 6

The structure requires a new field, so let's add it: QVCTUSVDU1MBZMJTU\

NPEFM-JTU4UPSF

QMBZFS1MBZFS

USFFWJFX5SFF7JFX

^

This also needs new import statements:

VTFTUETZOD\"SD.VUFY^

VTF4UBUF

VTFQMBZFS1MBZFS

We use the QVCDSBUF syntax to silent an error. Since we're using a private type (4UBUF) in a public method, the compiler throws an error. This syntax means that the function is public to the other modules of the crate, but other crates cannot access it. Here, we only send the TUBUF to the 1MBZFS constructor, which we will implement right away.

Playing music

We'll create a new 1MBZFS structure to wrap the event loop. The player will be usable from the main thread to control the music. Here's the structure itself: QVCTUSVDU1MBZFS\

BQQ@TUBUF"SD.VUFYTVQFS4UBUF

FWFOU@MPPQ&WFOU-PPQ

^

And here's the start of its constructor:

JNQM1MBZFS\

QVCDSBUFGOOFXBQQ@TUBUF"SD.VUFYTVQFS4UBUF 4FMG

\

MFUFWFOU@MPPQ&WFOU-PPQOFX

\

MFUBQQ@TUBUFBQQ@TUBUFDMPOF

MFUFWFOU@MPPQFWFOU@MPPQDMPOF

UISFBETQBXONPWF]]\

d

^

^

[ 196 ]

Implementing the Engine of the Music Player Chapter 6

1MBZFS\

BQQ@TUBUF

FWFOU@MPPQ

^

^

^

We start by creating a new event loop. Then, we start a new thread. We used a new scope to avoid having to rename the variables that will be sent to the thread because these variables are used in the initialization of the structure at the end of the constructor. Again, we need to use a NPWF closure because we're sending a copy of the event loop and the application state to the thread.

Let's see the first part of the thread's closure:

UISFBETQBXONPWF]]\

MFUNVUCVGGFS<<>#6''&3@4*;&>

MFUNVUQMBZCBDL1MBZCBDLOFX.1.11MBZCBDL/POF

%&'"6-5@3"5&

MFUNVUTPVSDF/POF

MPPQ\

JGMFU4PNFBDUJPOFWFOU@MPPQRVFVFUSZ@QPQ\

NBUDIBDUJPO\

-PBEQBUI \

MFUGJMF'JMFPQFOQBUIVOXSBQ

TPVSDF

4PNF.Q%FDPEFSOFX#VG3FBEFSOFXGJMFVOXSBQ

MFUSBUFTPVSDFBT@SFGNBQ]TPVSDF]

TPVSDFTBNQMFT@SBUFVOXSBQ@PS%&'"6-5@3"5& QMBZCBDL1MBZCBDLOFX.1.11MBZCBDL

/POFSBUF

BQQ@TUBUFMPDLVOXSBQTUPQQFEGBMTF

^

4UPQ \^

^

^

d

^

^

[ 197 ]





Implementing the Engine of the Music Player Chapter 6

We start by creating a buffer to contain the samples to be played. Then we'll create a 1MBZCBDL, which is an object that will allow us to play music on the hardware. We'll also create a TPVSDF variable that will contain an .Q%FDPEFS. We then start an infinite loop and try to get the first element in the queue: if there's an element in the queue, 4PNFBDUJPO is returned. That's why we used JGMFU to pattern match against the result of this method call. We then match against the action to see which action it is: if it is a -PBE

action, we open the file with the specified path and create an .Q%FDPEFS with a buffered reader of this file. We then try to get the sample rate of the song and create a new 1MBZCBDL

with this rate. We'll handle the 4UPQ action later.

Finally, we see our first use of .VUFY:

BQQ@TUBUFMPDLVOXSBQTUPQQFEGBMTF

Let's rewrite it in another way to see what's going on: MFUNVUHVBSEBQQ@TUBUFMPDLVOXSBQ

HVBSETUPQQFEGBMTF

We first call MPDL, which returns a 3FTVMU.VUFY(VBSE5

1PJTPO&SSPS.VUFY(VBSE5 .

Mutex guard

A mutex guard is a scoped lock: this means that the mutex will be automatically unlocked when going out of scope. It is a nice way to ensure that users will use a .VUFY and won't forget to unlock it.

RAII

But how does it work behind the scene? Rust uses the idiom of Resource Acquisition Is Initialization(RAII) for short. With this idiom, a resource is allocated in the constructor and released in its destructor. In Rust, destructors are implemented by the %SPQ trait. So, to get back to mutex guards, the mutex is unlocked when the destructor of .VUFY(VBSE is called, so, as in the previous example, when the HVBSE variable goes out of scope.

[ 198 ]

Implementing the Engine of the Music Player Chapter 6

Let's get back to our infinite loop:

MPPQ\

JGMFU4PNFBDUJPOFWFOU@MPPQRVFVFUSZ@QPQ\

d

^FMTFJGFWFOU@MPPQQMBZJOHMPDLVOXSBQ\

MFUNVUXSJUUFOGBMTF

JGMFU4PNFSFGNVUTPVSDFTPVSDF\

MFUTJ[FJUFS@UP@CVGGFSTPVSDFNVUCVGGFS

JGTJ[F \

QMBZCBDLXSJUFCVGGFS<TJ[F>

XSJUUFOUSVF

^

^

JGXSJUUFO\

BQQ@TUBUFMPDLVOXSBQTUPQQFEUSVF

FWFOU@MPPQQMBZJOHMPDLVOXSBQGBMTF

TPVSDF/POF

^

^

^

Here, we check whether the playing value is true (again using the MPDLVOXSBQ trick).

We must use a to access the value of a .VUFY(VBSE because it implements %FSFG. That means we don't have direct access to the underlying value. But since it implements the

%FSFG trait, we can access it by dereferencing the guard (with a ). We didn't need this trick before because we accessed a field and Rust automatically dereferences fields.

We then create a XSJUUFO variable that will be USVF if the player was able to play a sample.

If it was unable to play one, this means the song came to an end. In this case, we set the TUPQQFE value to USVF and QMBZJOH to GBMTF.

To play the samples, we call JUFS@UP@CVGGFS, which will take the value from the decoder (which is an *UFSBUPS) and write them to the buffer. Afterward, it will write the buffer to the QMBZCBDL in order to play the samples on your sound card.

Let's look at this JUFS@UP@CVGGFS function:

GOJUFS@UP@CVGGFS**UFSBUPS*UFNJ JUFSNVU*CVGGFSNVU

<<J>#6''&3@4*;&> VTJ[F\

MFUNVUJUFSJUFSUBLF#6''&3@4*;&

MFUNVUJOEFY

XIJMFMFU4PNFTBNQMFJUFSOFYU\

JGMFU4PNFTBNQMFJUFSOFYU\

CVGGFS<JOEFY><>TBNQMF

[ 199 ]





Implementing the Engine of the Music Player Chapter 6

CVGGFS<JOEFY><>TBNQMF

^

JOEFY

^

JOEFY

^

We start by taking #6''&3@4*;& elements from the iterator and add them to the buffer two at a time (for two channels). We then return the number of elements written to the buffer.

Using the music player

We're now ready to use our music engine. Let's add a couple of new methods to 1MBZMJTU.

Let's start with a method to get the path of the selection: GOTFMFDUFE@QBUITFMG 0QUJPO4USJOH \

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

MFUWBMVFTFMGNPEFMHFU@WBMVFJUFS1"5)@$0-6./BTJ

SFUVSOWBMVFHFU4USJOH

^

/POF

^

We start by getting the selection, then we get the iterator for the selection. From the iterator, we can get the value at the specified column to get the path. We can now add a method to load the selected song:

QVCGOQMBZTFMG CPPM\

JGMFU4PNFQBUITFMGTFMFDUFE@QBUI\

TFMGQMBZFSMPBEQBUI

USVF

^FMTF\

GBMTF

^

^

If there's a selected song, we load it into the music engine. We return true if a song was loaded.

[ 200 ]





Implementing the Engine of the Music Player Chapter 6

We'll now use this method in the event handler of the play button: JNQM"QQ\

QVCGODPOOFDU@UPPMCBS@FWFOUTTFMG\

d

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

MFUDPWFSTFMGDPWFSDMPOF

MFUTUBUFTFMGTUBUFDMPOF

TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGTUBUFMPDLVOXSBQTUPQQFE\

JGQMBZMJTUQMBZ\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

TFU@DPWFSDPWFSQMBZMJTU

^

^FMTF\

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^

^

d

^

^

We create a copy of the QMBZMJTU variable because it is moved into the closure. In the latter, we then call the QMBZ method we created just before. We only change the image of the button and show the cover if a song starts to play.

You can now try the music player: open an MP3 file, click play, and you should hear the song. Let's continue to develop the software since many features are missing.

Pausing and resuming the song

We'll start by adding a field indicating whether the player is in pause or not. This field will be changed by methods such as QMBZ or SFTVNF. However, remember that our 1MBZMJTU is wrapped in an 3D, so that we can use it in different places, namely in the event handlers.

Also, remember that Rust forbids mutation when there are mutable references to a value.

How can we update this field while still using a reference-counted pointer? One way is to use interior mutability.

[ 201 ]





Implementing the Engine of the Music Player Chapter 6

Interior mutability

Interior mutability is a concept granting mutable an inner value of a type with an immutable reference. Is this safe to do? Yes, totally, because we need to respect certain constraints. One way to have interior mutability is to wrap our $FMM type. The constraint of this type is that if we want to get the value from the $FMM from an immutable reference, the wrapped type must implement the $PQZ trait. We'll see the other commonly-used type for interior mutability later in this chapter. For now, let's add our field to the 1MBZFS type: VTFTUEDFMM$FMM

QVCTUSVDU1MBZFS\

BQQ@TUBUF"SD.VUFYTVQFS4UBUF

FWFOU@MPPQ&WFOU-PPQ

QBVTFE$FMMCPPM

^

Let's update the construction of the structure:

JNQM1MBZFS\

QVCDSBUFGOOFXBQQ@TUBUF"SD.VUFYTVQFS4UBUF 4FMG

\

d

1MBZFS\

BQQ@TUBUF

FWFOU@MPPQ

QBVTFE$FMMOFXGBMTF

^

^

^

We can now add a method to check whether the music is paused or not: QVCGOJT@QBVTFETFMG CPPM\

TFMGQBVTFEHFU

^

[ 202 ]

Implementing the Engine of the Music Player Chapter 6

Here, we need to call $FMMHFU to get a copy of the inner value. We can now add methods to play and resume the song:

QVCGOQBVTFTFMG\

TFMGQBVTFETFUUSVF

TFMGBQQ@TUBUFMPDLVOXSBQTUPQQFEUSVF

TFMGTFU@QMBZJOHGBMTF

^

QVCGOSFTVNFTFMG\

TFMGQBVTFETFUGBMTF

TFMGBQQ@TUBUFMPDLVOXSBQTUPQQFEGBMTF

TFMGTFU@QMBZJOHUSVF

^

Here we see that we need to call $FMMTFU to update the value of the $FMM. We can do that even though we only have an immutable reference and, once again, it is completely safe to do so. Then, we update the TUPQQFE field of the application state because the click handler for the play button will use it to decide whether we want to play or resume the music. We also call TFU@QMBZJOH to indicate to the player thread whether it needs to continue playing the song or not. This method is defined as such: GOTFU@QMBZJOHTFMGQMBZJOHCPPM\

TFMGFWFOU@MPPQQMBZJOHMPDLVOXSBQQMBZJOH

MFUSFGMPDLSFGDPOEJUJPO@WBSJBCMF

TFMGFWFOU@MPPQDPOEJUJPO@WBSJBCMF

MFUNVUTUBSUFEMPDLMPDLVOXSBQ

TUBSUFEQMBZJOH

JGQMBZJOH\

DPOEJUJPO@WBSJBCMFOPUJGZ@POF

^

^

It sets the QMBZJOH variable and then notifies the player thread to wake it up if QMBZJOH is USVF.

We'll now add a QBVTF method to our 1MBZMJTU type that will call the QBVTF method we've just created when the user clicks pause:

QVCGOQBVTFTFMG\

TFMGQMBZFSQBVTF

^

[ 203 ]

Implementing the Engine of the Music Player Chapter 6

To use it, we'll update the click handler of the play button: TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGTUBUFMPDLVOXSBQTUPQQFE\

JGQMBZMJTUQMBZ\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

TFU@DPWFSDPWFSQMBZMJTU

^

^FMTF\

playlist.pause();

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^

^

We added the call to pause in the FMTF block.

We now want to update the QMBZ method. Now that we can pause the song, there are two new cases to consider for this method:

If the song is playing, we want to pause it.

If the song is paused, we either want to resume the song if the same one is selected or start a new song if another one is selected.

That's why we need a new field in our 1MBZMJTU structure: QVCTUSVDU1MBZMJTU\

DVSSFOU@TPOH3FG$FMM0QUJPO4USJOH

NPEFM-JTU4UPSF

QMBZFS1MBZFS

USFFWJFX5SFF7JFX

^

We added a field that will contain the path of the currently playing song. Here we wrap the 0QUJPO4USJOH into a 3FG$FMM, which is another way to have interior mutability. We cannot use a $FMM because the 4USJOH type does not implement the $PQZ trait. So, what is the difference between $FMM and 3FG$FMM? The 3FG$FMM type will check the borrowing rules at runtime: if two borrows happen at the same time, it will panic. We have to be careful when using 3FG$FMM: it is better to have compile-time borrowing checks if possible.

But when using HULST, we sometimes need to share a mutable state with the event handler and the best way to do that is to use 3FG$FMM.

[ 204 ]

Implementing the Engine of the Music Player Chapter 6

In the next chapter, we'll learn how to use a library that abstracts the state management so that you won't need to use 3FG$FMM and you won't get any QBOJD at runtime. This requires a new import statement:

VTFTUEDFMM3FG$FMM

We need to update the constructor to initialize this value: JNQM1MBZMJTU\

QVCDSBUFGOOFXTUBUF"SD.VUFY4UBUF 4FMG\

d

1MBZMJTU\

DVSSFOU@TPOH3FG$FMMOFX/POF

NPEFM

QMBZFS1MBZFSOFXTUBUFDMPOF

USFFWJFX

^

^

^

There's one more method to add in 1MBZMJTU before we move on to update the QMBZ

method:

QVCGOQBUITFMG 0QUJPO4USJOH \

TFMGDVSSFOU@TPOHCPSSPXDMPOF

^

This method returns a copy of the current song path. Since the field is a 3FG$FMM, we need to call CPSSPX in order to get access to the inner value. This method returns the equivalent of an immutable reference. We'll soon see how to have a mutable reference. As with .VUFY, the borrow is lexical and the borrow will end at the end of the function. We're now ready to update the QMBZ method:

QVCGOQMBZTFMG CPPM\

JGMFU4PNFQBUITFMGTFMFDUFE@QBUI\

JGTFMGQMBZFSJT@QBVTFE4PNFQBUI

TFMGQBUIBT@SFG\

TFMGQMBZFSSFTVNF

^FMTF\

TFMGQMBZFSMPBEQBUI

TFMGDVSSFOU@TPOHCPSSPX@NVU4PNFQBUIJOUP

^

USVF

^FMTF\

GBMTF

[ 205 ]

Implementing the Engine of the Music Player Chapter 6

^

^

We call SFTVNF if the song was paused and if the selected path is the same as the currently playing song path. If this condition is GBMTF, we load the specified path and save this path in our field. To do so, we call CPSSPX@NVU to get a mutable reference. Once again, we need to prefix the expression with so that %FSFG.VUEFSFG@NVU gets called. Run the project and you'll see that you can pause and resume the song.

Let's now add a way to stop the song. We'll start by adding a method to the 1MBZFS, as usual:

QVCGOTUPQTFMG\

TFMGQBVTFETFUGBMTF

TFMGBQQ@TUBUFMPDLVOXSBQTUPQQFEUSVF

TFMGFNJU4UPQ

TFMGTFU@QMBZJOHGBMTF

^

We first set the QBVTFE field to GBMTF so that the playlist won't try to resume the song the next time the play button is clicked. We then set the TUPQQFE field to USVF, this will cause the next click of this button to play the song instead of trying to pause it. We then emit the 4UPQ action to the event loop and indicate to the engine thread that it should not play music anymore.

The FNJU method is very simple:

GOFNJUTFMGBDUJPO"DUJPO\

TFMGFWFOU@MPPQRVFVFQVTIBDUJPO

^

It simply pushes the BDUJPO in the queue of the event loop.

Let's now handle this 4UPQ event:

4UPQ \

TPVSDF/POF

^

[ 206 ]

Implementing the Engine of the Music Player Chapter 6

We only reset the source to /POF because we won't need it anymore.

Then, we're ready to add a TUPQ method to the 1MBZMJTU: QVCGOTUPQTFMG\

TFMGDVSSFOU@TPOHCPSSPX@NVU/POF

TFMGQMBZFSTUPQ

^

We first reset the DVSSFOU@TPOH field to /POF in such a way that the next call to QMBZ

won't attempt to resume the song. We then call the TUPQ method we created earlier.

We're now ready to use this new method by creating a new event handler for the stop button, add this code to the DPOOFDU@UPPMCBS@FWFOUT method: MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

MFUDPWFSTFMGDPWFSDMPOF

TFMGUPPMCBSTUPQ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

QMBZMJTUTUPQ

DPWFSIJEF

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^

So, when we click stop, we call the 1MBZMJTUTUPQ method in order to stop playing the music. We also hide the cover and set back the play button to show the play icon. You can now try again in the music player to see this new feature in action.

Now let's add the actions for the two remaining buttons: previous and next.

We first need to create a new method in the 1MBZMJTU: QVCGOOFYUTFMG CPPM\

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

MFUOFYU@JUFS

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

JGTFMGNPEFMJUFS@OFYUJUFS\

SFUVSOGBMTF

^

4PNFJUFS

^

FMTF\

TFMGNPEFMHFU@JUFS@GJSTU

^

JGMFU4PNFSFGJUFSOFYU@JUFS\

TFMFDUJPOTFMFDU@JUFSJUFS

TFMGQMBZ

[ 207 ]

Implementing the Engine of the Music Player Chapter 6

^

OFYU@JUFSJT@TPNF

^

We start by getting the selection. Then we check whether an item is selected: in this case, we try to get the item after the selection. Otherwise, we get the first item on the list. Then, if we were able to get an item, we select it and start playing the song. We return whether we changed the selection or not.

The QSFWJPVT method is similar:

QVCGOQSFWJPVTTFMG CPPM\

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

MFUQSFWJPVT@JUFS

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

JGTFMGNPEFMJUFS@QSFWJPVTJUFS\

SFUVSOGBMTF

^

4PNFJUFS

^

FMTF\

TFMGNPEFMJUFS@OUI@DIJME/POFNBY

TFMGNPEFMJUFS@O@DIJMESFO/POF



^

JGMFU4PNFSFGJUFSQSFWJPVT@JUFS\

TFMFDUJPOTFMFDU@JUFSJUFS

TFMGQMBZ

^

QSFWJPVT@JUFSJT@TPNF

^

However, there's no HFU@JUFS@MBTU method, so we get the last element with JUFS@OUI@DIJME.

This requires a new import statement to be added at the top of the file: VTFTUEDNQNBY

[ 208 ]





Implementing the Engine of the Music Player Chapter 6

With these new methods, we're ready to handle the click events for the buttons. Let's start with the next button:

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

MFUDPWFSTFMGDPWFSDMPOF

TFMGUPPMCBSOFYU@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGQMBZMJTUOFYU\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

TFU@DPWFSDPWFSQMBZMJTU

^

^

We simply call the OFYU method we just created and if a new song was selected, we update the icon of the play button and show the new cover. The previous button handler is exactly the same except that we call QSFWJPVT instead: MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

MFUDPWFSTFMGDPWFSDMPOF

TFMGUPPMCBSQSFWJPVT@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGQMBZMJTUQSFWJPVT\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

TFU@DPWFSDPWFSQMBZMJTU

^

^

Showing the progression of the song

It would be nice to see the cursor moving when the song plays. Let's tackle this challenge right now.

We'll start by adding a method to our 1MBZFS to get the duration of a song: VTFTUEUJNF%VSBUJPO

QVCGODPNQVUF@EVSBUJPO1"T3FG1BUI QBUI1

0QUJPO%VSBUJPO \

MFUGJMF'JMFPQFOQBUIVOXSBQ

.Q%FDPEFSDPNQVUF@EVSBUJPO#VG3FBEFSOFXGJMF

^

[ 209 ]

Implementing the Engine of the Music Player Chapter 6

We simply call the DPNQVUF@EVSBUJPO method we created earlier. Next, we'll modify the 1MBZMJTU to call this function. But before we do so, we'll modify the 4UBUF type from the NBJO module to include additional information: VTFTUEDPMMFDUJPOT)BTI.BQ

TUSVDU4UBUF\

DVSSFOU@UJNFV

EVSBUJPOT)BTI.BQ4USJOHV

TUPQQFECPPM

^

We added a DVSSFOU@UJNF field, which will contain how much time elapsed since the song started playing. We also store the duration of the songs in a )BTI.BQ so that we only compute it once for each path. We now need to update the initialization of the 4UBUF in the

"QQ constructor:

MFUDVSSFOU@UJNF

MFUEVSBUJPOT)BTI.BQOFX

MFUTUBUF"SDOFX.VUFYOFX4UBUF\

DVSSFOU@UJNF

EVSBUJPOT

TUPQQFEUSVF

^

Let's go back to the 1MBZMJTU. It will now contain the 4UBUF in its structure: QVCTUSVDU1MBZMJTU\

DVSSFOU@TPOH3FG$FMM0QUJPO4USJOH

NPEFM-JTU4UPSF

QMBZFS1MBZFS

TUBUF"SD.VUFY4UBUF

USFFWJFX5SFF7JFX

^

[ 210 ]

Implementing the Engine of the Music Player Chapter 6

This should be reflected in its constructor:

1MBZMJTU\

DVSSFOU@TPOH3FG$FMMOFX/POF

NPEFM

QMBZFS1MBZFSOFXTUBUFDMPOF

TUBUF

USFFWJFX

^

Here, the TUBUF field was added. We'll now add a method that will compute the duration in another thread:

VTFTUEUISFBE

VTFUP@NJMMJT

GODPNQVUF@EVSBUJPOTFMGQBUI1BUI\

MFUTUBUFTFMGTUBUFDMPOF

MFUQBUIQBUIUP@TUSJOH@MPTTZUP@TUSJOH

UISFBETQBXONPWF]]\

JGMFU4PNFEVSBUJPO1MBZFSDPNQVUF@EVSBUJPOQBUI

\

MFUNVUTUBUFTUBUFMPDLVOXSBQ

TUBUFEVSBUJPOTJOTFSUQBUIUP@NJMMJTEVSBUJPO

^

^

^

In the thread's closure, we compute the duration and when it's done, we lock the state to insert the duration in the )BTI.BQ. We compute the duration in another thread because it can take time and we don't want to block the user interface during this computation. We now call this method in 1MBZMJTUBEE:

QVCGOBEETFMGQBUI1BUI\

TFMGDPNQVUF@EVSBUJPOQBUI

d

^

We'll update the "EKVTUNFOU so that its upper value is in the beginning: MFUBEKVTUNFOU"EKVTUNFOUOFX

[ 211 ]

Implementing the Engine of the Music Player Chapter 6

This is to avoid seeing the cursor moving too quickly when the duration is not yet computed.

Finally, we'll add the code to update the UI in the "QQDPOOFDU@FWFOUT method: VTFHUL\"EKVTUNFOU&YU$POUJOVF^

VTFUPPMCBS\TFU@JNBHF@JDPO1"64&@*$0/1-":@*$0/^

GODPOOFDU@FWFOUTTFMG\

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUBEKVTUNFOUTFMGBEKVTUNFOUDMPOF

MFUTUBUFTFMGTUBUFDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

HULUJNFPVU@BEENPWF]]\

MFUTUBUFTUBUFMPDLVOXSBQ

JGMFU4PNFQBUIQMBZMJTUQBUI\

JGMFU4PNFEVSBUJPOTUBUFEVSBUJPOTHFUQBUI

\

BEKVTUNFOUTFU@VQQFSEVSBUJPOBTG

^

^

JGTUBUFTUPQQFE\

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^FMTF\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

^

BEKVTUNFOUTFU@WBMVFTUBUFDVSSFOU@UJNFBTG

$POUJOVFUSVF

^

^

The HULUJNFPVU@BEE method will be run every 100 milliseconds as long as its closure returns $POUJOVFGBMTF. This closure starts by checking whether the duration is in the

)BTI.BQ, and sets the upper value of the cursor as this duration. If the value is not in the

)BTI.BQ, it means it wasn't computed yet. After that, we check whether the TUPQQFE field is true, that means the song ended and the engine thread is no longer playing it. In this case, we want to show the play icon. If the song is still playing, we show the pause icon. Finally, we set the current value of the cursor from the DVSSFOU@UJNF field.

[ 212 ]





Implementing the Engine of the Music Player

Chapter 6

The cursor will now move automatically as the song plays. Here's how the player looks now:

'JHVSF

Improving CPU usage

One issue you may have noticed is that when no song is playing, the software will use 100%

of the CPU. This is because of the infinite loop in the music engine thread. It will do nothing except loop when the song is paused or when there's no song to play. Let's now fix this issue.

[ 213 ]





Implementing the Engine of the Music Player Chapter 6

Condition variable

What we want to do is to make the thread sleep when it has nothing to do. We also want to be able to wake the thread up from the main thread. This is exactly what condition variables are for. So, let's add one to our engine. We'll start by adding a DPOEJUJPO@WBSJBCMF field to the &WFOU-PPQ:

TUSVDU&WFOU-PPQ\

DPOEJUJPO@WBSJBCMF"SD.VUFYCPPM $POEWBS

RVFVF"SD4FH2VFVF"DUJPO

QMBZJOH"SD.VUFYCPPM

^

A condition variable is usually used together with a Boolean value (wrapped in a .VUFY).

We need to rewrite the constructor of &WFOU-PPQ to initialize this new field: JNQM&WFOU-PPQ\

GOOFX 4FMG\

&WFOU-PPQ\

DPOEJUJPO@WBSJBCMF"SDOFX.VUFYOFXGBMTF

$POEWBSOFX

RVFVF"SDOFX4FH2VFVFOFX

QMBZJOH"SDOFX.VUFYOFXGBMTF

^

^

^

Next, we need to block the thread when it has nothing to do. Here's the start of the new code of the thread in 1MBZFSOFX:

\

MFUBQQ@TUBUFBQQ@TUBUFDMPOF

MFUFWFOU@MPPQFWFOU@MPPQDMPOF

MFUDPOEJUJPO@WBSJBCMFFWFOU@MPPQDPOEJUJPO@WBSJBCMFDMPOF

UISFBETQBXONPWF]]\

MFUCMPDL]]\

MFUSFGMPDLSFGDPOEJUJPO@WBSJBCMF

DPOEJUJPO@WBSJBCMF

MFUNVUTUBSUFEMPDLMPDLVOXSBQ

TUBSUFEGBMTF

XIJMFTUBSUFE\

TUBSUFE

DPOEJUJPO@WBSJBCMFXBJUTUBSUFEVOXSBQ

^

^

[ 214 ]

Implementing the Engine of the Music Player Chapter 6

We create a copy of the condition variable and we move this copy into the thread. Then, in the beginning of the closure, we lock the Boolean value associated with the condition variable to set it to GBMTF. Afterward, we loop: while this value is GBMTF, we block the current thread. We created a closure instead of a normal function because normal functions cannot capture values. The following code is the same as before: MFUNVUCVGGFS<<>#6''&3@4*;&>

MFUNVUQMBZCBDL1MBZCBDLOFX.1.11MBZCBDL/POF

%&'"6-5@3"5&

MFUNVUTPVSDF/POF

MPPQ\

JGMFU4PNFBDUJPOFWFOU@MPPQRVFVFUSZ@QPQ\

NBUDIBDUJPO\

-PBEQBUI \

MFUGJMF'JMFPQFOQBUIVOXSBQ

TPVSDF

4PNF.Q%FDPEFSOFX#VG3FBEFSOFXGJMFVOXSBQ

MFUSBUFTPVSDFBT@SFGNBQ]TPVSDF]

TPVSDFTBNQMFT@SBUFVOXSBQ@PS%&'"6-5@3"5& QMBZCBDL1MBZCBDLOFX.1.11MBZCBDL

/POFSBUF

BQQ@TUBUFMPDLVOXSBQTUPQQFEGBMTF

^

4UPQ \

TPVSDF/POF

^

^

^FMTFJGFWFOU@MPPQQMBZJOHMPDLVOXSBQ\

MFUNVUXSJUUFOGBMTF

JGMFU4PNFSFGNVUTPVSDFTPVSDF\

MFUTJ[FJUFS@UP@CVGGFSTPVSDFNVUCVGGFS

JGTJ[F \

BQQ@TUBUFMPDLVOXSBQDVSSFOU@UJNF

TPVSDFDVSSFOU@UJNF

QMBZCBDLXSJUFCVGGFS<TJ[F>

XSJUUFOUSVF

^

^

[ 215 ]





Implementing the Engine of the Music Player Chapter 6

But the rest of the closure is a bit different:

JGXSJUUFO\

BQQ@TUBUFMPDLVOXSBQTUPQQFEUSVF

FWFOU@MPPQQMBZJOHMPDLVOXSBQGBMTF

TPVSDF/POF

CMPDL

^

^FMTF\

CMPDL

^

^

^

^

If the player was unable to play song (that is, the song came into an end), we call the closure to block the thread. We also block the thread if the player is paused. With the condition variable, the software stopped using 100% CPU.

Showing the song's current time

Currently, we only display the progression of the song. The user has no way to know the duration and for how many seconds the song has been playing. Let's fix that by adding labels that will show the current time and the duration.

We'll need two new import statements in the NBJO module: VTFHUL\-BCFM-BCFM&YU^

We'll also add two MBCFM in our "QQ structure: TUSVDU"QQ\

BEKVTUNFOU"EKVTUNFOU

DPWFS*NBHF

DVSSFOU@UJNF@MBCFM-BCFM

EVSBUJPO@MBCFM-BCFM

QMBZMJTU3D1MBZMJTU

TUBUF"SD.VUFY4UBUF

UPPMCBS.VTJD5PPMCBS

XJOEPX8JOEPX

^

[ 216 ]

Implementing the Engine of the Music Player Chapter 6

One MBCFM for the current time and the other for the duration. Since we want to show the different MBCFM on the right of the cursor, we'll create a horizontal box, this code should be added in "QQOFX:

MFUICPYHUL#PYOFX)PSJ[POUBM

WCPYBEEICPY

MFUBEKVTUNFOU"EKVTUNFOUOFX

MFUTDBMF4DBMFOFX)PSJ[POUBMBEKVTUNFOU

TDBMFTFU@ESBX@WBMVFGBMTF

TDBMFTFU@IFYQBOEUSVF

ICPYBEETDBMF

The 4DBMF widget is now added to ICPY instead of WCPY. And we call TFU@IFYQBOE so that the widget takes as much horizontal space as possible.

We're now ready to create our MBCFM's:

MFUDVSSFOU@UJNF@MBCFM-BCFMOFX/POF

ICPYBEEDVSSFOU@UJNF@MBCFM

MFUTMBTI@MBCFM-BCFMOFX

ICPYBEETMBTI@MBCFM

MFUEVSBUJPO@MBCFM-BCFMOFX/POF

EVSBUJPO@MBCFMTFU@NBSHJO@SJHIU

ICPYBEEEVSBUJPO@MBCFM

We create three MBCFM; the third one being a separator. We set a right margin to the last MBCFM so that it is not too close to the border of the window. Further, in the "QQ constructor, we need to update the initialization of the structure: MFUBQQ"QQ\

BEKVTUNFOU

DPWFS

DVSSFOU@UJNF@MBCFM

EVSBUJPO@MBCFM

QMBZMJTU

TUBUF

UPPMCBS

XJOEPX

^

We added the two MBCFM.

[ 217 ]

Implementing the Engine of the Music Player Chapter 6

We'll create a function to convert a number of milliseconds to a 4USJOH of the NJOVUFTFDPOE format:

GONJMMJT@UP@NJOVUFTNJMMJTV 4USJOH\

MFUNVUTFDPOETNJMMJT@

MFUNJOVUFTTFDPOET

TFDPOET

GPSNBU\^\^NJOVUFTTFDPOET

^

In this function, we first convert the milliseconds to seconds by dividing by one thousand.

We then get the number of minutes by dividing the seconds by . Afterward, we compute the number of seconds that are not included in the minutes with the modulo operation.

Finally, we format the minutes and seconds as a 4USJOH. As you can see, we used a special \^ formatter. The means that we want to print the number as two characters, even if the number is less than 0. The after the colon indicates that we want to prepend instead of spaces.

With this new function, we can rewrite the timer to update (in the method

"QQDPOOFDU@FWFOUT) the MBCFM's:

MFUDVSSFOU@UJNF@MBCFMTFMGDVSSFOU@UJNF@MBCFMDMPOF

MFUEVSBUJPO@MBCFMTFMGEVSBUJPO@MBCFMDMPOF

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUBEKVTUNFOUTFMGBEKVTUNFOUDMPOF

MFUTUBUFTFMGTUBUFDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

HULUJNFPVU@BEENPWF]]\

MFUTUBUFTUBUFMPDLVOXSBQ

JGMFU4PNFQBUIQMBZMJTUQBUI\

JGMFU4PNFEVSBUJPOTUBUFEVSBUJPOTHFUQBUI\

BEKVTUNFOUTFU@VQQFSEVSBUJPOBTG

EVSBUJPO@MBCFMTFU@UFYUNJMMJT@UP@NJOVUFTEVSBUJPO

^

^

JGTUBUFTUPQQFE\

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^FMTF\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

DVSSFOU@UJNF@MBCFMTFU@UFYUNJMMJT@UP@NJOVUFTTUBUFDVSSFOU@UJNF



^

BEKVTUNFOUTFU@WBMVFTUBUFDVSSFOU@UJNFBTG

$POUJOVFUSVF

^

[ 218 ]



Implementing the Engine of the Music Player

Chapter 6

Here are the changes from the previous version. When we get the duration, we update the duration MBCFM. And when the song is not stopped (that is, when it is playing), we update the current time MBCFM.

We need to change the stop button handler so that it resets the text of these MBCFM's.

Finally, we can update the handler:

MFUDVSSFOU@UJNF@MBCFMTFMGDVSSFOU@UJNF@MBCFMDMPOF

MFUEVSBUJPO@MBCFMTFMGEVSBUJPO@MBCFMDMPOF

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

MFUDPWFSTFMGDPWFSDMPOF

TFMGUPPMCBSTUPQ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

DVSSFOU@UJNF@MBCFMTFU@UFYU

EVSBUJPO@MBCFMTFU@UFYU

QMBZMJTUTUPQ

DPWFSIJEF

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^

We clone the widgets to move them into the closure and set the text of the MBCFM's to the empty string.

Here's the result you should see when running the application:

'JHVSF

[ 219 ]





Implementing the Engine of the Music Player Chapter 6

Loading and saving the playlist

We have the ability to create a playlist in our music player, but we cannot save a playlist to a file in order to be able to load one later. Let's add this feature to our project.

We'll save the playlist in the NV file format and to handle this format, we'll use the NV crate. So let's add it to our $BSHPUPNM file: NV?

Add this line to the NBJO module:

FYUFSODSBUFNV

Saving a playlist

We'll start by adding a button to save the playlist. First, we add a field in the

.VTJD5PPMCBS structure for the button:

QVCTUSVDU.VTJD5PPMCBS\

PQFO@CVUUPO5PPM#VUUPO

OFYU@CVUUPO5PPM#VUUPO

QMBZ@CVUUPO5PPM#VUUPO

QVCQMBZ@JNBHF*NBHF

QSFWJPVT@CVUUPO5PPM#VUUPO

RVJU@CVUUPO5PPM#VUUPO

SFNPWF@CVUUPO5PPM#VUUPO

TBWF@CVUUPO5PPM#VUUPO

TUPQ@CVUUPO5PPM#VUUPO

UPPMCBS5PPMCBS

^

And in the constructor, we'll create this button:

JNQM.VTJD5PPMCBS\

QVCGOOFX 4FMG\

MFUUPPMCBS5PPMCBSOFX

MFUPQFO@CVUUPO@OFX@UPPM@CVUUPOEPDVNFOUPQFO

UPPMCBSBEEPQFO@CVUUPO

MFUTBWF@CVUUPO@OFX@UPPM@CVUUPOEPDVNFOUTBWF

UPPMCBSBEETBWF@CVUUPO

UPPMCBSBEE4FQBSBUPS5PPM*UFNOFX

[ 220 ]

Implementing the Engine of the Music Player Chapter 6

d

MFUUPPMCBS.VTJD5PPMCBS\

PQFO@CVUUPO

OFYU@CVUUPO

QMBZ@CVUUPO

QMBZ@JNBHF

QSFWJPVT@CVUUPO

RVJU@CVUUPO

SFNPWF@CVUUPO

TBWF@CVUUPO

TUPQ@CVUUPO

UPPMCBS

^

UPPMCBS

^

^

Next, we'll add a TBWF method in the 1MBZMJTU structure: VTFTUEGT'JMF

VTFNV

QVCGOTBWFTFMGQBUI1BUI\

MFUNVUGJMF'JMFDSFBUFQBUIVOXSBQ

MFUNVUXSJUFSNV8SJUFSOFXNVUGJMF

MFUNVUXSJUF@JUFS]JUFS5SFF*UFS]\

MFUWBMVFTFMGNPEFMHFU@WBMVFJUFS1"5)@$0-6./BT

J

MFUQBUIWBMVFHFU4USJOH VOXSBQ

XSJUFSXSJUF@FOUSZNVQBUI@FOUSZQBUIVOXSBQ

^

JGMFU4PNFJUFSTFMGNPEFMHFU@JUFS@GJSTU\

XSJUF@JUFSJUFS

XIJMFTFMGNPEFMJUFS@OFYUJUFS\

XSJUF@JUFSJUFS

^

^

^

[ 221 ]

Implementing the Engine of the Music Player Chapter 6

Here, we first create a NV8SJUFS with a 'JMF that we've created. This writer will be used to write the entry to the file. We create a closure that gets the path from an iterator of our 5SFF7JFX and writes this path to the file. We chose to create a closure to avoid repeating the code, as we'll need this code twice. After that, we get the first iterator and write its contents before looping until there's no more row in the view.

We're now ready to call this code. First, we'll create a function in the module toolbar to show a save file dialog. It is similar to the TIPX@PQFO@EJBMPH function we wrote in the previous chapter:

GOTIPX@TBWF@EJBMPHQBSFOU"QQMJDBUJPO8JOEPX 0QUJPO1BUI#VG

\

MFUNVUGJMF/POF

MFUEJBMPH'JMF$IPPTFS%JBMPHOFX4PNF$IPPTFBEFTUJOBUJPO

.6QMBZMJTU

GJMF4PNFQBSFOU'JMF$IPPTFS"DUJPO4BWF

MFUGJMUFS'JMF'JMUFSOFX

GJMUFSBEE@NJNF@UZQFBVEJPYNQFHVSM

GJMUFSTFU@OBNF.6QMBZMJTUGJMF

EJBMPHTFU@EP@PWFSXSJUF@DPOGJSNBUJPOUSVF

EJBMPHBEE@GJMUFSGJMUFS

EJBMPHBEE@CVUUPO$BODFM3&410/4&@$"/$&-

EJBMPHBEE@CVUUPO4BWF3&410/4&@"$$&15

MFUSFTVMUEJBMPHSVO

JGSFTVMU3&410/4&@"$$&15\

GJMFEJBMPHHFU@GJMFOBNF

^

EJBMPHEFTUSPZ

GJMF

^

Here, we use the 'JMF$IPPTFS"DUJPO4BWF type instead of

'JMF$IPPTFS"DUJPO0QFO. We use a different filter and mime type. We also call TFU@EP@PWFSXSJUF@DPOGJSNBUJPO which is very important. It will ask for a confirmation if the user asks to overwrite a file. The rest of the function is exactly the same as the one to open a file, except that the MBCFM of the button is now 4BWF.

[ 222 ]





Implementing the Engine of the Music Player

Chapter 6

We can now use this function in the event handler of the save button: MFUQBSFOUTFMGXJOEPXDMPOF

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

TFMGUPPMCBSTBWF@CVUUPODPOOFDU@DMJDLFENPWF]@]\

MFUGJMFTIPX@TBWF@EJBMPHQBSFOU

JGMFU4PNFGJMFGJMF\

QMBZMJTUTBWFGJMF

^

^

We simply call the function TIPX@TBWF@EJBMPH and give the resulting file to the 1MBZMJTUTBWF method. You can now try to save a playlist in the application:

'JHVSF

Loading a playlist

We can save playlists, but still cannot load them. Let's start by adding a MPBE method to 1MBZMJTU:

QVCGOMPBETFMGQBUI1BUI\

MFUNVUSFBEFSNV3FBEFSPQFOQBUIVOXSBQ

GPSFOUSZJOSFBEFSFOUSJFT\

JGMFU0LNV&OUSZ1BUIQBUIFOUSZ\

TFMGBEEQBUI

^

^

^

Here, we create a NV3FBEFS with the specified path. We loop over the entry and if we were able to retrieve a NV&OUSZ1BUI, we add it to the playlist widget.

[ 223 ]

Implementing the Engine of the Music Player Chapter 6

We'll now modify the open dialog to allow selecting .6 files: GOTIPX@PQFO@EJBMPHQBSFOU"QQMJDBUJPO8JOEPX 0QUJPO1BUI#VG

\

MFUNVUGJMF/POF

MFUEJBMPH'JMF$IPPTFS%JBMPHOFX4PNF4FMFDUBO.1BVEJP

GJMF

4PNFQBSFOU'JMF$IPPTFS"DUJPO0QFO

MFUNQ@GJMUFS'JMF'JMUFSOFX

NQ@GJMUFSBEE@NJNF@UZQFBVEJPNQ

NQ@GJMUFSTFU@OBNF.1BVEJPGJMF

EJBMPHBEE@GJMUFSNQ@GJMUFS

MFUNV@GJMUFS'JMF'JMUFSOFX

NV@GJMUFSBEE@NJNF@UZQFBVEJPYNQFHVSM

NV@GJMUFSTFU@OBNF.6QMBZMJTUGJMF

EJBMPHBEE@GJMUFSNV@GJMUFS

EJBMPHBEE@CVUUPO$BODFM3&410/4&@$"/$&-

EJBMPHBEE@CVUUPO"DDFQU3&410/4&@"$$&15

MFUSFTVMUEJBMPHSVO

JGSFTVMU3&410/4&@"$$&15\

GJMFEJBMPHHFU@GJMFOBNF

^

EJBMPHEFTUSPZ

GJMF

^

We'll now change the open button event handler to select which action to do depending on the file type:

JNQM"QQ\

QVCGODPOOFDU@UPPMCBS@FWFOUTTFMG\

MFUQBSFOUTFMGXJOEPXDMPOF

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

TFMGUPPMCBSPQFO@CVUUPODPOOFDU@DMJDLFENPWF]@]\

MFUGJMFTIPX@PQFO@EJBMPHQBSFOU

JGMFU4PNFGJMFGJMF\

JGMFU4PNFFYUGJMFFYUFOTJPO\

NBUDIFYUUP@TUSVOXSBQ\

NQ QMBZMJTUBEEGJMF

NV QMBZMJTUMPBEGJMF

FYUFOTJPO \

MFUEJBMPH

.FTTBHF%JBMPHOFX4PNFQBSFOU

%JBMPH'MBHTFNQUZ.FTTBHF5ZQF&SSPS

[ 224 ]



Implementing the Engine of the Music Player

Chapter 6

#VUUPOT5ZQF0LGPSNBU$BOOPUPQFO

GJMFXJUI

FYUFOTJPO\^FYUFOTJPO

EJBMPHSVO

EJBMPHEFTUSPZ

^

^

^

^

^

d

^

^

This requires a couple of new import statements:

VTFHUL\

#VUUPOT5ZQF

%JBMPH'MBHT

.FTTBHF%JBMPH

.FTTBHF5ZQF

^

This new event handler now checks the file extension, if it is NQ, it will call the 1MBZMJTUBEE method as we were doing earlier. If it is NV, we call our new 1MBZMJTUMPBE method. Otherwise, we show an error message to the user:

'JHVSF

[ 225 ]





Implementing the Engine of the Music Player Chapter 6

You can now try to load a playlist in our music player, don't forget to change the filter in order to see M3U files in the dialog.

Using gstreamer for playback

Implementing an engine to play music was a good exercise to learn about threading.

However, for a real program, you could simply use HTUSFBNFS for the music playback. So, let's see how to use this library in our music player.

Remove the following dependencies in your $BSHPUPNM: DSPTTCFBN?

QVMTFTJNQMF?

TJNQMFNBE?

And remove their corresponding FYUFSODSBUF statements. We can also remove the NQ

and QMBZFS modules as we'll use HTUSFBNFS instead. Now, we can add our dependencies for HTUSFBNFS:

HTUSFBNFS?

HTUSFBNFSQMBZFS?

And add their corresponding FYUFSODSBUF statements: FYUFSODSBUFHTUSFBNFSBTHTU

FYUFSODSBUFHTUSFBNFS@QMBZFSBTHTU@QMBZFS

At the beginning of the NBJO function, we need to initialize HTUSFBNFS: HTUJOJUFYQFDUHTUSFBNFSJOJUJBMJ[BUJPOGBJMFE

We no longer need our 4UBUF structure, so we remove it and the TUBUF field in the "QQ structure. And now, we can update our QMBZMJTU module. First, let's add a few VTF statements:

VTFHTU\$MPDL5JNF&MFNFOU&YU^

VTFHTU@QMBZFS

VTFHUL$BTU

[ 226 ]

Implementing the Engine of the Music Player Chapter 6

We remove the TUBUF field and update the QMBZFS one in the 1MBZMJTU structure: QVCTUSVDU1MBZMJTU\

DVSSFOU@TPOH3FG$FMM0QUJPO4USJOH

NPEFM-JTU4UPSF

QMBZFSHTU@QMBZFS1MBZFS

USFFWJFX5SFF7JFX

^

The 1MBZMJTU constructor does not need the TUBUF anymore: JNQM1MBZMJTU\

QVCDSBUFGOOFX 4FMG\

MFUNPEFM-JTU4UPSFOFX<

1JYCVGTUBUJD@UZQF

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

1JYCVGTUBUJD@UZQF

>

MFUUSFFWJFX5SFF7JFXOFX@XJUI@NPEFMNPEFM

USFFWJFXTFU@IFYQBOEUSVF

USFFWJFXTFU@WFYQBOEUSVF

4FMGDSFBUF@DPMVNOTUSFFWJFX

MFUEJTQBUDIFS

HTU@QMBZFS1MBZFS(.BJO$POUFYU4JHOBM%JTQBUDIFSOFX/POF

MFUQMBZFSHTU@QMBZFS1MBZFSOFX/POF

4PNFEJTQBUDIFSVQDBTU

HTU@QMBZFS1MBZFS4JHOBM%JTQBUDIFS



1MBZMJTU\

DVSSFOU@TPOH3FG$FMMOFX/POF

NPEFM

QMBZFS

USFFWJFX

^

^

^

[ 227 ]

Implementing the Engine of the Music Player Chapter 6

Here, we create the 1MBZFS from the HTUSFBNFS crate. We need to remove the DPNQVUF@EVSBUJPO method and all its uses because we'll use HTUSFBNFS to get the song's duration:

QVCGOHFU@EVSBUJPOTFMG $MPDL5JNF\

TFMGQMBZFSHFU@EVSBUJPO

^

QVCGOHFU@DVSSFOU@UJNFTFMG $MPDL5JNF\

TFMGQMBZFSHFU@QPTJUJPO

^

QVCGOJT@QMBZJOHTFMG CPPM\

TFMGQMBZFSHFU@QJQFMJOF

NBQ]FMFNFOU]FMFNFOUHFU@TUBUFHTU$-0$,@5*.&@/0/& HTU4UBUF1MBZJOH

VOXSBQ@PSGBMTF

^

Here, we create a few methods that will be useful to show the time and when the song is playing. Finally, we can update the QMBZ method to use HTUSFBNFS instead: QVCGOQMBZTFMG CPPM\

JGTFMGTFMFDUFE@QBUITFMGQMBZFSHFU@VSJ\

TFMGQMBZFSQMBZ

SFUVSOGBMTF

^

JGMFU4PNFQBUITFMGTFMFDUFE@QBUI\

MFUVSJGPSNBUGJMF\^QBUI

TFMGQMBZFSTFU@VSJVSJ

TFMGQMBZFSQMBZ

USVF

^FMTF\

GBMTF

^

^

Let's go back to the NBJO module to update the creation of the playlist: MFUQMBZMJTU3DOFX1MBZMJTUOFX

[ 228 ]

Implementing the Engine of the Music Player Chapter 6

One more thing to update is the code to show the current time: HULUJNFPVU@BEENPWF]]\

MFUEVSBUJPOQMBZMJTUHFU@EVSBUJPO

BEKVTUNFOUTFU@VQQFSEVSBUJPOOBOPTFDPOETVOXSBQ@PSBT

G

EVSBUJPO@MBCFMTFU@UFYUGPSNBU\^EVSBUJPO

MFUDVSSFOU@UJNFQMBZMJTUHFU@DVSSFOU@UJNF

JGQMBZMJTUJT@QMBZJOH\

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^FMTF\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

DVSSFOU@UJNF@MBCFMTFU@UFYUGPSNBU\^

DVSSFOU@UJNF

^

BEKVTUNFOUTFU@WBMVFDVSSFOU@UJNFOBOPTFDPOETVOXSBQ@PSBT

G

$POUJOVFUSVF

^

We now use the methods we created a bit earlier and some from HTUSFBNFS.

Finally, we update the UPPMCBS module. First, the QMBZ@CVUUPO event handler: TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGQMBZMJTUJT@QMBZJOH\

JGQMBZMJTUQMBZ\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

TFU@DPWFSDPWFSQMBZMJTU

^

^FMTF\

QMBZMJTUQBVTF

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^

^

We now use the JT@QMBZJOH method instead of the TUBUF. Let's also remove the

'JMF'JMUFS from the TIPX@PQFO@EJBMPH function because HTUSFBNFS supports more formats than just .1. And to be able to open them, we need to update the PQFO@CVUUPO

event handler:

TFMGUPPMCBSPQFO@CVUUPODPOOFDU@DMJDLFENPWF]@]\

MFUGJMFTIPX@PQFO@EJBMPHQBSFOU

JGMFU4PNFGJMFGJMF\

JGMFU4PNFFYUGJMFFYUFOTJPO\

NBUDIFYUUP@TUSVOXSBQ\

[ 229 ]





Implementing the Engine of the Music Player Chapter 6

NQ]PHH QMBZMJTUBEEGJMF

NV QMBZMJTUMPBEGJMF

FYUFOTJPO \

MFUEJBMPH.FTTBHF%JBMPHOFX4PNFQBSFOU

%JBMPH'MBHTFNQUZ.FTTBHF5ZQF&SSPS

#VUUPOT5ZQF0LGPSNBU$BOOPUPQFOGJMF

XJUIFYUFOTJPO\^FYUFOTJPO

EJBMPHSVO

EJBMPHEFTUSPZ

^

^

^

^

^

Here, we only added the PHH format, but you can also add other formats.

Summary

This chapter started by showing you how to decode MP3 data with the TJNQMFNBE crate.

You then learned how to write a music engine, this showed you how to use threads and different threading objects such as .VUFY, lock-free data structures, and condition variables.

You also learned how Rust can ensure thread safety. You also saw how to mutable the fields of a value when you have an immutable reference with interior mutability. During the whole chapter, we added the missing features to the music player such as play, pause, previous, and next song.

In the next chapter, we'll improve the modularity of the music player by rewriting it with the SFMN crate.

[ 230 ]





7

Music Player in a More Rusty

Way with Relm

In the previous chapter, we finished our music player. It is completely fine, but using HUL

ST directly in Rust can be error-prone. That's why we'll rewrite our music player using SFMN, an idiomatic GUI library for Rust. 3FMN is based on HULST, so the application will look the same at the end. However, the code will be cleaner and more declarative.

We will cover the following topics in this chapter: Relm

Relm widgets

Model-view-controller

Declarative view

Message passing





Music Player in a More Rusty Way with Relm Chapter 7

Reasons to use relm instead of gtk-rs

directly

As you have seen in the previous chapters, we used concepts that were not really obvious, and doing certain things that would normally be easy to do aren't that easy when using GTK+ with Rust. These are some of the many reasons to use SFMN.

State mutation

It might not be clear from the previous chapter, but we indirectly used 3D3FG$FMM5 to do state mutation. Indeed, our 1MBZMJTU type contains a 3FG$FMM0QUJPO4USJOH and we wrapped our 1MBZMJTU inside a reference-counted pointer. This was to be able to mutate the state in reaction to events, for instance playing the song when clicking the play button:

MFUQMBZMJTUTFMGQMBZMJTUDMPOF

MFUQMBZ@JNBHFTFMGUPPMCBSQMBZ@JNBHFDMPOF

MFUDPWFSTFMGDPWFSDMPOF

MFUTUBUFTFMGTUBUFDMPOF

TFMGUPPMCBSQMBZ@CVUUPODPOOFDU@DMJDLFENPWF]@]\

JGTUBUFMPDLVOXSBQTUPQQFE\

JGQMBZMJTUQMBZ\

TFU@JNBHF@JDPOQMBZ@JNBHF1"64&@*$0/

TFU@DPWFSDPWFSQMBZMJTU

^

^FMTF\

QMBZMJTUQBVTF

TFU@JNBHF@JDPOQMBZ@JNBHF1-":@*$0/

^

^

Having to use all these calls to DMPOF is cumbersome and using the 3FG$FMM5 type can lead to issues that are hard to debug in complex applications. The issue with this type is that the borrow checking happens at runtime. For instance, the following application: VTFTUEDFMM3FG$FMM

VTFTUEDPMMFDUJPOT)BTI.BQ

GONBJO\

MFUDFMM3FG$FMMOFX)BTI.BQOFX

DFMMCPSSPX@NVUJOTFSUPOF

MFUCPSSPXFE@DFMMDFMMCPSSPX

JGMFU4PNFLFZCPSSPXFE@DFMMHFUPOF\

[ 232 ]





Music Player in a More Rusty Way with Relm Chapter 7

DFMMCPSSPX@NVUJOTFSUUXP

^

^

Will panic:

UISFBE NBJO QBOJDLFEBU BMSFBEZCPSSPXFE#PSSPX.VU&SSPS

DIFDLPVUTSDMJCDPSFSFTVMUST

Even though it is obvious why it panics in this example (we called CPSSPX@NVU when the borrow was still alive in CPSSPXFE@DFMM), in more complex applications, it will be harder to understand why the panic happens, especially if we wrap the 3FG$FMM5 in an 3D and clone it everywhere. This brings us to the second issue with this type: using 3D5

encourages us to clone our data and share it too much which increases the coupling between our modules.

The SFMN crate takes a different approach: widgets owns their data and the different widgets communicate between them using message passing.

Asynchronous user interface

Another common issue when creating user interfaces is that we might want to perform an action that might take time (such as a network request) without freezing the UI. By being based on UPLJP, an asynchronous I/O framework for Rust, SFMN allows you to easily program graphical user interfaces that can perform network requests without freezing the interface itself.

Creating custom widgets

In object-oriented languages, it is very easy to create new widgets and use them like built-in widgets. In this paradigm, you only need to create a new class that inherits from a widget and that's it.

In $IBQUFS, Creating a Music Player, we created custom widgets, such as 1MBZMJTU and

.VTJD5PPMCBS, but we needed to create a function to get the real GTK+ widget: QVCGOWJFXTFMG 5SFF7JFX\

TFMGUSFFWJFX

^

[ 233 ]





Music Player in a More Rusty Way with Relm

Chapter 7

An alternative would have been to implement the %FSFG trait: VTFTUEPQT%FSFG

JNQM%FSFGGPS1MBZMJTU\

UZQF5BSHFU5SFF7JFX

GOEFSFGTFMG 5SFF7JFX\

TFMGUSFFWJFX

^

^

That implementation would allow us to add the widget to its QBSFOU like this: QBSFOUBEEQMBZMJTU

(Note the leading in front of QMBZMJTU which is the call to EFSFG.) Instead of adding it in the following way:

QBSFOUBEEQMBZMJTUWJFX

But it is still different than when using normal HUL widgets.

3FMN solves all of these issues. Let's start using this crate.

Creating a window with relm

First of all, we'll use the nightly version of the Rust compiler.

While using this nightly version is not strictly necessary to use SFMN, it provides a syntax that is a bit nicer using a feature that is only available on this version.

That will be a good opportunity to learn how to install a different version of the compiler.

Nightly is the unstable version of Rust; it's a version that is compiled almost every day.

Some unstable features of Rust are only available on nightly. But, don't worry, we'll also see how to use SFMN on the stable version of Rust.

[ 234 ]





Music Player in a More Rusty Way with Relm Chapter 7

Installing Rust nightly

With SVTUVQ, the tool we installed in $IBQUFS, Basics of Rust, it is very easy to install nightly:

rustup default nightly

Running this command will install the nightly version of the tools (DBSHP, SVTUD, and so on). Also, it will switch the corresponding commands to use the nightly version.

If you want to go back to the stable version, issue the following command: rustup default stable

The nightly version is updated very frequently, so you might want to update it every week or more often. To do so, you need to run this command: rustup update

This will also update the stable version if a new version was released (one stable version is released every 6 weeks).

Now that we are using Rust nightly, we're ready to create a OFX project: cargo new rusic-relm --bin

Add the following dependencies in the $BSHPUPNM file:

<EFQFOEFODJFT>

HUL?

HULTZT?

SFMN?

SFMNBUUSJCVUFT?

SFMNEFSJWF?

We still need HUL because SFMN is based on it. Let's add the corresponding FYUFSODSBUF

statements:

<GFBUVSFQSPD@NBDSP>

FYUFSODSBUFHUL

FYUFSODSBUFHUL@TZT

<NBDSP@VTF>

FYUFSODSBUFSFMN

FYUFSODSBUFSFMN@BUUSJCVUFT

<NBDSP@VTF>

FYUFSODSBUFSFMN@EFSJWF

[ 235 ]





Music Player in a More Rusty Way with Relm Chapter 7

SFMN provides some macros, that's why we needed to add <NBDSP@VTF>. We'll start slowly by creating a simple window with SFMN.

Widget

This crate is centered around the concept of widgets, which are different than the HUL

widgets. In SFMN, a widget is composed of a view, a model, and a method to update the model in reaction to events. The concept of widget is implemented by a trait in SFMN: the 8JEHFU trait.

Model

We'll start with an empty model and we'll populate it later in this chapter: QVCTUSVDU.PEFM\

^

As you can see, a model can be a simple structure. It could also be if your widget don't need a model. Actually, it can be any type you want.

Besides the model, a widget needs to know the initial value of its model. To specify what it is, we need to implement the NPEFM method of the 8JEHFU trait:

<XJEHFU>

JNQM8JEHFUGPS"QQ\

GONPEFM .PEFM\

.PEFM\

^

^

d

^

Here, we use the <XJEHFU> attribute provided by the SFMN@BUUSJCVUFT crate. Attributes are currently an unstable feature of the language, that's why we use nightly. We'll see in the section about the declarative view why this attribute is needed. So, let's go back to our NPEFM model, we only return .PEFM\^ for now as our model does not contain any data.

Other methods are needed for this trait, so this implementation is incomplete for now.

[ 236 ]





Music Player in a More Rusty Way with Relm Chapter 7

Messages

3FMN widgets communicate by sending messages to other widgets, but also to themselves.

For instance, when the EFMFUF@FWFOU signal is emitted, we can emit the 2VJU message to our widget and take appropriate action when we receive this message. A message is modeled as an FOVN using the custom derive .TH that is specific to SFMN:

<EFSJWF.TH>

QVCFOVN.TH\

2VJU

^

This custom derive is provided by the SFMN@EFSJWF crate.

View

Views are created in a declarative way in SFMN as a part of the 8JEHFU trait: VTFHUL\

(UL8JOEPX&YU

*OIJCJU

8JEHFU&YU

^

VTFSFMN8JEHFU

VTFSFMN@BUUSJCVUFTXJEHFU

VTFTFMG.TH

<XJEHFU>

JNQM8JEHFUGPS"QQ\

d

WJFX\

HUL8JOEPX\

UJUMF3VTJD

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

^

^

^

[ 237 ]





Music Player in a More Rusty Way with Relm

Chapter 7

We first imported some stuff from the HUL crate. Then we imported the 8JEHFU trait from SFMN and the XJEHFU attribute. Later, we imported the variant of our FOVN.TH because we use it in this code. To declare the view, we use the WJFX macro. This macro is very particular, it is not a macro that is declared as NBDSP@SVMFT, as we saw in $IBQUFS, Basics of Rust. Instead, it is parsed by the procedural macro implementing the <XJEHFU> attribute in order to provide a syntax that is not allowed in Rust.

To declare our view, we first specify the name of the HUL8JOEPX widget.

We cannot import HUL8JOEPX to be able to use only 8JOEPX in the declaration of the view.

After that, we use curly brackets and inside them, we specify the properties and events handled by the widget.

Properties

Here, we declare that the UJUMF property is 3VTJD. So we transformed the TFU@UJUMF call from HUL to the UJUMF property, only the part after TFU@ is needed.

Actually, SFMN will convert the property (UJUMF3VTJD) to the TFU@UJUMF3VTJD call, as we'll see later.

Events

The syntax of the event handler is a bit special:

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

First, we only need to write EFMFUF@FWFOU@@ instead of DPOOFDU@EFMFUF@FWFOUNPWF]@@]\^. If we needed the arguments of the signal, we could have written the name of an identifier instead of using underscores (@). On the right side of the fat arrow ( ), we specify two things between parentheses and separated by a comma. First, there's 2VJU, which is the message that will be sent to the current widget when the event is emitted. And second is the value to return to the HUL callback. Here, we return *OIJCJUGBMTF to specify that we don't want to prevent the default event handler from running.

[ 238 ]





Music Player in a More Rusty Way with Relm Chapter 7

Code generation

The code generated by the attribute is a normal Rust method that looks like: GOWJFXSFMN3FMN4FMG NPEFM4FMG.PEFM 4FMG\

5IJTNFUIPEEPFTOPUBDUVBMMZFYJTUCVUSFMNEJSFDUMZDSFBUF

BXJOEPXVTJOHUIFGVODUJPOTGSPNUIFTZTDSBUFT

MFUXJOEPXHUL8JOEPXOFX

XJOEPXTFU@UJUMF3VTJD

XJOEPXTIPX

DPOOFDUSFMNXJOEPXDPOOFDU@EFMFUF@FWFOU@@SFUVSO

4PNF2VJU*OIJCJUGBMTF

8JO\

NPEFM

XJOEPXXJOEPX

^

^

Update function

The only remaining required method of the 8JEHFU trait is VQEBUF. In this method, we'll manage the 2VJU message:

<XJEHFU>

JNQM8JEHFUGPS"QQ\

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

2VJU HULNBJO@RVJU

^

^

d

^

Here, we specify that when we receive the 2VJU message, we call HULNBJO@RVJU, which is a function similar to "QQMJDBUJPORVJU that we used in $IBQUFS, Creating a Music Player.

It should be noted that the <XJEHFU> attribute will also generate the "QQ structure that will contain the widgets and the model.

[ 239 ]





Music Player in a More Rusty Way with Relm Chapter 7

We can finally show this window by calling its SVO method in the NBJO function: GONBJO\

"QQSVOVOXSBQ

^

Later, we'll see why we need to specify as a parameter to SVO.

Adding child widgets

We saw the basics of how to create a widget with relm. Now, let's continue the creation of our user interface. We'll start by adding the toolbar. Besides specifying properties and signals in the WJFX macro, we can also nest widgets in order to add a child to a container.

So, to add HUL#PY as a child of our window, we simply need to nest the former inside the latter:

WJFX\

HUL8JOEPX\

UJUMF3VTJD

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

HUL#PY\

^

^

^

And to add a toolbar to the HUL#PY, we create a new level of nesting: WJFX\

HUL8JOEPX\

UJUMF3VTJD

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

HUL#PY\

PSJFOUBUJPO7FSUJDBM

<OBNFUPPMCBS>

HUL5PPMCBS\

^

^

^

^

Here, we can see that there's an attribute: the <OBNF> attribute gives a name to a widget which will allow us to access this widget by the specified identifier, as we'll see later. We'll encounter other attributes in the rest of this chapter.

[ 240 ]

Music Player in a More Rusty Way with Relm Chapter 7

We'll add an attribute to our model to keep the image to be shown on the play/pause button:

VTFHUL*NBHF

QVCDPOTU1"64&@*$0/TUSHULNFEJBQBVTF

QVCDPOTU1-":@*$0/TUSHULNFEJBQMBZ

QVCTUSVDU.PEFM\

QMBZ@JNBHF*NBHF

^

We also added the constants for the name of the images representing the state of the button.

We need to update the NPEFM method to specify this new field: GONPEFM .PEFM\

.PEFM\

QMBZ@JNBHFOFX@JDPO1-":@*$0/

^

^

This uses the following function to create an image: GOOFX@JDPOJDPOTUS *NBHF\

*NBHFOFX@GSPN@GJMFGPSNBUBTTFUT\^QOHJDPO

^

Let's add the items to the toolbar:

VTFHUL\

0SJFOUBCMF&YU

5PPM#VUUPO&YU

^

VTFHUL0SJFOUBUJPO7FSUJDBM

WJFX\

HUL8JOEPX\

UJUMF3VTJD

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

HUL#PY\

PSJFOUBUJPO7FSUJDBM

<OBNFUPPMCBS>

HUL5PPMCBS\

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOEPDVNFOUPQFO

DMJDLFE 0QFO

^

HUL5PPM#VUUPO\

[ 241 ]

Music Player in a More Rusty Way with Relm Chapter 7

JDPO@XJEHFUOFX@JDPOEPDVNFOUTBWF

DMJDLFE 4BWF

^

HUL4FQBSBUPS5PPM*UFN\

^

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOHULNFEJBQSFWJPVT

^

HUL5PPM#VUUPO\

JDPO@XJEHFUTFMGNPEFMQMBZ@JNBHF

DMJDLFE 1MBZ1BVTF

^

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOHULNFEJBTUPQ

DMJDLFE 4UPQ

^

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOHULNFEJBOFYU

^

HUL4FQBSBUPS5PPM*UFN\

^

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOSFNPWF

^

HUL4FQBSBUPS5PPM*UFN\

^

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOHULRVJU

DMJDLFE 2VJU

^

^

^

^

^

Here, there's no new syntax shown. Take note that we can specify function calls as well as model attributes in the value of a property. We needed to put a before OFX@JDPO

because the code is translated as such:

UPPM@CVUUPOTFU@JDPO@XJEHFUOFX@JDPOHULRVJU

And this TFU@JDPO@XJEHFU method requires something that can be converted into an 0QUJPO1 where 1 is a widget. It requires a reference, so we give it a reference.

[ 242 ]





Music Player in a More Rusty Way with Relm Chapter 7

One-way data binding

Setting a property from a model attribute is very frequent in relm and it actually creates a one-way bond between the model attribute and the property. This means that when the attribute is updated, the widget property will be updated as well. There are some restrictions to this feature though:

Only an assignment to a model attribute will update the property.

This assignment must be inside an implementation decorated with the

<XJEHFU> attribute.

These restrictions come from the fact that SFMN only analyzes the source code decorated by this attribute. And it only considers assignment to be an update of the model data.

This might require changing some code. For instance, the following code will not trigger a property update:

TFMGNPEFMTUSJOHQVTI@TUSTUSJOH

You can rewrite it this way in order for SFMN to consider it an update: TFMGNPEFMTUSJOHTUSJOH

As you can see, SFMN recognizes not only the assignment, but also the assignments using an operator such as .

We used many new messages in the previous code, so let's update our enumeration accordingly:

<EFSJWF.TH>

QVCFOVN.TH\

0QFO

1MBZ1BVTF

2VJU

4BWF

4UPQ

^

[ 243 ]





Music Player in a More Rusty Way with Relm Chapter 7

We also need to change the VQEBUF method to consider these new messages: GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

0QFO

1MBZ1BVTF

2VJU HULNBJO@RVJU

4BWF

4UPQ

^

^

For now, since we only code the interface, we do nothing when we receive these messages.

Post-initialization of the view

If you run the application, you'll see that the images are not shown on the toolbar buttons.

This is because of the way SFMN works. When it generates the code, it calls the TIPX

method on every widget, instead of TIPX@BMM. So, the toolbar and the tool buttons will be shown, but not the images, as they are only attributes of the buttons, they are not created using the widget syntax. To solve this issue, we'll call TIPX@BMM on the toolbar in the JOJU@WJFX method:

<XJEHFU>

JNQM8JEHFUGPS"QQ\

GOJOJU@WJFXNVUTFMG\

TFMGUPPMCBSTIPX@BMM

^

d

^

That's why we gave a name to the toolbar widget earlier: we needed to call a method on this widget here. The JOJU@WJFX method is called after the WJFX is created. This is useful to execute some code to customize the view when it's not possible to do so using the WJFX

syntax. If you run the application again, you'll see that the buttons now have an image.

Let's now add the cover image widget and the cursor widget. For the image, we'll need to add a new crate to $BSHPUPNM:

<EFQFOEFODJFT>

HELQJYCVG?

[ 244 ]

Music Player in a More Rusty Way with Relm Chapter 7

Let's also add the corresponding FYUFSODSBUF statement: FYUFSODSBUFHEL@QJYCVG

We also need new import statements:

VTFHEL@QJYCVG1JYCVG

VTFHUL\

"EKVTUNFOU

#PY&YU

*NBHF&YU

-BCFM&YU

4DBMF&YU

^

VTFHUL0SJFOUBUJPO)PSJ[POUBM

Let's add a couple of new fields to our .PEFM:

QVCTUSVDU.PEFM\

BEKVTUNFOU"EKVTUNFOU

DPWFS@QJYCVG0QUJPO1JYCVG

DPWFS@WJTJCMFCPPM

DVSSFOU@EVSBUJPOV

DVSSFOU@UJNFV

QMBZ@JNBHF*NBHF

^

Most of the new fields existed in the application we developed in the two previous chapters. The DPWFS@WJTJCMF attribute is new, though. We'll use it to know whether we should show the image of the cover. Don't forget to update the initialization of the model: GONPEFM .PEFM\

.PEFM\

BEKVTUNFOU"EKVTUNFOUOFX

DPWFS@QJYCVG/POF

DPWFS@WJTJCMFGBMTF

DVSSFOU@EVSBUJPO

DVSSFOU@UJNF

QMBZ@JNBHFOFX@JDPO1-":@*$0/

^

^

[ 245 ]

Music Player in a More Rusty Way with Relm Chapter 7

We can now add the *NBHF after the 5PPMCBS widget: HUL*NBHF\

GSPN@QJYCVGTFMGNPEFMDPWFS@QJYCVGBT@SFG

WJTJCMFTFMGNPEFMDPWFS@WJTJCMF

^

Here, we call BT@SFG on the DPWFS@QJYCVG attribute, because, once again, the method (TFU@GSPN@QJYCVG) requires something that can be converted into a 0QUJPO1JYCVG .

We also specify that the WJTJCMF property of the image is bound to the DPWFS@WJTJCMF model attribute. This means that we'll be able to hide the image by setting this attribute to GBMTF.

We'll then add the cursor, which will give us the following view: WJFX\

HUL8JOEPX\

UJUMF3VTJD

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

HUL#PY\

PSJFOUBUJPO7FSUJDBM

<OBNFUPPMCBS>

HUL5PPMCBS\

d

^

HUL*NBHF\

GSPN@QJYCVGTFMGNPEFMDPWFS@QJYCVGBT@SFG

WJTJCMFTFMGNPEFMDPWFS@WJTJCMF

^

HUL#PY\

PSJFOUBUJPO)PSJ[POUBM

TQBDJOH

HUL4DBMF)PSJ[POUBMTFMGNPEFMBEKVTUNFOU\

ESBX@WBMVFGBMTF

IFYQBOEUSVF

^

HUL-BCFM\

UFYU

NJMMJT@UP@NJOVUFTTFMGNPEFMDVSSFOU@UJNF

^

HUL-BCFM\

UFYU

^

HUL-BCFM\

NBSHJO@SJHIU

UFYU

NJMMJT@UP@NJOVUFTTFMGNPEFMDVSSFOU@EVSBUJPO

[ 246 ]

Music Player in a More Rusty Way with Relm Chapter 7

^

^

^

^

^

This require the following method, which we saw in the previous chapter: GONJMMJT@UP@NJOVUFTNJMMJTV 4USJOH\

MFUNVUTFDPOETNJMMJT@

MFUNJOVUFTTFDPOET

TFDPOET

GPSNBU\^\^NJOVUFTTFDPOET

^

We used another way to create a widget:

HUL4DBMF)PSJ[POUBMTFMGNPEFMBEKVTUNFOU\

ESBX@WBMVFGBMTF

IFYQBOEUSVF

^

This syntax will call the constructor of the widget, like so: HUL4DBMFOFX)PSJ[POUBMTFMGNPEFMBEKVTUNFOU

We could also have used the traditional syntax to create a widget: VTFHUL3BOHF&YU

HUL4DBMF\

BEKVTUNFOUTFMGNPEFMBEKVTUNFOU

PSJFOUBUJPO)PSJ[POUBM

ESBX@WBMVFGBMTF

IFYQBOEUSVF

^

These are just two ways to do the same thing.

[ 247 ]





Music Player in a More Rusty Way with Relm Chapter 7

Dialogs

For the open and save dialog, we'll use the same functions as in the previous chapter: VTFTUEQBUI1BUI#VG

VTFHUL\'JMF$IPPTFS"DUJPO'JMF$IPPTFS%JBMPH'JMF'JMUFS^

VTFHUL@TZT\(5,@3&410/4&@"$$&15(5,@3&410/4&@$"/$&-^

DPOTU3&410/4&@"$$&15J(5,@3&410/4&@"$$&15BTJ

DPOTU3&410/4&@$"/$&-J(5,@3&410/4&@$"/$&-BTJ

GOTIPX@PQFO@EJBMPHQBSFOU8JOEPX 0QUJPO1BUI#VG \

MFUNVUGJMF/POF

MFUEJBMPH'JMF$IPPTFS%JBMPHOFX4PNF4FMFDUBO.1BVEJP

GJMF

4PNFQBSFOU'JMF$IPPTFS"DUJPO0QFO

MFUNQ@GJMUFS'JMF'JMUFSOFX

NQ@GJMUFSBEE@NJNF@UZQFBVEJPNQ

NQ@GJMUFSTFU@OBNF.1BVEJPGJMF

EJBMPHBEE@GJMUFSNQ@GJMUFS

MFUNV@GJMUFS'JMF'JMUFSOFX

NV@GJMUFSBEE@NJNF@UZQFBVEJPYNQFHVSM

NV@GJMUFSTFU@OBNF.6QMBZMJTUGJMF

EJBMPHBEE@GJMUFSNV@GJMUFS

EJBMPHBEE@CVUUPO$BODFM3&410/4&@$"/$&-

EJBMPHBEE@CVUUPO"DDFQU3&410/4&@"$$&15

MFUSFTVMUEJBMPHSVO

JGSFTVMU3&410/4&@"$$&15\

GJMFEJBMPHHFU@GJMFOBNF

^

EJBMPHEFTUSPZ

GJMF

^

GOTIPX@TBWF@EJBMPHQBSFOU8JOEPX 0QUJPO1BUI#VG \

MFUNVUGJMF/POF

MFUEJBMPH'JMF$IPPTFS%JBMPHOFX4PNF$IPPTFBEFTUJOBUJPO

.6QMBZMJTU

GJMF4PNFQBSFOU'JMF$IPPTFS"DUJPO4BWF

MFUGJMUFS'JMF'JMUFSOFX

GJMUFSBEE@NJNF@UZQFBVEJPYNQFHVSM

GJMUFSTFU@OBNF.6QMBZMJTUGJMF

EJBMPHTFU@EP@PWFSXSJUF@DPOGJSNBUJPOUSVF

[ 248 ]

Music Player in a More Rusty Way with Relm Chapter 7

EJBMPHBEE@GJMUFSGJMUFS

EJBMPHBEE@CVUUPO$BODFM3&410/4&@$"/$&-

EJBMPHBEE@CVUUPO4BWF3&410/4&@"$$&15

MFUSFTVMUEJBMPHSVO

JGSFTVMU3&410/4&@"$$&15\

GJMFEJBMPHHFU@GJMFOBNF

^

EJBMPHEFTUSPZ

GJMF

^

But this time, we'll put the code for the open action in a method on the "QQ widget: VTFHUL\#VUUPOT5ZQF%JBMPH'MBHT.FTTBHF%JBMPH.FTTBHF5ZQF^

JNQM"QQ\

GOPQFOTFMG\

MFUGJMFTIPX@PQFO@EJBMPHTFMGXJOEPX

JGMFU4PNFGJMFGJMF\

MFUFYUGJMFFYUFOTJPONBQ]FYU]

FYUUP@TUSVOXSBQUP@TUSJOH

JGMFU4PNFFYUFYU\

NBUDIFYUBT@TUS\

NQ

NV

FYUFOTJPO \

MFUEJBMPH

.FTTBHF%JBMPHOFX4PNFTFMGXJOEPX

%JBMPH'MBHTFNQUZ.FTTBHF5ZQF&SSPS

#VUUPOT5ZQF0LGPSNBU$BOOPUPQFOGJMF

XJUIFYUFOTJPO\^FYUFOTJPO

EJBMPHSVO

EJBMPHEFTUSPZ

^

^

^

^

^

^

[ 249 ]





Music Player in a More Rusty Way with Relm Chapter 7

We can then call these functions in the VQEBUF method: GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

0QFO TFMGPQFO

1MBZ1BVTF

2VJU HULNBJO@RVJU

4BWF TIPX@TBWF@EJBMPHTFMGXJOEPX

4UPQ

^

^

Let's manage some of the other actions.

Other methods

This will require two new methods in the JNQM8JEHFU:

<XJEHFU>

JNQM8JEHFUGPS"QQ\

d

GOTFU@DVSSFOU@UJNFNVUTFMGUJNFV\

TFMGNPEFMDVSSFOU@UJNFUJNF

TFMGNPEFMBEKVTUNFOUTFU@WBMVFUJNFBTG

^

GOTFU@QMBZ@JDPOTFMGJDPOTUS\

TFMGNPEFMQMBZ@JNBHFTFU@GSPN@GJMFGPSNBUBTTFUT\^QOH

JDPO

^

^

But these methods have nothing to do with a 8JEHFU, so why are we allowed to add DVTUPN methods in a trait implementation? Well, the <XJEHFU> attribute will take these methods and move them to a separate JNQM"QQ where they belong. But why do we want to do this instead of placing them ourselves? That's because SFMN analyzes the assignments to the model attributes in the methods in the implementation decorated by the <XJEHFU> attribute. As we saw earlier, an assignment to a model field will automatically update the view. If we placed these methods in a separate JNQM"QQ, SFMN would have been unable to analyze these methods and generate the code to automatically update the view.

[ 250 ]

Music Player in a More Rusty Way with Relm Chapter 7

This is a frequent mistake, if your view is not updating when you're assigning to a model attribute, it's probably because your assignment is not within an implementation decorated by the <XJEHFU> attribute.

We also need a new attribute for our model:

QVCTUSVDU.PEFM\

BEKVTUNFOU"EKVTUNFOU

DPWFS@QJYCVG0QUJPO1JYCVG

DPWFS@WJTJCMFCPPM

DVSSFOU@EVSBUJPOV

DVSSFOU@UJNFV

QMBZ@JNBHF*NBHF

TUPQQFECPPM

^

We added a TUPQQFE attribute that we also need to add in the model initialization: GONPEFM .PEFM\

.PEFM\

BEKVTUNFOU"EKVTUNFOUOFX

DPWFS@QJYCVG/POF

DPWFS@WJTJCMFGBMTF

DVSSFOU@EVSBUJPO

DVSSFOU@UJNF

QMBZ@JNBHFOFX@JDPO1-":@*$0/

TUPQQFEUSVF

^

^

We can now change the VQEBUF method to use these new methods: GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

0QFO TFMGPQFO

1MBZ1BVTF \

JGTFMGNPEFMTUPQQFE\

TFMGTFU@QMBZ@JDPO1-":@*$0/

^

^

2VJU HULNBJO@RVJU

4BWF TIPX@TBWF@EJBMPHTFMGXJOEPX

4UPQ \

TFMGTFU@DVSSFOU@UJNF

TFMGNPEFMDVSSFOU@EVSBUJPO

TFMGNPEFMDPWFS@WJTJCMFGBMTF

TFMGTFU@QMBZ@JDPO1-":@*$0/

[ 251 ]





Music Player in a More Rusty Way with Relm Chapter 7

^

^

^

The VQEBUF method receives TFMG by a mutable reference, which allows us to update the model attributes.

Playlist

We're now ready to create a new widget: the playlist. We'll need the following new EFQFOEFODJFT:

<EFQFOEFODJFT>

JE?

NV?

Add their corresponding FYUFSODSBUF statements:

FYUFSODSBUFJE

FYUFSODSBUFNV

Let's create a new module for our QMBZMJTU:

NPEQMBZMJTU

In the TSDQMBZMJTUST file, we start by creating our model: VTFHUL-JTU4UPSF

QVCTUSVDU.PEFM\

DVSSFOU@TPOH0QUJPO4USJOH

NPEFM-JTU4UPSF

SFMN3FMN1MBZMJTU

^

The 3FMN type comes from the SFMN crate:

VTFSFMN3FMN

[ 252 ]





Music Player in a More Rusty Way with Relm Chapter 7

It is useful to send messages to a widget. We'll learn more about that in the section about widget communication. Let's add the model initialization function: VTFHEL@QJYCVG1JYCVG

VTFHUL\4UBUJD5ZQF5ZQF^

<XJEHFU>

JNQM8JEHFUGPS1MBZMJTU\

GONPEFMSFMN3FMN4FMG @ .PEFM\

.PEFM\

DVSSFOU@TPOH/POF

NPEFM-JTU4UPSFOFX<

1JYCVGTUBUJD@UZQF

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

1JYCVGTUBUJD@UZQF

>

SFMNSFMNDMPOF

^

^

^

Here, we notice that we use a different signature for the NPEFM method. How is this possible? The method of the trait cannot change, right? It is another convenience brought by the <XJEHFU> crate. In many cases, we don't need these parameters, so they are automatically added if they are needed. The first parameter is SFMN and we save a copy of it in the model. The second parameter is the model initialization parameter. The -JTU4UPSF is the same as in $IBQUFS, Creating a Music Player, we only save it in our model because we'll need it later.

Model parameter

Let's talk more about this second parameter. It could be used to send data to the widget when we create it. Remember when we called SVO:

"QQSVOVOXSBQ

[ 253 ]

Music Player in a More Rusty Way with Relm Chapter 7

Here, we specified as the model parameter because we don't need one. But we could have used a different value, such as , and this value would have been received in the second parameter of the NPEFM method.

We're now ready to create the view:

VTFHUL

VTFHUL\5SFF7JFX&YU8JEHFU&YU^

VTFSFMN8JEHFU

VTFSFMN@BUUSJCVUFTXJEHFU

<XJEHFU>

JNQM8JEHFUGPS1MBZMJTU\

d

WJFX\

<OBNFUSFFWJFX>

HUL5SFF7JFX\

IFYQBOEUSVF

NPEFMTFMGNPEFMNPEFM

WFYQBOEUSVF

^

^

^

It is really simple: we give it a name and set both the IFYQBOE and WFYQBOE properties to USVF and we bind the NPEFM property with our -JTU4UPSF.

Let's create an empty VQEBUF method for now:

<XJEHFU>

JNQM8JEHFUGPS1MBZMJTU\

d

GOVQEBUFNVUTFMGFWFOU.TH\

^

^

We'll see the .TH type later. We'll now add the columns exactly like we did it in $IBQUFS

, Creating a Music Player. Let's copy the following enumeration and constants: VTFTFMG7JTJCJMJUZ

<EFSJWF1BSUJBM&R>

FOVN7JTJCJMJUZ\

*OWJTJCMF

7JTJCMF

[ 254 ]

Music Player in a More Rusty Way with Relm Chapter 7

^

DPOTU5)6.#/"*-@$0-6./V

DPOTU5*5-&@$0-6./V

DPOTU"35*45@$0-6./V

DPOTU"-#6.@$0-6./V

DPOTU(&/3&@$0-6./V

DPOTU:&"3@$0-6./V

DPOTU53"$,@$0-6./V

DPOTU1"5)@$0-6./V

DPOTU1*9#6'@$0-6./V

And let's add new methods to the 1BZMJTU:

JNQM1MBZMJTU\

GOBEE@QJYCVG@DPMVNOTFMGDPMVNOJWJTJCJMJUZ

7JTJCJMJUZ\

MFUWJFX@DPMVNO5SFF7JFX$PMVNOOFX

JGWJTJCJMJUZ7JTJCMF\

MFUDFMM$FMM3FOEFSFS1JYCVGOFX

WJFX@DPMVNOQBDL@TUBSUDFMMUSVF

WJFX@DPMVNOBEE@BUUSJCVUFDFMMQJYCVGDPMVNO

^

TFMGUSFFWJFXBQQFOE@DPMVNOWJFX@DPMVNO

^

GOBEE@UFYU@DPMVNOTFMGUJUMFTUSDPMVNOJ\

MFUWJFX@DPMVNO5SFF7JFX$PMVNOOFX

WJFX@DPMVNOTFU@UJUMFUJUMF

MFUDFMM$FMM3FOEFSFS5FYUOFX

WJFX@DPMVNOTFU@FYQBOEUSVF

WJFX@DPMVNOQBDL@TUBSUDFMMUSVF

WJFX@DPMVNOBEE@BUUSJCVUFDFMMUFYUDPMVNO

TFMGUSFFWJFXBQQFOE@DPMVNOWJFX@DPMVNO

^

GODSFBUF@DPMVNOTTFMG\

TFMGBEE@QJYCVG@DPMVNO5)6.#/"*-@$0-6./BTJ7JTJCMF

TFMGBEE@UFYU@DPMVNO5JUMF5*5-&@$0-6./BTJ

TFMGBEE@UFYU@DPMVNO"SUJTU"35*45@$0-6./BTJ

TFMGBEE@UFYU@DPMVNO"MCVN"-#6.@$0-6./BTJ

TFMGBEE@UFYU@DPMVNO(FOSF(&/3&@$0-6./BTJ

TFMGBEE@UFYU@DPMVNO:FBS:&"3@$0-6./BTJ

TFMGBEE@UFYU@DPMVNO5SBDL53"$,@$0-6./BTJ

TFMGBEE@QJYCVG@DPMVNO1*9#6'@$0-6./BTJ*OWJTJCMF

^

^

[ 255 ]

Music Player in a More Rusty Way with Relm Chapter 7

The difference from these functions in $IBQUFS, Creating a Music Player is that here, we have direct access to the USFFWJFX as an attribute. This requires new import statements: VTFHUL\

$FMM-BZPVU&YU

$FMM3FOEFSFS1JYCVG

$FMM3FOEFSFS5FYU

5SFF7JFX$PMVNO

5SFF7JFX$PMVNO&YU

5SFF7JFX&YU

^

We'll now call the DSFBUF@DPMVNOT method in the JOJU@WJFX method:

<XJEHFU>

JNQM8JEHFUGPS1MBZMJTU\

GOJOJU@WJFXNVUTFMG\

TFMGDSFBUF@DPMVNOT

^

d

^

Let's start interacting with the playlist. We'll create a method to add a song to the playlist: VTFTUEQBUI1BUI

VTFHUL\-JTU4UPSF&YU-JTU4UPSF&YU.BOVBM5P7BMVF^

VTFJE5BH

JNQM1MBZMJTU\

GOBEETFMGQBUI1BUI\

MFUGJMFOBNF

QBUIGJMF@TUFNVOXSBQ@PS@EFGBVMUUP@TUSVOXSBQ@PS@EFGBVMU

MFUSPXTFMGNPEFMNPEFMBQQFOE

JGMFU0LUBH5BHSFBE@GSPN@QBUIQBUI\

MFUUJUMFUBHUJUMFVOXSBQ@PSGJMFOBNF

MFUBSUJTUUBHBSUJTUVOXSBQ@PSOPBSUJTU

MFUBMCVNUBHBMCVNVOXSBQ@PSOPBMCVN

MFUHFOSFUBHHFOSFVOXSBQ@PSOPHFOSF

MFUZFBSUBHZFBSNBQ]ZFBS]

ZFBSUP@TUSJOHVOXSBQ@PSOPZFBSUP@TUSJOH

MFUUSBDLUBHUSBDLNBQ]USBDL]

USBDLUP@TUSJOHVOXSBQ@PSUP@TUSJOH

MFUUPUBM@USBDLT

UBHUPUBM@USBDLTNBQ]UPUBM@USBDLT]

[ 256 ]

Music Player in a More Rusty Way with Relm Chapter 7

UPUBM@USBDLTUP@TUSJOHVOXSBQ@PSUP@TUSJOH

MFUUSBDL@WBMVFGPSNBU\^\^USBDL

UPUBM@USBDLT

TFMGTFU@QJYCVGSPXUBH

TFMGNPEFMNPEFMTFU@WBMVFSPX5*5-&@$0-6./

UJUMFUP@WBMVF

TFMGNPEFMNPEFMTFU@WBMVFSPX"35*45@$0-6./

BSUJTUUP@WBMVF

TFMGNPEFMNPEFMTFU@WBMVFSPX"-#6.@$0-6./

BMCVNUP@WBMVF

TFMGNPEFMNPEFMTFU@WBMVFSPX(&/3&@$0-6./

HFOSFUP@WBMVF

TFMGNPEFMNPEFMTFU@WBMVFSPX:&"3@$0-6./

ZFBSUP@WBMVF

TFMGNPEFMNPEFMTFU@WBMVFSPX53"$,@$0-6./

USBDL@WBMVFUP@WBMVF

^

FMTF\

TFMGNPEFMNPEFMTFU@WBMVFSPX5*5-&@$0-6./

GJMFOBNFUP@WBMVF

^

MFUQBUIQBUIUP@TUSVOXSBQ@PS@EFGBVMU

TFMGNPEFMNPEFMTFU@WBMVFSPX1"5)@$0-6./

QBUIUP@WBMVF

^

^

This calls the TFU@QJYCVG method, so let's define it: VTFHEL@QJYCVG\*OUFSQ5ZQF1JYCVG-PBEFS^

VTFHUL5SFF*UFS

DPOTU*/5&31@):1&3*OUFSQ5ZQF

DPOTU*."(&@4*;&J

DPOTU5)6.#/"*-@4*;&J

GOTFU@QJYCVGTFMGSPX5SFF*UFSUBH5BH\

JGMFU4PNFQJDUVSFUBHQJDUVSFTOFYU\

MFUQJYCVG@MPBEFS1JYCVG-PBEFSOFX

QJYCVG@MPBEFSTFU@TJ[F*."(&@4*;&*."(&@4*;& QJYCVG@MPBEFSMPBEFS@XSJUFQJDUVSFEBUBVOXSBQ

JGMFU4PNFQJYCVGQJYCVG@MPBEFSHFU@QJYCVG\

MFUUIVNCOBJMQJYCVGTDBMF@TJNQMF5)6.#/"*-@4*;& 5)6.#/"*-@4*;&*/5&31@):1&3VOXSBQ

[ 257 ]

Music Player in a More Rusty Way with Relm Chapter 7

TFMGNPEFMNPEFMTFU@WBMVFSPX5)6.#/"*-@$0-6./

UIVNCOBJMUP@WBMVF

TFMGNPEFMNPEFMTFU@WBMVFSPX1*9#6'@$0-6./

QJYCVGUP@WBMVF

^

QJYCVG@MPBEFSDMPTFVOXSBQ

^

^

It is very similar to the one created in $IBQUFS, Creating a Music Player. This method will be called when we receive the "EE4POHQBUI message, so let's now create our message type:

VTFTUEQBUI1BUI#VG

VTFTFMG.TH

<EFSJWF.TH>

QVCFOVN.TH\

"EE4POH1BUI#VG

-PBE4POH1BUI#VG

/FYU4POH

1BVTF4POH

1MBZ4POH

1SFWJPVT4POH

3FNPWF4POH

4BWF4POH1BUI#VG

4POH4UBSUFE0QUJPO1JYCVG

4UPQ4POH

^

And let's modify the VQEBUF method accordingly:

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

"EE4POHQBUI TFMGBEEQBUI

-PBE4POHQBUI

/FYU4POH

1BVTF4POH

1MBZ4POH

1SFWJPVT4POH

3FNPWF4POH

4BWF4POHQBUI

4POH4UBSUFE@

4UPQ4POH

^

^

[ 258 ]





Music Player in a More Rusty Way with Relm Chapter 7

Here, we call the method BEE when we receive the "EE4POH message. But where is this message emitted? Well, it will be emitted by the "QQ type, when the user requests to open a file. It is time we go back to the main module and use this new SFMN widget.

Adding a relm widget

First, we'll need these new import statements:

VTFQMBZMJTU1MBZMJTU

VTFQMBZMJTU.TH\

"EE4POH

-PBE4POH

/FYU4POH

1MBZ4POH

1BVTF4POH

1SFWJPVT4POH

3FNPWF4POH

4BWF4POH

4POH4UBSUFE

4UPQ4POH

^

And then, add the 1MBZMJTU widget below the toolbar: WJFX\

<OBNFXJOEPX>

HUL8JOEPX\

UJUMF3VTJD

HUL#PY\

PSJFOUBUJPO7FSUJDBM

<OBNFUPPMCBS>

HUL5PPMCBS\

d

^

<OBNFQMBZMJTU>

1MBZMJTU\

^

HUL*NBHF\

GSPN@QJYCVGTFMGNPEFMDPWFS@QJYCVGBT@SFG

WJTJCMFTFMGNPEFMDPWFS@WJTJCMF

^

HUL#PY\

d

^

^

[ 259 ]





Music Player in a More Rusty Way with Relm Chapter 7

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

^

^

There's something different with using SFMN widgets and HUL widgets. 3FMN widgets must not contain a module prefix, while HUL widget must contain one. This is why we imported 1MBZMJTU, but now HUL5PPMCBS, for instance. But why is it needed? Well, SFMN widgets are different than HUL widgets, so they are not created or added to another widget in the same way. Thus, SFMN can distinguish them this way: if there's a prefix, this is a built-in HUL

widget, otherwise it is a custom SFMN widget. When I say HUL widgets, this even includes HUL widgets from other crates, such as XFCLJUHUL8FC7JFX.

Communicating between widgets

We'll now communicate between the widgets to indicate we want to add a song to the playlist. But before we do so, we'll look in more detail at how a widget can communicate with itself.

Communicating with the same widget

We previously saw how to communicate with the same widget. To send a message to the same widget from an event handler in the view, we simply need to specify the message to be sent on the right side of , like in the following example: HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOHULRVJU

DMJDLFE 2VJU

^

[ 260 ]





Music Player in a More Rusty Way with Relm Chapter 7

Here, the 2VJU message is sent to the same widget (that is, "QQ) when the user clicks this tool button. But this is syntax sugar for a call to the FNJU method on the stream of events of a SFMN widget.

Emit

So, let's see how to send a message to the same widget without using this syntax: this is useful in more complex cases, such as when we want to conditionally send a message. Let's go back to our 1MBZMJTU and add a QMBZ method:

JNQM1MBZMJTU\

GOQMBZNVUTFMG\

JGMFU4PNFQBUITFMGTFMFDUFE@QBUI\

TFMGNPEFMDVSSFOU@TPOH4PNFQBUIJOUP

TFMGNPEFMSFMNTUSFBNFNJU4POH4UBSUFETFMGQJYCVG

^

^

^

This line sends a message to the current widget:

TFMGNPEFMSFMNTUSFBNFNJU4POH4UBSUFETFMGQJYCVG

We first get the event stream from the SFMN widget and then call FNJU on it with a message. This QMBZ method requires two new methods: VTFHUL\

5SFF.PEFM&YU

5SFF4FMFDUJPO&YU

^

JNQM1MBZMJTU\

GOQJYCVGTFMG 0QUJPO1JYCVG \

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

MFUWBMVFTFMGNPEFMNPEFMHFU@WBMVFJUFS

1*9#6'@$0-6./BTJ

SFUVSOWBMVFHFU1JYCVG

^

/POF

^

GOTFMFDUFE@QBUITFMG 0QUJPO4USJOH \

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

[ 261 ]





Music Player in a More Rusty Way with Relm Chapter 7

MFUWBMVFTFMGNPEFMNPEFMHFU@WBMVFJUFS

1"5)@$0-6./BTJ

SFUVSOWBMVFHFU4USJOH

^

/POF

^

^

These are very similar to the ones we wrote in the previous chapters. We can now call the QMBZ method in the VQEBUF method:

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

"EE4POHQBUI TFMGBEEQBUI

-PBE4POHQBUI

/FYU4POH

1BVTF4POH

1MBZ4POH TFMGQMBZ

1SFWJPVT4POH

3FNPWF4POH

4BWF4POHQBUI

5PCFMJTUFOFECZ"QQ

4POH4UBSUFE@

4UPQ4POH

^

^

I also added a comment before 4POH4UBSUFE to indicate that this message will not be handled by the 1BZMJTU widget, but by the "QQ widget. Now, let's see how to communicate between different widgets.

With different widgets

Let's update the PQFO method to communicate with the playlist: JNQM"QQ\

GOPQFOTFMG\

MFUGJMFTIPX@PQFO@EJBMPHTFMGXJOEPX

JGMFU4PNFGJMFGJMF\

MFUFYUGJMFFYUFOTJPONBQ]FYU]

FYUUP@TUSVOXSBQUP@TUSJOH

JGMFU4PNFFYUFYU\

NBUDIFYUBT@TUS\

NQ TFMGQMBZMJTUFNJU"EE4POHGJMF

NV TFMGQMBZMJTUFNJU-PBE4POHGJMF

[ 262 ]

Music Player in a More Rusty Way with Relm Chapter 7

FYUFOTJPO \

MFUEJBMPH.FTTBHF%JBMPHOFX4PNFTFMGXJOEPX

%JBMPH'MBHTFNQUZ.FTTBHF5ZQF&SSPS

#VUUPOT5ZQF0LGPSNBU$BOOPUPQFOGJMFXJUI

FYUFOTJPO\^FYUFOTJPO

EJBMPHSVO

EJBMPHEFTUSPZ

^

^

^

^

^

^

So, we call the same FNJU method to send a message to another widget: TFMGQMBZMJTUFNJU"EE4POHGJMF

Here, we sent a message that is not yet handled by the 1MBZMJTU (-PBE4POH), so let's fix that:

VTFNV

JNQM1MBZMJTU\

GOMPBETFMGQBUI1BUI\

MFUNVUSFBEFSNV3FBEFSPQFOQBUIVOXSBQ

GPSFOUSZJOSFBEFSFOUSJFT\

JGMFU0LNV&OUSZ1BUIQBUIFOUSZ\

TFMGBEEQBUI

^

^

^

^

This method is called in the VQEBUF method:

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

"EE4POHQBUI TFMGBEEQBUI

-PBE4POHQBUI TFMGMPBEQBUI

/FYU4POH

1BVTF4POH

1MBZ4POH TFMGQMBZ

1SFWJPVT4POH

3FNPWF4POH

4BWF4POHQBUI

5PCFMJTUFOFECZ"QQ

4POH4UBSUFE@

[ 263 ]





Music Player in a More Rusty Way with Relm Chapter 7

4UPQ4POH

^

^

Handle messages from a relm widget

Let's now see how to handle the 4POH4UBSUFE message. To do so, we use a syntax similar to the one for handling HUL events. The message is on the left side of while the handler is on the right side of it:

<XJEHFU>

JNQM8JEHFUGPS"QQ\

d

WJFX\

d

<OBNFQMBZMJTU>

1MBZMJTU\

4POH4UBSUFESFGQJYCVG 4UBSUFEQJYCVGDMPOF

^

^

^

We can see here that when we receive the 4POH4UBSUFE message from the playlist, we emit the 4UBSUFE message on the same widget ("QQ). We needed to use SFG and then DMPOF

the value contained in the message here because we do not own the message. Indeed, multiple widgets can listen to the same message, the widget that emitted the message and its parent. Before we handle this new message, we'll add it to our .TH enumeration:

<EFSJWF.TH>

QVCFOVN.TH\

0QFO

1MBZ1BVTF

2VJU

4BWF

4UBSUFE0QUJPO1JYCVG

4UPQ

^

[ 264 ]





Music Player in a More Rusty Way with Relm Chapter 7

This variant takes an optional QJYCVG because some MP3 files do not have a cover image inside them. And here's how we handle this message: GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

d

4UBSUFEQJYCVG \

TFMGTFU@QMBZ@JDPO1"64&@*$0/

TFMGNPEFMDPWFS@WJTJCMFUSVF

TFMGNPEFMDPWFS@QJYCVGQJYCVG

^

^

^

When the song starts playing, we show the pause icon and the cover.

Syntax sugar to send a message to another relm widget Sending a message to another widget with FNJU is a bit verbose, so SFMN provides syntactic sugar for this case. Let's send a message to the playlist when the user clicks the remove button:

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOSFNPWF

DMJDLFE QMBZMJTU!3FNPWF4POH

^

Here, we used the ! syntax to specify that the message will be sent to another widget. The part before the ! is the receiver widget, while the part after this character is the message. So, this code means that whenever the user clicks the remove button, send the 3FNPWF4POH message to the QMBZMJTU widget.

Let's handle this message in the 1BZMJTUVQEBUF method:

<XJEHFU>

JNQM8JEHFUGPS1MBZMJTU\

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

"EE4POHQBUI TFMGBEEQBUI

-PBE4POHQBUI TFMGMPBEQBUI

/FYU4POH

1BVTF4POH

1MBZ4POH TFMGQMBZ

1SFWJPVT4POH

3FNPWF4POH TFMGSFNPWF@TFMFDUJPO

[ 265 ]

Music Player in a More Rusty Way with Relm Chapter 7

4BWF4POHQBUI

5PCFMJTUFOFECZ"QQ

4POH4UBSUFE@

4UPQ4POH

^

^

d

^

This calls the SFNPWF@TFMFDUJPO method, as shown here: GOSFNPWF@TFMFDUJPOTFMG\

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

TFMGNPEFMNPEFMSFNPWFJUFS

^

^

This is the same method as the one from $IBQUFS, Creating a Music Player. Now, let's send the remaining messages. The 1MBZ4POH, 1BVTF4POH, 4BWF4POH, and 4UPQ4POH messages are emitted in the VQEBUF method:

<XJEHFU>

JNQM8JEHFUGPS"QQ\

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

1MBZ1BVTF \

JGTFMGNPEFMTUPQQFE\

TFMGQMBZMJTUFNJU1MBZ4POH

^FMTF\

TFMGQMBZMJTUFNJU1BVTF4POH

TFMGTFU@QMBZ@JDPO1-":@*$0/

^

^

4BWF \

MFUGJMFTIPX@TBWF@EJBMPHTFMGXJOEPX

JGMFU4PNFGJMFGJMF\

TFMGQMBZMJTUFNJU4BWF4POHGJMF

^

^

4UPQ \

TFMGTFU@DVSSFOU@UJNF

TFMGNPEFMDVSSFOU@EVSBUJPO

TFMGQMBZMJTUFNJU4UPQ4POH

TFMGNPEFMDPWFS@WJTJCMFGBMTF

TFMGTFU@QMBZ@JDPO1-":@*$0/

[ 266 ]

Music Player in a More Rusty Way with Relm Chapter 7

^

d

^

^

^

The other messages are sent using the ! syntax in the view: WJFX\

<OBNFXJOEPX>

HUL8JOEPX\

UJUMF3VTJD

HUL#PY\

PSJFOUBUJPO7FSUJDBM

<OBNFUPPMCBS>

HUL5PPMCBS\

d

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOHULNFEJBQSFWJPVT

DMJDLFE QMBZMJTU!1SFWJPVT4POH

^

d

HUL5PPM#VUUPO\

JDPO@XJEHFUOFX@JDPOHULNFEJBOFYU

DMJDLFE QMBZMJTU!/FYU4POH

^

^

d

^

EFMFUF@FWFOU@@ 2VJU*OIJCJUGBMTF

^

^

We'll handle these messages in the 1BZMJTUVQEBUF method: GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

"EE4POHQBUI TFMGBEEQBUI

-PBE4POHQBUI TFMGMPBEQBUI

/FYU4POH TFMGOFYU

1BVTF4POH

1MBZ4POH TFMGQMBZ

1SFWJPVT4POH TFMGQSFWJPVT

3FNPWF4POH TFMGSFNPWF@TFMFDUJPO

4BWF4POHQBUI TFMGTBWFQBUI

5PCFMJTUFOFECZ"QQ

4POH4UBSUFE@

4UPQ4POH TFMGTUPQ

[ 267 ]

Music Player in a More Rusty Way with Relm Chapter 7

^

^

This requires some new methods:

GOOFYUNVUTFMG\

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

MFUOFYU@JUFS

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

JGTFMGNPEFMNPEFMJUFS@OFYUJUFS\

SFUVSO

^

4PNFJUFS

^

FMTF\

TFMGNPEFMNPEFMHFU@JUFS@GJSTU

^

JGMFU4PNFSFGJUFSOFYU@JUFS\

TFMFDUJPOTFMFDU@JUFSJUFS

TFMGQMBZ

^

^

GOQSFWJPVTNVUTFMG\

MFUTFMFDUJPOTFMGUSFFWJFXHFU@TFMFDUJPO

MFUQSFWJPVT@JUFS

JGMFU4PNF@JUFSTFMFDUJPOHFU@TFMFDUFE\

JGTFMGNPEFMNPEFMJUFS@QSFWJPVTJUFS\

SFUVSO

^

4PNFJUFS

^

FMTF\

TFMGNPEFMNPEFMJUFS@OUI@DIJME/POFNBY

TFMGNPEFMNPEFMJUFS@O@DIJMESFO/POF

^

JGMFU4PNFSFGJUFSQSFWJPVT@JUFS\

TFMFDUJPOTFMFDU@JUFSJUFS

TFMGQMBZ

^

^

VTFTUEGT'JMF

GOTBWFTFMGQBUI1BUI\

MFUNVUGJMF'JMFDSFBUFQBUIVOXSBQ

MFUNVUXSJUFSNV8SJUFSOFXNVUGJMF

[ 268 ]





Music Player in a More Rusty Way with Relm Chapter 7

MFUNVUXSJUF@JUFS]JUFS5SFF*UFS]\

MFUWBMVFTFMGNPEFMNPEFMHFU@WBMVFJUFS1"5)@$0-6./

BTJ

MFUQBUIWBMVFHFU4USJOH VOXSBQ

XSJUFSXSJUF@FOUSZNVQBUI@FOUSZQBUIVOXSBQ

^

JGMFU4PNFJUFSTFMGNPEFMNPEFMHFU@JUFS@GJSTU\

XSJUF@JUFSJUFS

XIJMFTFMGNPEFMNPEFMJUFS@OFYUJUFS\

XSJUF@JUFSJUFS

^

^

^

And function TUPQ:

GOTUPQNVUTFMG\

TFMGNPEFMDVSSFOU@TPOH/POF

^

These methods are all similar to the ones we created in the previous chapters. You can run the application to see that we can open and remove songs, but we cannot play them yet. So let's fix this.

Playing music

First, add the NQ module:

NPENQ

Copy the TSDNQST file from the previous chapter.

We also need the following dependencies:

<EFQFOEFODJFT>

DSPTTCFBN?

GVUVSFT?

QVMTFTJNQMF?

TJNQMFNBE?

[ 269 ]

Music Player in a More Rusty Way with Relm Chapter 7

And add these statements to the NBJO module:

FYUFSODSBUFDSPTTCFBN

FYUFSODSBUFGVUVSFT

FYUFSODSBUFQVMTF@TJNQMF

FYUFSODSBUFTJNQMFNBE

We'll now add a QMBZFS module:

NPEQMBZFS

This new module will start with a bunch of import statements: VTFTUEDFMM$FMM

VTFTUEGT'JMF

VTFTUEJP#VG3FBEFS

VTFTUEQBUI\1BUI1BUI#VG^

VTFTUETZOD\"SD$POEWBS.VUFY^

VTFTUEUISFBE

VTFTUEUJNF%VSBUJPO

VTFDSPTTCFBNTZOD4FH2VFVF

VTFGVUVSFT\"TZOD4JOL4JOL^

VTFGVUVSFTTZODNQTD6OCPVOEFE4FOEFS

VTFQVMTF@TJNQMF1MBZCBDL

VTFNQ.Q%FDPEFS

VTFQMBZMJTU1MBZFS.TH\

TFMG

1MBZFS1MBZ

1MBZFS4UPQ

1MBZFS5JNF

^

VTFTFMG"DUJPO

[ 270 ]

Music Player in a More Rusty Way with Relm Chapter 7

We imported a new 1MBZFS.TH type from the QMBZMJTU module, so let's add it:

<EFSJWF$MPOF>

QVCFOVN1MBZFS.TH\

1MBZFS1MBZ

1MBZFS4UPQ

1MBZFS5JNFV

^

We'll define some constants:

DPOTU#6''&3@4*;&VTJ[F

DPOTU%&'"6-5@3"5&V

And let's create the types that we'll need:

FOVN"DUJPO\

-PBE1BUI#VG

4UPQ

^

<EFSJWF$MPOF>

TUSVDU&WFOU-PPQ\

DPOEJUJPO@WBSJBCMF"SD.VUFYCPPM $POEWBS

RVFVF"SD4FH2VFVF"DUJPO

QMBZJOH"SD.VUFYCPPM

^

QVCTUSVDU1MBZFS\

FWFOU@MPPQ&WFOU-PPQ

QBVTFE$FMMCPPM

UY6OCPVOEFE4FOEFS1MBZFS.TH

^

The "DUJPO and &WFOU-PPQ are the same as in the previous chapter, but the 1MBZFS type is a bit different. Instead of having a field with the state of the application, it contains a sender that will be used to send messages to the playlist and ultimately to the application itself. So, instead of using a shared state and a timeout like we did in the previous chapter, we'll use message passing, which is more efficient.

[ 271 ]

Music Player in a More Rusty Way with Relm Chapter 7

We'll need a constructor for &WFOU-PPQ:

JNQM&WFOU-PPQ\

GOOFX 4FMG\

&WFOU-PPQ\

DPOEJUJPO@WBSJBCMF"SDOFX.VUFYOFXGBMTF

$POEWBSOFX

RVFVF"SDOFX4FH2VFVFOFX

QMBZJOH"SDOFX.VUFYOFXGBMTF

^

^

^

Let's create the constructor for 1MBZFS:

JNQM1MBZFS\

QVCDSBUFGOOFXUY6OCPVOEFE4FOEFS1MBZFS.TH 4FMG\

MFUFWFOU@MPPQ&WFOU-PPQOFX

\

MFUNVUUYUYDMPOF

MFUFWFOU@MPPQFWFOU@MPPQDMPOF

MFUDPOEJUJPO@WBSJBCMFFWFOU@MPPQDPOEJUJPO@WBSJBCMFDMPOF

UISFBETQBXONPWF]]\

MFUCMPDL]]\

MFUSFGMPDLSFGDPOEJUJPO@WBSJBCMF

DPOEJUJPO@WBSJBCMF

MFUNVUTUBSUFEMPDLMPDLVOXSBQ

TUBSUFEGBMTF

XIJMFTUBSUFE\

TUBSUFE

DPOEJUJPO@WBSJBCMFXBJUTUBSUFEVOXSBQ

^

^

MFUNVUCVGGFS<<>#6''&3@4*;&>

MFUNVUQMBZCBDL1MBZCBDLOFX.1.11MBZCBDL

/POF

%&'"6-5@3"5&

MFUNVUTPVSDF/POF

MPPQ\

JGMFU4PNFBDUJPOFWFOU@MPPQRVFVFUSZ@QPQ\

NBUDIBDUJPO\

-PBEQBUI \

MFUGJMF'JMFPQFOQBUIVOXSBQ

TPVSDF

4PNF.Q%FDPEFSOFX#VG3FBEFSOFXGJMFVOXSBQ

MFUSBUFTPVSDFBT@SFGNBQ]TPVSDF]

[ 272 ]

Music Player in a More Rusty Way with Relm Chapter 7

TPVSDFTBNQMFT@SBUFVOXSBQ@PS%&'"6-5@3"5& QMBZCBDL1MBZCBDLOFX.1.1

1MBZCBDL

/POFSBUF

TFOENVUUY1MBZFS1MBZ

^

4UPQ \

TPVSDF/POF

^

^

^FMTFJGFWFOU@MPPQQMBZJOHMPDLVOXSBQ\

MFUNVUXSJUUFOGBMTF

JGMFU4PNFSFGNVUTPVSDFTPVSDF\

MFUTJ[FJUFS@UP@CVGGFSTPVSDFNVUCVGGFS

JGTJ[F \

TFOENVUUY

1MBZFS5JNFTPVSDFDVSSFOU@UJNF

QMBZCBDLXSJUFCVGGFS<TJ[F>

XSJUUFOUSVF

^

^

JGXSJUUFO\

TFOENVUUY1MBZFS4UPQ

FWFOU@MPPQQMBZJOHMPDLVOXSBQGBMTF

TPVSDF/POF

CMPDL

^

^FMTF\

CMPDL

^

^

^

^

1MBZFS\

FWFOU@MPPQ

QBVTFE$FMMOFXGBMTF

UY

^

^

^

It is similar to the one we wrote in the previous chapter, but instead of using the shared state, we send messages back to the playlist. Here's an example of how we send these messages:

[ 273 ]

Music Player in a More Rusty Way with Relm Chapter 7

TFOENVUUY1MBZFS5JNFTPVSDFDVSSFOU@UJNF

This sends the current time back to the UI so that it can display it. This requires the TFOE

function to be defined:

GOTFOEUYNVU6OCPVOEFE4FOEFS1MBZFS.TH NTH1MBZFS.TH\

JGMFU0L"TZOD4JOL3FBEZUYTUBSU@TFOENTH\

UYQPMM@DPNQMFUFVOXSBQ

^FMTF\

FQSJOUMO6OBCMFUPTFOENFTTBHFUPTFOEFS

^

^

This code uses the GVUVSF crate to send the message and it shows an error in case it fails.

The JUFS@UP@CVGGFS function is the same as the one from the previous chapter: GOJUFS@UP@CVGGFS**UFSBUPS*UFNJ JUFSNVU*CVGGFSNVU

<<J>#6''&3@4*;&> VTJ[F\

MFUNVUJUFSJUFSUBLF#6''&3@4*;&

MFUNVUJOEFY

XIJMFMFU4PNFTBNQMFJUFSOFYU\

JGMFU4PNFTBNQMFJUFSOFYU\

CVGGFS<JOEFY><>TBNQMF

CVGGFS<JOEFY><>TBNQMF

^

JOEFY

^

JOEFY

^

We'll now add the methods to play and pause a song: QVCGOMPBE1"T3FG1BUI TFMGQBUI1\

MFUQBUICVGQBUIBT@SFGUP@QBUI@CVG

TFMGFNJU-PBEQBUICVG

TFMGTFU@QMBZJOHUSVF

^

QVCGOQBVTFNVUTFMG\

TFMGQBVTFETFUUSVF

TFMGTFOE1MBZFS4UPQ

TFMGTFU@QMBZJOHGBMTF

^

QVCGOSFTVNFNVUTFMG\

TFMGQBVTFETFUGBMTF

TFMGTFOE1MBZFS1MBZ

TFMGTFU@QMBZJOHUSVF

[ 274 ]

Music Player in a More Rusty Way with Relm Chapter 7

^

They're very similar to the ones from the previous chapter, but we send a message instead of modifying a state. They require the following methods: GOFNJUTFMGBDUJPO"DUJPO\

TFMGFWFOU@MPPQRVFVFQVTIBDUJPO

^

GOTFOENVUTFMGNTH1MBZFS.TH\

TFOENVUTFMGUYNTH

^

GOTFU@QMBZJOHTFMGQMBZJOHCPPM\

TFMGFWFOU@MPPQQMBZJOHMPDLVOXSBQQMBZJOH

MFUSFGMPDLSFGDPOEJUJPO@WBSJBCMF

TFMGFWFOU@MPPQDPOEJUJPO@WBSJBCMF

MFUNVUTUBSUFEMPDLMPDLVOXSBQ

TUBSUFEQMBZJOH

JGQMBZJOH\

DPOEJUJPO@WBSJBCMFOPUJGZ@POF

^

^

The FNJU and TFU@QMBZJOH methods are the same as in the previous chapter.

The TFOE method simply calls the TFOE function we defined earlier.

We'll also need these two methods:

QVCGOJT@QBVTFETFMG CPPM\

TFMGQBVTFEHFU

^

QVCGOTUPQNVUTFMG\

TFMGQBVTFETFUGBMTF

TFMGTFOE1MBZFS5JNF

TFMGTFOE1MBZFS4UPQ

TFMGFNJU4UPQ

TFMGTFU@QMBZJOHGBMTF

^

[ 275 ]

Music Player in a More Rusty Way with Relm Chapter 7

The JT@QBVTFE method has not changed. And the TUPQ method is similar, but again, it sends messages instead of updating the application state directly. Let's go back to our 1BZMJTU to use this new player. The model will now contain the player itself: VTFQMBZFS1MBZFS

QVCTUSVDU.PEFM\

DVSSFOU@TPOH0QUJPO4USJOH

QMBZFS1MBZFS

NPEFM-JTU4UPSF

SFMN3FMN1MBZMJTU

^

The .TH type will contain a new variant called 1MBZFS.TH3FDW that will be emitted whenever the player sends a message:

<EFSJWF.TH>

QVCFOVN.TH\

"EE4POH1BUI#VG

-PBE4POH1BUI#VG

/FYU4POH

1BVTF4POH

1MBZFS.TH3FDW1MBZFS.TH

1MBZ4POH

1SFWJPVT4POH

3FNPWF4POH

4BWF4POH1BUI#VG

4POH4UBSUFE0QUJPO1JYCVG

4UPQ4POH

^

We're now ready to update the model initialization: VTFGVUVSFTTZODNQTD

GONPEFMSFMN3FMN4FMG @ .PEFM\

MFUUYSYNQTDVOCPVOEFE

SFMNDPOOFDU@FYFD@JHOPSF@FSSSY1MBZFS.TH3FDW

.PEFM\

DVSSFOU@TPOH/POF

QMBZFS1MBZFSOFXUY

NPEFM-JTU4UPSFOFX<

1JYCVGTUBUJD@UZQF

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

[ 276 ]

Music Player in a More Rusty Way with Relm Chapter 7

5ZQF4USJOH

5ZQF4USJOH

5ZQF4USJOH

1JYCVGTUBUJD@UZQF

>

SFMNSFMNDMPOF

^

^

It now creates a sender and receiver pair from the NQTD type of the GVUVSF crate. MPSC

stands for Multiple-Producers-Single-Consumer. We now call the 3FMNDPOOFDU@FYFD@JHOPSF@FSS method, this method connects a 'VUVSF or a 4USFBN to a message. This means that whenever a value is produced in the 4USFBN, a message will be emitted. The message needs to take a parameter of the same type as the value produced by the 4USFBN. A 'VUVSF represents a value that is possibly not yet available, but will be available in the future, unless an error happens. A 4USFBN is similar, but can produce multiple values that will be available at different times in the future.

Similar to the DPOOFDU@FYFD@JHOPSF@FSS method, there's also the DPOOFDU@FYFD method, which takes another message variant as a parameter, this second message will be emitted when there's an error. Here, we simply ignore the errors.

In the VQEBUF method:

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

5PCFMJTUFOFECZ"QQ

1MBZFS.TH3FDW@

d

^

^

We have nothing to do with this message because it will be handled by the "QQ widget.

We'll now add a method to pause the player:

GOQBVTFNVUTFMG\

TFMGNPEFMQMBZFSQBVTF

^

Next we need to update the QMBZ and TUPQ methods:

GOQMBZNVUTFMG\

JGMFU4PNFQBUITFMGTFMFDUFE@QBUI\

JGTFMGNPEFMQMBZFSJT@QBVTFE4PNFQBUI

TFMGQBUIBT@SFG\

TFMGNPEFMQMBZFSSFTVNF

^FMTF\

[ 277 ]

Music Player in a More Rusty Way with Relm Chapter 7

TFMGNPEFMQMBZFSMPBEQBUI

TFMGNPEFMDVSSFOU@TPOH4PNFQBUIJOUP

TFMGNPEFMSFMNTUSFBNFNJU4POH4UBSUFETFMGQJYCVG

^

^

^

GOTUPQNVUTFMG\

TFMGNPEFMDVSSFOU@TPOH/POF

TFMGNPEFMQMBZFSTUPQ

^

The TUPQ method is the same, except that we can update the model directly, because we don't need to use the 3FG$FMM type anymore. The QMBZ method will now load or resume the song depending on the state of the player.

The QMBZ method requires a QBUI method:

GOQBUITFMG 0QUJPO4USJOH \

TFMGNPEFMDVSSFOU@TPOHDMPOF

^

Let's go back to the NBJO module to manage the messages sent by the player. First, we need a new variant for our FOVN.TH:

<EFSJWF.TH>

QVCFOVN.TH\

.TH3FDW1MBZFS.TH

d

^

We will handle this in the VQEBUF method:

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

.TH3FDWQMBZFS@NTH TFMGQMBZFS@NFTTBHFQMBZFS@NTH

d

^

^

[ 278 ]





Music Player in a More Rusty Way with Relm Chapter 7

This requires a new method to be added in JNQM8JEHFUGPS"QQ:

<XJEHFU>

JNQM8JEHFUGPS"QQ\

GOQMBZFS@NFTTBHFNVUTFMGQMBZFS@NTH1MBZFS.TH\

NBUDIQMBZFS@NTH\

1MBZFS1MBZ \

TFMGNPEFMTUPQQFEGBMTF

TFMGTFU@QMBZ@JDPO1"64&@*$0/

^

1MBZFS4UPQ \

TFMGTFU@QMBZ@JDPO1-":@*$0/

TFMGNPEFMTUPQQFEUSVF

^

1MBZFS5JNFUJNF TFMGTFU@DVSSFOU@UJNFUJNF

^

^

^

This is also a DVTUPN method, that is, a method that is not part of the 8JEHFU trait, but is analyzed by the <XJEHFU> attribute. We put it there instead of a separate JNQM"QQ

because we updated the model. In this method, we either update the icon to display the play button or the current time.

Computing the song duration

The only remaining feature that needs to be implemented in order to be on par with the music player of the previous chapter is to compute and display the song duration. First, we will copy the DPNQVUF@EVSBUJPO method from the previous chapter and paste it in our 1MBZFS:

QVCGODPNQVUF@EVSBUJPO1"T3FG1BUI QBUI1

0QUJPO%VSBUJPO \

MFUGJMF'JMFPQFOQBUIVOXSBQ

.Q%FDPEFSDPNQVUF@EVSBUJPO#VG3FBEFSOFXGJMF

^

[ 279 ]

Music Player in a More Rusty Way with Relm Chapter 7

We'll now call this method in the 1MBZMJTU:

VTFTUEUISFBE

VTFGVUVSFTTZODPOFTIPU

GODPNQVUF@EVSBUJPOTFMGQBUI1BUI\

MFUQBUIQBUIUP@QBUI@CVG

MFUUYSYPOFTIPUDIBOOFM

UISFBETQBXONPWF]]\

JGMFU4PNFEVSBUJPO1MBZFSDPNQVUF@EVSBUJPOQBUI\

UYTFOEQBUIEVSBUJPO

FYQFDU$BOOPUTFOEDPNQVUFEEVSBUJPO

^

^

TFMGNPEFMSFMNDPOOFDU@FYFD@JHOPSF@FSSSY]QBUIEVSBUJPO]

%VSBUJPO$PNQVUFEQBUIEVSBUJPO

^

Here, we use POFTIPU which is also a channel, similar to NQTD, but POFTIPU can only send a message once. The message sent is a tuple, so we convert it to our .TH type by using a new %VSBUJPO$PNQVUFE variant that we'll add to the type: VTFTUEUJNF%VSBUJPO

<EFSJWF.TH>

QVCFOVN.TH\

"EE4POH1BUI#VG

%VSBUJPO$PNQVUFE1BUI#VG%VSBUJPO

4POH%VSBUJPOV

d

^

We've also added a 4POH%VSBUJPO message that we'll use soon.

We need to call this method in 1MBZMJTUBEE:

JNQM1MBZMJTU\

GOBEETFMGQBUI1BUI\

TFMGDPNQVUF@EVSBUJPOQBUI

d

^

^

[ 280 ]

Music Player in a More Rusty Way with Relm Chapter 7

We then need to handle the new %VSBUJPO$PNQVUFE message in 1MBZMJTUVQEBUF: VTFUP@NJMMJT

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

%VSBUJPO$PNQVUFEQBUIEVSBUJPO \

MFUQBUIQBUIUP@TUSJOH@MPTTZUP@TUSJOH

JGTFMGNPEFMDVSSFOU@TPOHBT@SFG4PNFQBUI\

TFMGNPEFMSFMNTUSFBNFNJU4POH%VSBUJPOUP@NJMMJTEVSBUJPO

^

TFMGNPEFMEVSBUJPOTJOTFSUQBUIUP@NJMMJTEVSBUJPO

^

5PCFMJTUFOFECZ"QQ

4POH%VSBUJPO@

d

^

^

Here, we insert the computed duration in the model. And if the song is the one currently being played, we send the 4POH%VSBUJPO message so that the "QQ widget can update itself.

This requires a new field for the durations in the model: VTFTUEDPMMFDUJPOT)BTI.BQ

QVCTUSVDU.PEFM\

DVSSFOU@TPOH0QUJPO4USJOH

EVSBUJPOT)BTI.BQ4USJOHV

QMBZFS1MBZFS

NPEFM-JTU4UPSF

SFMN3FMN1MBZMJTU

^

Add the new model initialization:

GONPEFMSFMN3FMN4FMG @ .PEFM\

d

.PEFM\

EVSBUJPOT)BTI.BQOFX

d

^

^

[ 281 ]

Music Player in a More Rusty Way with Relm Chapter 7

This also requires the UP@NJMMJT function to be added in the NBJO module, which is the same as in the previous chapter:

VTFTUEUJNF%VSBUJPO

GOUP@NJMMJTEVSBUJPO%VSBUJPO V\

EVSBUJPOBT@TFDTEVSBUJPOTVCTFD@OBOPTBTV

@@

^

Since the duration is only computed once, we also need to send it when we start playing the song, so let's update the 1MBZMJTUQMBZ method:

GOQMBZNVUTFMG\

JGMFU4PNFQBUITFMGTFMFDUFE@QBUI\

JGTFMGNPEFMQMBZFSJT@QBVTFE4PNFQBUI

TFMGQBUIBT@SFG\

TFMGNPEFMQMBZFSSFTVNF

^FMTF\

TFMGNPEFMQMBZFSMPBEQBUI

JGMFU4PNFEVSBUJPO

TFMGNPEFMEVSBUJPOTHFUQBUI\

TFMGNPEFMSFMNTUSFBNFNJU4POH%VSBUJPOEVSBUJPO

^

TFMGNPEFMDVSSFOU@TPOH4PNFQBUIJOUP

TFMGNPEFMSFMNTUSFBNFNJU4POH4UBSUFETFMGQJYCVG

^

^

^

We send the 4POH%VSBUJPO message if we found it in the )BTI.BQ (it is possible that the song starts playing before the duration is computed).

Finally, we need to handle the following message in the "QQ view: WJFX\

1MBZMJTU\

1MBZFS.TH3FDWSFGQMBZFS@NTH

.TH3FDWQMBZFS@NTHDMPOF

4POH%VSBUJPOEVSBUJPO %VSBUJPOEVSBUJPO

4POH4UBSUFESFGQJYCVG 4UBSUFEQJYCVGDMPOF

^

d

^

[ 282 ]





Music Player in a More Rusty Way with Relm Chapter 7

When we receive the 4POH%VSBUJPO message from the playlist, we send the %VSBUJPO

message to "QQ, so we need to add this variant to its .TH type:

<EFSJWF.TH>

QVCFOVN.TH\

%VSBUJPOV

d

^

We'll simply handle it in the VQEBUF method:

GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

%VSBUJPOEVSBUJPO \

TFMGNPEFMDVSSFOU@EVSBUJPOEVSBUJPO

TFMGNPEFMBEKVTUNFOUTFU@VQQFSEVSBUJPOBTG

^

d

^

^

You can now run the application and see that it works exactly the same as the one from the previous chapter.

Using relm on stable Rust

In this whole chapter, we used Rust nightly to be able to use DVTUPN attributes, which are currently unstable. The <XJEHFU> attribute provided by SFMN provides many advantages: Declarative view

Data bindings

Less typing

So it would be nice to be able to use a similar syntax on stable that provides the same advantages. And it is possible to do so, by using the SFMN@XJEHFU macro. We'll rewrite the "QQ widget to use this macro:

SFMN@XJEHFU\

JNQM8JEHFUGPS"QQ\

GOJOJU@WJFXNVUTFMG\

TFMGUPPMCBSTIPX@BMM

^

[ 283 ]

Music Player in a More Rusty Way with Relm Chapter 7

GONPEFM .PEFM\

.PEFM\

BEKVTUNFOU"EKVTUNFOUOFX



DPWFS@QJYCVG/POF

DPWFS@WJTJCMFGBMTF

DVSSFOU@EVSBUJPO

DVSSFOU@UJNF

QMBZ@JNBHFOFX@JDPO1-":@*$0/

TUPQQFEUSVF

^

^

GOPQFOTFMG\

d

^

d

GOVQEBUFNVUTFMGFWFOU.TH\

d

^

WJFX\

<OBNFXJOEPX>

HUL8JOEPX\

UJUMF3VTJD

d

^

^

^

^

As you can see, we moved the external PQFO method inside the implementation decorated by the SFMN@XJEHFU macro. This is due to a limitation of this macro, while it allows us to use the nice syntax provided by relm on stable Rust, we cannot access the fields of the model from outside the macro. The rest is exactly the same as the previous versions.

[ 284 ]





Music Player in a More Rusty Way with Relm Chapter 7

Relm widgets data binding

There are many other features available in relm and I wanted to show you the most important of them: the syntax that is provided to simulate property binding. As you may have noticed by now, there's no property in SFMN widgets, but you can use message passing to update the internal state of a SFMN widget. To make it more convenient, the <XJEHFU> attribute also allows you to bind a model attribute to a message, this means that whenever the attribute is updated, the message will be emitted with this new value.

We'll add a toggle button to be able to switch between a simple and a detailed view for the playlist. The simple view will only show the cover and the title while the detailed view will show all the columns. First, let's add an attribute to the "QQ model: QVCTUSVDU.PEFM\

EFUBJMFE@WJFXCPPM

d

^

GONPEFM .PEFM\

.PEFM\

EFUBJMFE@WJFXGBMTF

d

^

^

This field specifies whether we're in the detailed view mode or not. We'll also need a message that will be emitted when we click the toggle button:

<EFSJWF.TH>

QVCFOVN.TH\

7JFX5PHHMF

d

^

Then, we add the toggle button to the toolbar:

<OBNFUPHHMF@CVUUPO>

HUL5PHHMF5PPM#VUUPO\

MBCFM%FUBJMFEWJFX

UPHHMFE 7JFX5PHHMF

^

[ 285 ]

Music Player in a More Rusty Way with Relm Chapter 7

When we receive this message, we'll set the NPEFM attribute accordingly: GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

7JFX5PHHMF TFMGNPEFMEFUBJMFE@WJFX

TFMGUPHHMF@CVUUPOHFU@BDUJWF

d

^

^

Now, let's a message to the 1MBZMJTU:

<EFSJWF.TH>

QVCFOVN.TH\

%FUBJMFE7JFXCPPM

d

^

This is the message we'll use for the binding. Let's handle it: GOVQEBUFNVUTFMGFWFOU.TH\

NBUDIFWFOU\

%FUBJMFE7JFXEFUBJMFE TFMGTFU@EFUBJMFE@WJFXEFUBJMFE

d

^

^

GOTFU@EFUBJMFE@WJFXTFMGEFUBJMFECPPM\

GPSDPMVNOJOTFMGUSFFWJFXHFU@DPMVNOTJUFSTLJQ\

DPMVNOTFU@WJTJCMFEFUBJMFE

^

^

The latter method toggles the visible of all columns except the first two. We can now create the binding in the "QQ view:

VTFQMBZMJTU.TH%FUBJMFE7JFX

WJFX\

d

<OBNFQMBZMJTU>

1MBZMJTU\

d

%FUBJMFE7JFXTFMGNPEFMEFUBJMFE@WJFX

^

^

[ 286 ]





Music Player in a More Rusty Way with Relm Chapter 7

This code will send the %FUBJMFE7JFX message with the specified attribute as the value whenever it changes.

Summary

In this chapter, we used SFMN to create a music player. We saw how simple it is to use rust nightly with SVTUVQ. We learned how to declaratively create views and use message passing to communicate between widgets. We also learned how to structure GUI applications by separating the model, the view, and the function to update the model in reaction to events. In the next chapter, we'll switch to another project: an FTP server.

[ 287 ]





8

Understanding FTP

This chapter is all about asynchronous programming in Rust. In order to show you how it works, we'll write an FTP server. However, to make it as easy as possible for you to understand, we'll break the subject down into the following topics: Presenting the FTP protocol

Implementing a synchronous FTP server

Presenting asynchronous programmation in Rust

Asynchronously implementing the FTP server

These steps are all important in order to make you feel confident in Rust asynchronous programming.

Now, let's start by talking a bit about the FTP protocol!

File transfer protocol

The file transfer protocol (FTP) was created in 1971. Its final RFC is 959. If you're curious, you can read more about it at IUUQTUPPMTJFUGPSHIUNMSGD.

Being an old protocol, a few commands don't have clear specifications, so some alternative specifications (that are more or less official) have been written in order to fill those blanks.

We'll go back to them when writing the server.

Another important point to note is that FTP uses TCP connections.

Now that we've quickly introduced you to FTP, let's see how it works.





Understanding FTP

Chapter 8

Introduction to FTP

A client connects to a server and then sends commands to the server. Each command receives an answer from the server with either a success or failure.

For example, the client will send the 18% command to the server: 18%=S=O

=S=O

Here, the server answered (which literally means pathname created) and then gave the current working directory the client is in (which is , in this case).

As you can see, every command ended with . This is another standard in FTPbevery command has to end with . In case you don't know, stands for carriage return and stands for the backline.

Another thing to notebthe answer from the server always contains a string before the .

Consider the following example:

/001=S=O

%PJOHOPUIJOH=S=O

If the client's command doesn't require a precise output (except for the returned code), it's all up to the server. It's generally just a small sentence giving more information about what the server did (or what failed). On another server, the /001 command could have given the following:

/001=S=O

JTMJGF=S=O

Lastly, FTP works with two channels:

The first channel is used to send small commands, such as updating a status The second channel is used to send a large amount of data, such as a file transfer or even listing a directory

[ 289 ]





Understanding FTP

Chapter 8

A funny thing about this second channel is that it's up to the client to decide whether the server connects to the client or vice versa. But in almost every case, the client asks the server to connect to him for a second time, and the server picks a port and they're good to go.

We can now say that we're done with a quick introduction to FTP. If it still doesn't seem perfectly clear at this point, no need to worry: it'll become more obvious as we go through the implementation of the server.

So, let's start with a synchronous server implementation.

Implementing simple chunks of commands

Let's start slowly by first creating a very simple server that sends IFMMP to a new client and then closes the connection:

VTFTUEOFU5DQ-JTUFOFS

VTFTUEJP8SJUF

GONBJO\

MFUMJTUFOFS

5DQ-JTUFOFSCJOEFYQFDU$PVMEO UCJOEUIJT

BEESFTT

QSJOUMO8BJUJOHGPSDMJFOUTUPDPOOFDU

GPSTUSFBNJOMJTUFOFSJODPNJOH\

0LTUSFBN \

QSJOUMO/FXDMJFOU

JGMFU&SS@TUSFBNXSJUFCIFMMP\

QSJOUMO'BJMFEUPTFOEIFMMP

^

^

@ \

QSJOUMO"DMJFOUUSJFEUPDPOOFDU

^

^

^

Pretty easy, right? As usual, let's explain what the code does: MFUMJTUFOFS5DQ-JTUFOFSCJOEFYQFDU$PVMEO U

CJOEUIJTBEESFTT

For those who don't know much about the network, the preceding line of code is the most important for any server

[ 290 ]

Understanding FTP

Chapter 8

It tries to book the port for your server only. If another software is using it, then the CJOE call will fail. The given string represents the address and port we want to book. The argument works as follows: <*1><1035>. Here, we entered , which means that we want the port on the address .

It might sound strange to allow a server to pick an IP address to use, but it's actually not the case. You can only choose between MPDBMIPTU (alias ) and . The only difference between those two is that allows other computers to connect to your own (if the port can be accessed from outside through the box provided by your internet access provider), whereas can only be accessed from the computer it has been started on. But enough with network explanationsbthis isn't the point of this book, so let's move on!

The only other code that requires explanation is the following: GPSTUSFBNJOMJTUFOFSJODPNJOH\

The JODPNJOH method call allows us to iterate infinitely on newly received connections by returning an iterator. Then, the GPS loop just calls the OFYU method of the iterator.

That's it for this small code sample. Now it's time to improve all this!

It'd be nice to handle every client separately and not close the connection as soon as we receive a new connection, wouldn't it? So, let's just update the previous code a bit: VTFTUEOFU\5DQ-JTUFOFS5DQ4USFBN^

VTFTUEUISFBE

GOIBOEMF@DMJFOUNVUTUSFBN5DQ4USFBN\

QSJOUMOOFXDMJFOUDPOOFDUFE

QVUDMJFOUDPEFIBOEMJOHIFSF

^

GONBJO\

MFUMJTUFOFS

5DQ-JTUFOFSCJOEFYQFDU$PVMEO UCJOEUIJT

BEESFTT

QSJOUMO8BJUJOHGPSDMJFOUTUPDPOOFDU

GPSTUSFBNJOMJTUFOFSJODPNJOH\

0LTUSFBN \

UISFBETQBXONPWF]]\

IBOEMF@DMJFOUTUSFBN

^

^

[ 291 ]





Understanding FTP

Chapter 8

@ \

QSJOUMO"DMJFOUUSJFEUPDPOOFDU

^

^

^

Every time a new client connects to the server, we spawn a new thread and send the client's socket into it. This way, we can now handle every client on its own.

Now that we can get new clients connected, it's time to actually start implementing the FTP

part of our server.

Starting with basics

Of course, since we need to read and write on sockets, having to do that again and again in every function wouldn't be very efficient. Therefore, we'll start by implementing functions to do that. For now, we won't handle errors nicely (yes, VOXSBQ is evil).

Let's start with the XSJUF function:

VTFVTFTUEOFU5DQ4USFBN

VTFTUEJP8SJUF

GOTFOE@DNETUSFBNNVU5DQ4USFBNDPEF3FTVMU$PEFNFTTBHF

TUS\

MFUNTHJGNFTTBHFJT@FNQUZ\$PNNBOE/PU*NQMFNFOUFE

GPSNBU\^=S=ODPEFBTV

^FMTF\

GPSNBU\^\^=S=ODPEFBTVNFTTBHF

^

QSJOUMO\^NTH

XSJUFTUSFBN\^NTHVOXSBQ

^

OK, there's nothing fancy nor difficult to understand here. However, take a look at this: Every message ends with in FTP

Every message has to be followed by a whitespace if you want to add parameters or information.

This also works in the exact same way when a client sends us a command.

[ 292 ]

Understanding FTP

Chapter 8

What? Did I forget to provide you the 3FTVMU$PEF type? Indeed, you're absolutely right.

Here it is:

<EFSJWF%FCVH$MPOF$PQZ>

<SFQSV>

<BMMPXEFBE@DPEF>

FOVN3FTVMU$PEF\

3FTUBSU.BSLFS3FQMZ

4FSWJDF3FBE*O999.JOVUFT

%BUB$POOFDUJPO"MSFBEZ0QFO

'JMF4UBUVT0L

0L

$PNNBOE/PU*NQMFNFOUFE4VQFSGMVPVT"U5IJT4JUF

4ZTUFN4UBUVT

%JSFDUPSZ4UBUVT

'JMF4UBUVT

)FMQ.FTTBHF

4ZTUFN5ZQF

4FSWJDF3FBEZ'PS/FX6TFS

4FSWJDF$MPTJOH$POUSPM$POOFDUJPO

%BUB$POOFDUJPO0QFO

$MPTJOH%BUB$POOFDUJPO

&OUFSJOH1BTTJWF.PEF

6TFS-PHHFE*O

3FRVFTUFE'JMF"DUJPO0LBZ

1"5)/".&$SFBUFE

6TFS/BNF0LBZ/FFE1BTTXPSE

/FFE"DDPVOU'PS-PHJO

3FRVFTUFE'JMF"DUJPO1FOEJOH'VSUIFS*OGPSNBUJPO

4FSWJDF/PU"WBJMBCMF

$BOU0QFO%BUB$POOFDUJPO

$POOFDUJPO$MPTFE

'JMF#VTZ

-PDBM&SSPS*O1SPDFTTJOH

*OTVGGJDJFOU4UPSBHF4QBDF

6OLOPXO$PNNBOE

*OWBMJE1BSBNFUFS0S"SHVNFOU

$PNNBOE/PU*NQMFNFOUFE

#BE4FRVFODF0G$PNNBOET

$PNNBOE/PU*NQMFNFOUFE'PS5IBU1BSBNFUFS

/PU-PHHFE*O

/FFE"DDPVOU'PS4UPSJOH'JMFT

'JMF/PU'PVOE

1BHF5ZQF6OLOPXO

&YDFFEFE4UPSBHF"MMPDBUJPO

'JMF/BNF/PU"MMPXFE

^

[ 293 ]

Understanding FTP

Chapter 8

Yep, not very beautiful... This is the exact representation of all FTP code types (errors, information, warnings, and so on). We can't do much better here; we have to rewrite all code so that we can understand it when we receive it and are able to give the correct code corresponding to the clients' commands.

Now, I suppose, you can guess what's coming next. The FOVN$PNNBOE of course! This time, we'll fulfill it while we move forward on to the implementation of the commands: VTFTUEJP

VTFTUETUS

<EFSJWF$MPOF$PQZ%FCVH>

FOVN$PNNBOE\

"VUI

6OLOPXO4USJOH

^

JNQM"T3FGTUS GPS$PNNBOE\

GOBT@SFGTFMG TUS\

NBUDITFMG\

$PNNBOE"VUI "65)

$PNNBOE6OLOPXO@ 6/,/

^

^

^

JNQM$PNNBOE\

QVCGOOFXJOQVU7FDV JP3FTVMU4FMG \

MFUNVUJUFSJOQVUTQMJU]CZUF]CZUFC

MFUNVUDPNNBOEJUFSOFYUFYQFDUDPNNBOEJO

JOQVUUP@WFD

UP@VQQFSDBTFNVUDPNNBOE

MFUEBUBJUFSOFYU

MFUDPNNBOE

NBUDIDPNNBOEBT@TMJDF\

C"65) $PNNBOE"VUI

T

$PNNBOE6OLOPXOTUSGSPN@VUGTVOXSBQ@PSUP@PXOFE

^

0LDPNNBOE

^

^

[ 294 ]

Understanding FTP

Chapter 8

OK, let's get through this code:

FOVN$PNNBOE\

"VUI

6OLOPXO4USJOH

^

Every time we add a new command handling, we'll have to add a new variant to this FOVN.

In case the command doesn't exist (or we haven't implemented it yet), 6OLOPXO will be returned with the command name. If the command is taking arguments, it'll be added just like we saw for 6OLOPXO. Let's take $XE as an example: FOVN$PNNBOE\

"VUI

$XE1BUI#VG

6OLOPXO4USJOH

^

As you can see, $XE contains a 1BUI#VG. $XE stands for change working directory and takes the path of the directory that the client wants to go to.

Of course, you'd need to update BT@SFG by adding the following line to the NBUDI block: $PNNBOE$XE@ $8%

And you'd need to update the OFX method implementation by adding the following line into the NBUDI block:

C$8% $PNNBOE$XEEBUBNBQ]CZUFT]

1BUIOFXTUSGSPN@VUGCZUFTVOXSBQUP@QBUI@CVGVOXSBQ

Now let's explain the "T3FG trait implementation. It's very convenient when you want to write a generic function. Take a look at the following example: GOGPP4"T3FGTUS G4\

QSJOUMO\^GBT@SFG

^

Thanks to this trait, as long as the type implements it, we can call BT@SFG on it. It's very useful in our case when sending messages to the client since we can just take a type implementing "T3FG.

Now let's talk about the OFX method of the $PNNBOE type: QVCGOOFXJOQVU7FDV JP3FTVMU4FMG \

MFUNVUJUFSJOQVUTQMJU]CZUF]CZUFC

[ 295 ]

Understanding FTP

Chapter 8

MFUNVUDPNNBOEJUFSOFYUFYQFDUDPNNBOEJO

JOQVUUP@WFD

UP@VQQFSDBTFNVUDPNNBOE

MFUEBUBJUFSOFYU

MFUDPNNBOE

NBUDIDPNNBOEBT@TMJDF\

C"65) $PNNBOE"VUI

T

$PNNBOE6OLOPXOTUSGSPN@VUGTVOXSBQ@PSUP@PXOFE

^

0LDPNNBOE

^

The point here is to convert the message received from the client. We need to do two things: Get the command

Get the command's arguments (if any)

First, we create an iterator to split our vector, so we can separate the command from the arguments:

MFUNVUJUFSJOQVUTQMJU]CZUF]CZUFC

Then, we get the command:

MFUNVUDPNNBOEJUFSOFYUFYQFDUDPNNBOEJOJOQVUUP@WFD

At this point, DPNNBOE is a 7FDV . To then make the matching easier (because nothing in the RFC of the FTP talks about the fact that commands should be in uppercase or that BVUI is the same as "65) or even "V5I), we call the VQQFSDBTF function, which looks like this:

GOUP@VQQFSDBTFEBUBNVU<V>\

GPSCZUFJOEBUB\

JGCZUF B BTVCZUF [ BTV\

CZUF

^

^

^

Next, we get the arguments by calling OFYU on the iterator JUFS: MFUEBUBJUFSOFYU

If there are no arguments, no problem! We'll just get /POF.

[ 296 ]

Understanding FTP

Chapter 8

Finally, we match the commands:

NBUDIDPNNBOEBT@TMJDF\

C"65) $PNNBOE"VUI

T

$PNNBOE6OLOPXOTUSGSPN@VUGTVOXSBQ@PSUP@PXOFE

^

To do so, we convert our 7FDV into a <V> (a slice of V). To also convert a TUS

(such as "65)) into a <V>, we use the C operator (which is more like saying to the compiler, Hey! Don't worry, just say it's a slice and not a TUS ! ) to allow the matching.

And we're good! We can now write the function to actually read the data from the client: GOSFBE@BMM@NFTTBHFTUSFBNNVU5DQ4USFBN 7FDV \

MFUCVGNVU<>

MFUNVUPVU7FDXJUI@DBQBDJUZ

MPPQ\

NBUDITUSFBNSFBECVG\

0LSFDFJWFEJGSFDFJWFE \

JGPVUJT@FNQUZCVG<>C \

DPOUJOVF

^

PVUQVTICVG<>

^

@ SFUVSO7FDOFX

^

MFUMFOPVUMFO

JGMFO PVU<MFO>C =S PVU<MFO>

C =O \

PVUQPQ

PVUQPQ

SFUVSOPVU

^

^

^

Here, we read one byte at a time (and it's not a very efficient way to do so; we'll go back on this function later) and return when we get . We have just added a little security by removing any whitespaces that would come before the command (so as long as we don't have any data in our vector, we won't add any whitespace).

If there is any error, we return an empty vector and stop the reading of the client input.

[ 297 ]

Understanding FTP

Chapter 8

Like I said earlier, reading byte by byte isn't efficient, but is simpler to demonstrate how it works. So, for now, let's stick to this. This will be done completely differently once the asynchronous programming kicks in.

So, now that we can read and write FTP inputs it's time to actually start the implementation of the commands!

Let's start by creating a new structure:

<BMMPXEFBE@DPEF>

TUSVDU$MJFOU\

DXE1BUI#VG

TUSFBN5DQ4USFBN

OBNF0QUJPO4USJOH

^

Here are some quick explanations for the preceding code: DXE stands for the current working directory

TUSFBN is the client's socket

OBNF is the username you got from user authentication (which doesn't really matter, as we won't handle authentication in the first steps) Now it's time to update the IBOEMF@DMJFOU function: GOIBOEMF@DMJFOUNVUTUSFBN5DQ4USFBN\

QSJOUMOOFXDMJFOUDPOOFDUFE

TFOE@DNENVUTUSFBN3FTVMU$PEF4FSWJDF3FBEZ'PS/FX6TFS

8FMDPNFUPUIJT'51

TFSWFS

MFUDMJFOU$MJFOUOFXTUSFBN

MPPQ\

MFUEBUBSFBE@BMM@NFTTBHFNVUDMJFOUTUSFBN

JGEBUBJT@FNQUZ\

QSJOUMODMJFOUEJTDPOOFDUFE

CSFBL

^

DMJFOUIBOEMF@DNEDPNNBOEOFXEBUB

^

^

When a new client connects to the server, we send them a message to inform them that the server is ready. Then we create a new $MJFOU instance, listen on the client socket, and handle its commands. Simple, right?

[ 298 ]

Understanding FTP

Chapter 8

Two things are missing from this code:

The $MJFOUOFX method

The $MJFOUIBOEMF@DNE method

Let's start with the first one:

JNQM$MJFOU\

GOOFXTUSFBN5DQ4USFBN $MJFOU\

$MJFOU\

DXE1BUI#VGGSPN

TUSFBNTUSFBN

OBNF/POF

^

^

^

Nothing fancy here; the current path is (it corresponds to the root of the server, not to the root of the filesystem!). We have set the client's stream, and the name hasn't been defined yet.

Now let's see the $MJFOUIBOEMF@DNE method (needless to say, it'll be the core of this FTP server):

GOIBOEMF@DNENVUTFMGDNE$PNNBOE\

QSJOUMO \^DNE

NBUDIDNE\

$PNNBOE"VUI TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF$PNNBOE/PU*NQMFNFOUFE

/PUJNQMFNFOUFE

$PNNBOE6OLOPXOT TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF6OLOPXO$PNNBOE

/PUJNQMFNFOUFE

^

^

And that's it! Ok, so that's not really it. We still have a lot to add. But my point is, we now only have to add other commands here to make it all work.

[ 299 ]





Understanding FTP

Chapter 8

Commands implementation

In the previous code, we only handled one command; any other command will receive an VOLOPXODPNNBOE answer from the server. Also, our "VUI implementation says it's not implemented. So, to sum this up, we handle one command that answers that it's not implemented. Crazy, right? For the "VUI command, we'll look at this later.

Now let's implement some commands for real. Let's start with a simple one: 4ZTU. This is supposed to return which system this FTP server is running on. For some reason, we won't answer that, and we'll just send back an answer-nothing usable.

Implementing the SYST command

First, let's add a new entry into the $PNNBOE enum (I won't do this every time, but the steps will remain the same):

FOVN$PNNBOE\

"VUI

4ZTU

6OLOPXO4USJOH

^

Then, let's update the BT@SFG implementation:

JNQM"T3FGTUS GPS$PNNBOE\

GOBT@SFGTFMG TUS\

NBUDITFMG\

$PNNBOE"VUI "65)

$PNNBOE4ZTU 4:45

$PNNBOE6OLOPXO@ 6/,/

^

^

^

Finally, let's update the $PNNBOEOFX method:

JNQM$PNNBOE\

QVCGOOFXJOQVU7FDV JP3FTVMU4FMG \

MFUNVUJUFSJOQVUTQMJU]CZUF]CZUFC

MFUNVUDPNNBOEJUFSOFYUFYQFDUDPNNBOEJO

JOQVUUP@WFD

UP@VQQFSDBTFNVUDPNNBOE

MFUEBUBJUFSOFYU

MFUDPNNBOE

NBUDIDPNNBOEBT@TMJDF\

[ 300 ]





Understanding FTP

Chapter 8

C"65) $PNNBOE"VUI

C4:45 $PNNBOE4ZTU

T

$PNNBOE6OLOPXOTUSGSPN@VUGTVOXSBQ@PSUP@PXOFE

^

0LDPNNBOE

^

^

That's it! Like I said earlier, just remember those three steps every time you add a new command and everything should be fine.

Now let's implement the command:

GOIBOEMF@DNENVUTFMGDNE$PNNBOE\

QSJOUMO \^DNE

NBUDIDNE\

$PNNBOE"VUI TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF$PNNBOE/PU*NQMFNFOUFE

/PUJNQMFNFOUFE

$PNNBOE4ZTU TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF0L

*XPO UUFMM

$PNNBOE6OLOPXOT TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF6OLOPXO$PNNBOE

/PUJNQMFNFOUFE

^

^

And that's it! We implemented a new command (which doesn't do much, but that isn't the point)!

Implementing the USER command

Since we have a OBNF in our $MJFOU structure, it'd be nice to have some use for it, right? So, as the title says, let's implement the 64&3 command. Since this command takes an argument, I'll go through the command implementation steps once again, so you'll have an example of a command taking a parameter.

First, let's update the FOVN$PNNBOE:

FOVN$PNNBOE\

"VUI

4ZTU

6TFS4USJOH

6OLOPXO4USJOH

^

[ 301 ]

Understanding FTP

Chapter 8

Then, we update the BT@SFG implementation:

JNQM"T3FGTUS GPS$PNNBOE\

GOBT@SFGTFMG TUS\

NBUDITFMG\

$PNNBOE"VUI "65)

$PNNBOE4ZTU 4:45

$PNNBOE6TFS 64&3

$PNNBOE6OLOPXO@ 6/,/

^

^

^

Finally, we update the $PNNBOEOFX method:

JNQM$PNNBOE\

QVCGOOFXJOQVU7FDV JP3FTVMU4FMG \

MFUNVUJUFSJOQVUTQMJU]CZUF]CZUFC

MFUNVUDPNNBOEJUFSOFYUFYQFDUDPNNBOEJO

JOQVUUP@WFD

UP@VQQFSDBTFNVUDPNNBOE

MFUEBUBJUFSOFYU

MFUDPNNBOE

NBUDIDPNNBOEBT@TMJDF\

C"65) $PNNBOE"VUI

C4:45 $PNNBOE4ZTU

C64&3 $PNNBOE6TFSEBUBNBQ]CZUFT]

4USJOHGSPN@VUGCZUFTUP@WFDFYQFDUDBOOPU

DPOWFSUCZUFTUP4USJOHVOXSBQ@PS@EFGBVMU

T

$PNNBOE6OLOPXOTUSGSPN@VUGTVOXSBQ@PSUP@PXOFE

^

0LDPNNBOE

^

^

Phew, all done! Now we just need to implement the function (which is quite simple, I promise):

GOIBOEMF@DNENVUTFMGDNE$PNNBOE\

QSJOUMO \^DNE

NBUDIDNE\

$PNNBOE"VUI TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF$PNNBOE/PU*NQMFNFOUFE

/PUJNQMFNFOUFE

$PNNBOE4ZTU TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF0L

*XPO UUFMM

$PNNBOE6TFSVTFSOBNF \

[ 302 ]





Understanding FTP

Chapter 8

JGVTFSOBNFJT@FNQUZ\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF*OWBMJE1BSBNFUFS0S"SHVNFOU

*OWBMJEVTFSOBNF

^FMTF\

TFMGOBNFVTFSOBNFUP@PXOFE

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF6TFS-PHHFE*O

GPSNBU8FMDPNF\^VTFSOBNF

^

^

$PNNBOE6OLOPXOT TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF6OLOPXO$PNNBOE

/PUJNQMFNFOUFE

^

^

Here's a little explanation just in case you need it; if we receive an empty username (or no username at all), we consider this as an invalid parameter and return

*OWBMJE1BSBNFUFS0S"SHVNFOU. Otherwise, everything is fine and we return 6TFS-PHHFE*O.

If you're wondering why we didn't return 3FTVMU$PEF0L, it's because the RFC states as such. Once again, every command, what it does, and what it should return is described there. If you feel lost, don't hesitate to read it again!

Implementing the NOOP command

This topic is quite a simple one. /001 stands for no operation. It takes no argument and does nothing. Just because I'm a nice person, here's the code for the /001 command in the $MJFOUIBOEMF@DNE method:

$PNNBOE/P0Q TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF0L%PJOH

OPUIJOH

Yes, I know, you're amazed by such wonderful code. But don't worry, you'll able to write something as good as this when you grow older!

It's now time to implement the next command!

[ 303 ]





Understanding FTP

Chapter 8

Implementing the PWD command

This command is very simple as well. 18% stands for print working directory. Once again, it's not the one from your system but the one from your server (so again, corresponds to the folder where you started the server).

The command doesn't take any argument, so there's no need to show you everything again.

Let's just focus on the command handling:

$PNNBOE1XE \

MFUNTHGPSNBU\^TFMGDXEUP@TUSVOXSBQ@PS

JGNTHJT@FNQUZ\

MFUNFTTBHFGPSNBU=\^=NTH

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF1"5)/".&$SFBUFE

GPSNBU=\^=

NTH

^FMTF\

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF'JMF/PU'PVOE/P

TVDIGJMFPSEJSFDUPSZ

^

^

Nothing complicated; we try to display the path, and if we fail, we return an error. The only strange thing is that if everything goes fine, we have to return 1"5)/".&$SFBUFE. This RFC

is really strange...

Sorry, this was the last simple command. Now we'll go deeper into the FTP and its strange RFC. The following command is just a nice introduction to what's coming next. (I hope I didn't scare you!)

Implementing the TYPE command

For now, we'll have an implementation of the 5:1& command that does nothing. We'll come back to it in the following chapters. However, a bit of explanation will come in handy, I assume.

5:1& stands for the representation type. When you're transferring data over the data connection (which is different from the command connection, which is the only one we've been using until now), you can transfer data differently.

[ 304 ]





Understanding FTP

Chapter 8

By default, the transfer type is ASCII (the main difference is that all have to be transformed into ). We'll use the image one (where you send data as you have it) to make our lives easier.

Once again, we'll go back to this implementation in later chapters.

For now, let's just add a 5ZQF command that doesn't take any argument: $PNNBOE5ZQF TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF0L

5SBOTGFSUZQFDIBOHFETVDDFTTGVMMZ

OK, we're lying a bit, but we'll have to deal with it for the moment.

We're almost at the end of the basics, but there's one last command to implement before you can try accessing the server using an FTP client.

Implementing the LIST command

The -*45 command returns a list of the current files and folders of the current folder or at the given parameter path. This is already very difficult itself because you need to check that the final path is accessible to the user (for example, if you receive GPP when you're at , there's an issue). But that's not all! When you're transferring the files and folders list, there is no official way to format it! Fun, right? Luckily, most of the FTP clients follow some kind of non-official RFC for this case, and we'll use it.

In addition to all of this, this command is the first one that we'll implement that uses the data connection. This requires you to add another command: 1"47.

*NQMFNFOUJOHUIF1"47DPNNBOE

To be able to make this command work, we need to add a few new fields in our $MJFOU

struct:

TUSVDU$MJFOU\

DXE1BUI#VG

TUSFBN5DQ4USFBN

OBNF0QUJPO4USJOH

EBUB@XSJUFS0QUJPO5DQ4USFBN

^

[ 305 ]

Understanding FTP

Chapter 8

We now need to update the $MJFOUOFX method as well: GOOFXTUSFBN5DQ4USFBN $MJFOU\

$MJFOU\

DXE1BUI#VGGSPN

TUSFBNTUSFBN

OBNF/POF

EBUB@XSJUFS/POF

^

^

The 1"47 command doesn't take arguments, so I'll let you add it to the structures and everything. Let's focus on the interesting part:

"EEJOHTPNFOFXJNQPSUT

VTFTUEOFU\*Q"EES*QW"EES4PDLFU"EES^

$PNNBOE1BTW \

JGTFMGEBUB@XSJUFSJT@TPNF\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO"MSFBEZ

MJTUFOJOH

^FMTF\

MFUQPSU

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF&OUFSJOH1BTTJWF.PEF

GPSNBU\^\^QPSU QPSUY''

MFUBEES4PDLFU"EESOFX*Q"EES7*QW"EESOFX

QPSU

MFUMJTUFOFS5DQ-JTUFOFSCJOEBEESVOXSBQ

NBUDIMJTUFOFSJODPNJOHOFYU\

4PNF0LDMJFOU \

TFMGEBUB@XSJUFS4PNFDMJFOU

^

@ \

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF4FSWJDF/PU"WBJMBCMFJTTVFT

IBQQFO

^

^

^

^

[ 306 ]

Understanding FTP

Chapter 8

Phew... Let's explain all this:

JGTFMGEBUB@XSJUFSJT@TPNF\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO"MSFBEZMJTUFOJOH

^

If we already have a data connection with this client, there's no need to open a new one, so we don't do anything else:

MFUQPSUV

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF&OUFSJOH1BTTJWF.PEF

GPSNBU\^\^QPSU QPSUY''

This part is a bit more tricky. First, we pick a port (the best way would be to check if the port is available first; we'll do this in later chapters). Then, we have to tell the client where it should connect to.

This is where things get a bit more complicated. We have to transfer the address as follows: JQJQJQJQQPSUQPSU

Every JQ part has to be 8-bits long (so 1-byte long), whereas, each QPSU part has to be 16-bits long (so, 2 bytes). The first part is easy; we just print localhost. However, the second part requires you to perform some binary operation.

To get the first byte only is simple; we just have to move 8 bits to the right. To sum this up, take a look at this:



This is our V. We now shift 8 bits to the right:



Tadaa!

For the second part, we could move 8 bits to the left and then 8 bits to the right, or we could just use the BOE binary operator. Here's a little scheme to explain this: Now let's take a nice binary to the hexadecimal converter and check the result: Y''

[ 307 ]





Understanding FTP

Chapter 8

Now if we perform this operation, we get the following: Y''





Now we have the last 8 bits only. Great! The last part of the command handling is very easy:

MFUBEES4PDLFU"EESOFX*Q"EES7*QW"EESOFX

QPSU

MFUMJTUFOFS5DQ-JTUFOFSCJOEBEESVOXSBQ

NBUDIMJTUFOFSJODPNJOHOFYU\

4PNF0LDMJFOU \

TFMGEBUB@XSJUFS4PNFDMJFOU

^

@ \

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF4FSWJDF/PU"WBJMBCMF

JTTVFT

IBQQFO

^

^

We bind the address and port, wait for a client to connect, and then assign it to our data writer. There's nothing problematic in this.

#BDLUPUIF-*45DPNNBOE

Now that we can handle a data connection, let's implement the -*45! For now, let's implement it without parameters (once again, we'll see in later chapters how to handle the

-*45 parameter). As usual, I'll let you add everything where it's needed and we'll just focus on the command handling:

$PNNBOE-JTU \

JGMFU4PNFSFGNVUEBUB@XSJUFSTFMGEBUB@XSJUFS\

MFUNVUUNQ1BUI#VGGSPN

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO

4UBSUJOHUPMJTUEJSFDUPSZ

MFUNVUPVU4USJOHOFX

GPSFOUSZJOSFBE@EJSUNQVOXSBQ\

GPSFOUSZJOEJS\

JGMFU0LFOUSZFOUSZ\

BEE@GJMF@JOGPFOUSZQBUINVUPVU

^

^

[ 308 ]

Understanding FTP

Chapter 8

TFOE@EBUBEBUB@XSJUFSPVU

^

^FMTF\

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF$POOFDUJPO$MPTFE

/PPQFOFEEBUBDPOOFDUJPO

^

JGTFMGEBUB@XSJUFSJT@TPNF\

TFMGEBUB@XSJUFS/POF

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF$MPTJOH%BUB$POOFDUJPO5SBOTGFS

EPOF

^

^

There's nothing complicated here either too. Once the transfer is over, we close the client socket and move on. What remains to be added are the TFOE@EBUB and the BEE@GJMF@JOGP functions. Let's start with the first one: GOTFOE@EBUBTUSFBNNVU5DQ4USFBNTTUS\

XSJUFTUSFBN\^TVOXSBQ

^

Easy, there's no error handling, so it just stands on one line. Now let's see the BEE@GJMF@JOGP function:

GOBEE@GJMF@JOGPQBUI1BUI#VGPVUNVU4USJOH\

MFUFYUSBJGQBUIJT@EJS\^FMTF\^

MFUJT@EJSJGQBUIJT@EJS\E^FMTF\^

MFUNFUBNBUDITUEGTNFUBEBUBQBUI\

0LNFUB NFUB

@ SFUVSO

^

MFUUJNFGJMF@TJ[FHFU@GJMF@JOGPNFUB

MFUQBUINBUDIQBUIUP@TUS\

4PNFQBUI NBUDIQBUITQMJUMBTU\

4PNFQBUI QBUI

@ SFUVSO

^

@ SFUVSO

^

MFUSJHIUTJGNFUBQFSNJTTJPOTSFBEPOMZ\

SSS

^FMTF\

SXSXSX

^

MFUGJMF@TUSGPSNBU\JT@EJS^\SJHIUT^\MJOLT^\PXOFS^

[ 309 ]

Understanding FTP

Chapter 8

\HSPVQ^\TJ[F^\NPOUI^

\EBZ^\IPVS^\NJO^\QBUI^\FYUSB^=S=O

JT@EJSJT@EJS

SJHIUTSJHIUT

MJOLTOVNCFSPGMJOLT

PXOFSBOPOZNPVTPXOFSOBNF

HSPVQBOPOZNPVTHSPVQOBNF

TJ[FGJMF@TJ[F

NPOUI.0/5)4<UJNFUN@NPOBTVTJ[F>

EBZUJNFUN@NEBZ

IPVSUJNFUN@IPVS

NJOUJNFUN@NJO

QBUIQBUI

FYUSBFYUSB

PVUQVTI@TUSGJMF@TUS

QSJOUMO \^GJMF@TUS

^

To make this code work, you'll also need the following:

<NBDSP@VTF>

FYUFSODSBUFDGH@JG

DGH@JG\

JG<DGHXJOEPXT>\

GOHFU@GJMF@JOGPNFUB.FUBEBUB UJNF5NV\

VTFTUEPTXJOEPXTQSFMVEF

UJNFBUUJNF5JNFTQFDOFXNFUBMBTU@XSJUF@UJNF

NFUBGJMF@TJ[F

^

^FMTF\

GOHFU@GJMF@JOGPNFUB.FUBEBUB UJNF5NV\

VTFTUEPTVOJYQSFMVEF

UJNFBUUJNF5JNFTQFDOFXNFUBNUJNF

NFUBTJ[F

^

^

^

Don't forget to add DGH@JG in your $BSHPUPNM:

DGHJG

DGHJG is really good at help you do conditional compilation in a more easily readable way. A point to note about the HFU@GJMF@JOGP function nowbthis is one of the rare things that can't be performed in the same way on all systems.

[ 310 ]





Understanding FTP

Chapter 8

Here, Windows has its own version and Unix has another. However, the two functions take the same argument (the import), and one function call changes. Let's go back to the BEE@GJMF@JOGP function now:

I suppose you recognized the output of the MT command, right? Apparently, the non-official RFC is working as follows:

ESSSNFNF+BOGPP

SXSXSXNFNF.BSTPNF@GJMF

First, E if it's a directory or if it isn't. Then, the rights (just like on Unix platforms):

<SXY><SXY><SXY>

The first SXY is for the owner, the second is about the group, and the last one is about everyone. Here, S stands for read access, X stands for write access, and Y stands for execution access.

The rest seems explicit enough on its own, so there's no need to explain it.

Implementing the CWD command

The $8% command allows the user to change its current folder location. However, it's far from easy to do.

Before going into the implementation of this command, we'll need to discuss a potential security issue: paths.

Imagine the user is at the location (which will corresponds to, say, IPNFTPNFPOFTPNFXIFSF) and requests GPP. If we just accept the path and move the user to this location, it'll end up at IPNFTPNFPOF. This means that the users could access all of your computer without issue. You see the problem now?

Luckily for us, 3VTU has a nice method on 1BUI that allows us to fix this huge security issue. I'm talking about 1BUIDBOPOJDBMJ[F (which is an alias of the GTDBOPOJDBMJ[F function).

So, what does this function do? Let's take an example: MFUQBUI1BUIOFXGPPUFTUCBSST

BTTFSU@FRQBUIDBOPOJDBMJ[FVOXSBQ

1BUI#VGGSPNGPPCBSST

[ 311 ]

Understanding FTP

Chapter 8

As you can see, it interprets the path, normalizes everything ( removes the folder component), and resolves symbolic links as well. Quite magical, right?

Of course, all good things have a downside, and so does DBOPOJDBMJ[F.: it can only work on real paths. If a part of the path doesn't exist, the function will just fail. It's pretty easy to get through it when you know it, but it can sound surprising at first.

So, how do we fix this? Well, we need to play with a real path. So first, we need to append the user's server path to the real server path (the one it has on the computer). Once this is done, we just append the path requested by the user and call DBOPOJDBMJ[F.

That's not very complicated, but is a bit annoying to play with at first. Don't worry, though, the code is coming!

If you wonder why we're not just using the DISPPU function (which would solve all problems), remember that this FTP server is supposed to work on every platform.

So first, let's add a new command entry to the FOVN$PNNBOE : $XE1BUI#VG

Good, now let's add it to the $PNNBOEOFX method matching: C$8% $PNNBOE$XEEBUBNBQ]CZUFT]

1BUIOFXTUSGSPN@VUGCZUFTVOXSBQUP@QBUI@CVGVOXSBQ

Perfect! I'll let you add it into the "T3FG implementation as well. Now it's time to go into the real implementation:

$PNNBOE$XEEJSFDUPSZ TFMGDXEEJSFDUPSZ

For once, to make our life easier, we'll create a new method in our $MJFOU, so all the code from the $8% command won't fill the FOVN:

GODPNQMFUF@QBUITFMGQBUI1BUI#VGTFSWFS@SPPU1BUI#VG

3FTVMU1BUI#VGJP&SSPS \

MFUEJSFDUPSZTFSWFS@SPPUKPJOJGQBUIIBT@SPPU\

QBUIJUFSTLJQDPMMFDU

^FMTF\

QBUI

^

MFUEJSEJSFDUPSZDBOPOJDBMJ[F

JGMFU0LSFGEJSEJS\

JGEJSTUBSUT@XJUITFSWFS@SPPU\

SFUVSO&SSJP&SSPS,JOE1FSNJTTJPO%FOJFEJOUP

^

[ 312 ]

Understanding FTP

Chapter 8

^

EJS

^

GODXENVUTFMGEJSFDUPSZ1BUI#VG\

MFUTFSWFS@SPPUFOWDVSSFOU@EJSVOXSBQ

MFUQBUITFMGDXEKPJOEJSFDUPSZ

JGMFU0LEJSTFMGDPNQMFUF@QBUIQBUITFSWFS@SPPU\

JGMFU0LQSFGJYEJSTUSJQ@QSFGJYTFSWFS@SPPU

NBQ]Q]QUP@QBUI@CVG\

TFMGDXEQSFGJYUP@QBUI@CVG

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF0L

GPSNBU%JSFDUPSZDIBOHFEUP=\^=

EJSFDUPSZEJTQMBZ

SFUVSO

^

^

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF'JMF/PU'PVOE/PTVDI

GJMFPSEJSFDUPSZ

^

OK, that's a lot of code. Let's now go through the execution flow: MFUTFSWFS@SPPUFOWDVSSFOU@EJSVOXSBQ

For now, you can't set which folder the server is running on; it'll be changed later on: MFUQBUITFMGDXEKPJOEJSFDUPSZ

First, we join the requested directory to the current directory of the user: JGMFU0LEJSTFMGDPNQMFUF@QBUIQBUITFSWFS@SPPU\

Things start to get funny in here. The whole canonicalization process is in there.

Now let's append the user path to the (real) server path: MFUEJSFDUPSZTFSWFS@SPPUKPJOJGQBUIIBT@SPPU\

QBUIJUFSTLJQDPMMFDU

^FMTF\

QBUI

^

So, if the path is an absolute one (starting with on Unix or a prefix on Windows such as D), we need to remove the first component of the path, otherwise, we just append it.

[ 313 ]

Understanding FTP

Chapter 8

We now have a full and potentially existent path. Let's canonicalize it: MFUEJSEJSFDUPSZDBOPOJDBMJ[F

Now we have one more thing to checkbif the path doesn't start with the server root, then it means that the user tried to cheat on us and tried to access non-accessible folders. Here is how we do it:

JGMFU0LSFGEJSEJS\

JGEJSTUBSUT@XJUITFSWFS@SPPU\

SFUVSO&SSJP&SSPS,JOE1FSNJTTJPO%FOJFEJOUP

^

^

In the case that DBOPOJDBMJ[F returned an error, there's no need to check if it did (since it's already an error). If it succeeded but doesn't start with TFSWFS@SPPU, then we return an error.

That's it for this function. Now, we'll return the result to the caller and can go back to the DXE method:

JGMFU0LEJSTFMGDPNQMFUF@QBUIQBUITFSWFS@SPPU\

JGMFU0LQSFGJYEJSTUSJQ@QSFGJYTFSWFS@SPPU

NBQ]Q]QUP@QBUI@CVG\



^

^

Once we get the full directory path and have confirmed it was okay, we need to remove the TFSWFS@SPPU prefix to get the path from our server root: TFMGDXEQSFGJYUP@QBUI@CVG

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF0L

GPSNBU%JSFDUPSZDIBOHFEUP=\^=

EJSFDUPSZEJTQMBZ

SFUVSO

Finally, once this is done, we can just set the path to the user and send back a message that the command succeeded (and return to avoid sending back that we failed!).

If anything goes wrong, we send back the following: TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF'JMF/PU'PVOE/PTVDIGJMF

PSEJSFDUPSZ

That's it for this command! You now know how to avoid a security issue by checking received paths provided by the clients.

[ 314 ]





Understanding FTP

Chapter 8

Implementing the CDUP command

$%61 is used to go up to the parent directory. In comparison to the $8% command implementation, it'll be a piece of cake! The $%61 command doesn't take arguments, so I'll let you add it to FOVNT. Now, let's focus on the command implementation: $PNNBOE$E6Q \

JGMFU4PNFQBUITFMGDXEQBSFOUNBQ1BUIUP@QBUI@CVG\

TFMGDXEQBUI

^

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF0L%POF

^

And that's it. There's need to check if the parent folder exists, as it does. And if we're already at the root, then there's no need to do anything. Isn't it wonderful?

Full implementation of the LIST command

Now that we know how to play with paths nicely, it'd be a shame not fully implement the

-*45 command, right?

To complete it, you'll need to update the $PNNBOE-JTU variant in order to make it accept 1BUI#VG as an argument.

So, we currently have the following code:

$PNNBOE-JTU \

JGMFU4PNFSFGNVUEBUB@XSJUFSTFMGEBUB@XSJUFS\

MFUNVUUNQ1BUI#VGGSPN

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO

4UBSUJOHUPMJTUEJSFDUPSZ

MFUNVUPVU4USJOHOFX

GPSFOUSZJOSFBE@EJSUNQVOXSBQ\

GPSFOUSZJOEJS\

JGMFU0LFOUSZFOUSZ\

BEE@GJMF@JOGPFOUSZQBUINVUPVU

^

^

TFOE@EBUBEBUB@XSJUFSPVU

^

^FMTF\

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF$POOFDUJPO$MPTFE

/PPQFOFEEBUB

DPOOFDUJPO

[ 315 ]

Understanding FTP

Chapter 8

^

JGTFMGEBUB@XSJUFSJT@TPNF\

TFMGEBUB@XSJUFS/POF

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF$MPTJOH%BUB$POOFDUJPO5SBOTGFS

EPOF

^

^

Let's update it as follows:

$PNNBOE-JTUQBUI \

JGMFU4PNFSFGNVUEBUB@XSJUFSTFMGEBUB@XSJUFS\

MFUTFSWFS@SPPUFOWDVSSFOU@EJSVOXSBQ

MFUQBUITFMGDXEKPJOQBUIVOXSBQ@PS@EFGBVMU

MFUEJSFDUPSZ1BUI#VGGSPNQBUI

JGMFU0LQBUITFMGDPNQMFUF@QBUIEJSFDUPSZ

TFSWFS@SPPU\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO

4UBSUJOHUPMJTUEJSFDUPSZ

MFUNVUPVU4USJOHOFX

GPSFOUSZJOSFBE@EJSQBUIVOXSBQ\

GPSFOUSZJOEJS\

JGMFU0LFOUSZFOUSZ\

BEE@GJMF@JOGPFOUSZQBUINVUPVU

^

^

TFOE@EBUBEBUB@XSJUFSPVU

^

^FMTF\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF*OWBMJE1BSBNFUFS0S"SHVNFOU

/PTVDIGJMFPSEJSFDUPSZ

^

^FMTF\

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF$POOFDUJPO$MPTFE

/PPQFOFEEBUBDPOOFDUJPO

^

JGTFMGEBUB@XSJUFSJT@TPNF\

TFMGEBUB@XSJUFS/POF

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF$MPTJOH%BUB$POOFDUJPO5SBOTGFSEPOF

^

^

[ 316 ]

Understanding FTP

Chapter 8

To put it simply, we just added the following line: MFUQBUITFMGDXEKPJOQBUIVOXSBQ@PS@EFGBVMU

MFUEJSFDUPSZ1BUI#VGGSPNQBUI

JGMFU0LQBUITFMGDPNQMFUF@QBUIEJSFDUPSZTFSWFS@SPPU\



^FMTF\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF*OWBMJE1BSBNFUFS0S"SHVNFOU

/PTVDIGJMFPSEJSFDUPSZ

^

Thanks to the $MJFOUDPNQMFUF@QBUI method, things were pretty easy with the path manipulation. So, what happens if the given path is a file? We don't check such a case but we should! Let's replace the following lines:

GPSFOUSZJOSFBE@EJSQBUIVOXSBQ\

GPSFOUSZJOEJS\

JGMFU0LFOUSZFOUSZ\

BEE@GJMF@JOGPFOUSZQBUINVUPVU

^

^

TFOE@EBUBEBUB@XSJUFSPVU

^

With:

JGQBUIJT@EJS\

GPSFOUSZJOSFBE@EJSQBUIVOXSBQ\

GPSFOUSZJOEJS\

JGMFU0LFOUSZFOUSZ\

BEE@GJMF@JOGPFOUSZQBUINVUPVU

^

^

TFOE@EBUBEBUB@XSJUFSPVU

^

^FMTF\

BEE@GJMF@JOGPQBUINVUPVU

^

And that's it! Luckily for us, we did things correctly the first time, so it just works.

[ 317 ]





Understanding FTP

Chapter 8

Implementing the MKD command

The .,% stands for make directory (yes, exactly like the Unix command but shorter). Just like -*45 and $8%, it takes 1BUI#VG as an argument. I'll let you handle the other adds as usual and focus on the command implementation:

$PNNBOE.LEQBUI TFMGNLEQBUI

Just like last time, we'll create a new method:

VTFTUEGTDSFBUF@EJS

GONLETFMGQBUI1BUI#VG\

MFUTFSWFS@SPPUFOWDVSSFOU@EJSVOXSBQ

MFUQBUITFMGDXEKPJOQBUI

JGMFU4PNFQBSFOUQBUIQBSFOUNBQ]Q]QUP@QBUI@CVG\

JGMFU0LNVUEJSTFMGDPNQMFUF@QBUIQBSFOU

TFSWFS@SPPU\

JGEJSJT@EJS\

JGMFU4PNFGJMFOBNFQBUIGJMF@OBNFNBQ]Q]

QUP@PT@TUSJOH\

EJSQVTIGJMFOBNF

JGDSFBUF@EJSEJSJT@PL\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF1"5)/".&$SFBUFE

'PMEFSTVDDFTTGVMMZDSFBUFE

SFUVSO

^

^

^

^

^

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF'JMF/PU'PVOE

$PVMEO UDSFBUFGPMEFS

^

Once again, a few things have to be done before even actually trying to make the directory.

First, we need to check whether all the elements of the given path are folders (well, only the last one in fact since otherwise, the $MJFOUDPNQMFUF@QBUI method will fail otherwise).

Then we need to once again, canonicalize this path (by calling the $MJFOUDPNQMFUF@QBUI method). Finally, we push the filename to the received path.

[ 318 ]





Understanding FTP

Chapter 8

The main difference here is that we don't strip the TFSWFS@SPPU path from the path returned by $MJFOUDPNQMFUF@QBUI.

Once all of this is done, we can try to create the folder by using the DSFBUF@EJS function. If it goes well, we then return 3FTVMU$PEF1"5)/".&$SFBUFE (and for once it makes sense!).

If any error occurs at any level, we just send that the path was incorrect.

That's it for this command!

Implementing the RMD command

Now that we can create folders, it'd be nice to be able to remove them, right? That's what 3.% (which stands for remove directory) is supposed to do!

Just like .,% (and the others), 3.% takes 1BUI#VG as an argument. Once again, and as usual, I'll let you handle the $PNNBOE part so we can focus on the command implementation: $PNNBOE3NEQBUI TFMGSNEQBUI

Yep, it's a new method once again. It becomes a habit at this point I suppose?

VTFTUEGTSFNPWF@EJS@BMM

GOSNETFMGQBUI1BUI#VG\

MFUTFSWFS@SPPUFOWDVSSFOU@EJSVOXSBQ

JGMFU0LQBUITFMGDPNQMFUF@QBUIQBUITFSWFS@SPPU\

JGSFNPWF@EJS@BMMQBUIJT@PL\

TFOE@DNENVUTFMGTUSFBN

3FTVMU$PEF3FRVFTUFE'JMF"DUJPO0LBZ

'PMEFSTVDDFTTGVMMZSFNPWFE

SFUVSO

^

^

TFOE@DNENVUTFMGTUSFBN3FTVMU$PEF'JMF/PU'PVOE

$PVMEO USFNPWFGPMEFS

^

And that's it! This is even easier than .,% since we don't need to check if the last potential parent is a folder. Once we have confirmed that the path was an authorized one, we can just remove it.

With all these commands, I think we can say that we have a very fine base to build upon in order to make a complete FTP server.

[ 319 ]





Understanding FTP

Chapter 8

Testing it

You now have a (very) basic FTP server implementation. You can connect to the server and list the files and folders in the current folder.

Start it with DBSHPSVO and give it a try! I recommend that you use 'JMF;JMMB. This is a great FTP client. Connect to MPDBMIPTU on the port and use the BOPOZNPVT username (or none), and you should be able to have a bit of fun already:

'JHVSF

Information on the file transfers and additional commands will be covered in later chapters.

[ 320 ]





Understanding FTP

Chapter 8

Summary

In this chapter, we looked at the basics of the FTP. We now have a simple (synchronous) server implementation, and you should have a good idea about how all of this is working.

We also looked at a potential security issue and how to fix it.

The following chapters will introduce you to asynchronous programming in Rust. Thanks to this chapter, it'll go a lot quicker on the FTP RFC side so we can focus on the asynchronous part.

[ 321 ]





9

Implementing an Asynchronous

FTP Server

In the previous chapter, we wrote a synchronous FTP server. Now, we'll write an asynchronous version with UPLJP, the asynchronous IO (Input/Output) library for Rust.

We'll cover the following topics:

Asynchronous servers

Futures

Streams

Tokio

Async/await

Error handling

Advantages of asynchronous IO

Asynchronous IO allows us to send a request without waiting for its result, we'll get notified somehow later when we receive the response. This enables our programs to be more concurrent and scale better.

In the previous chapter, we used threads in order to avoid blocking other clients while we wait for a response. Using threads has a cost, though, besides the fact that threads require more memory, they also impose a performance cost because they require a context switch when the code goes from one thread to the other.





Implementing an Asynchronous FTP Server Chapter 9

Disadvantages of asynchronous IO

However, using asynchronous IO does not come without drawbacks. Using asynchronous IO is harder than using synchronous IO. With asynchronous IO, we also need a way to know when an event has terminated. So, we need to learn a new way to manage the IO

events and it'll take more time to implement the same software that we wrote in the previous chapter.

Creating the new project

Let's start by creating a new binary project, as usual: cargo new --bin ftp-server

We'll add the following dependencies in the $BSHPUPNM file:

<EFQFOEFODJFT>

CZUFT?

UPLJPDPSF?

UPLJPJP?

<EFQFOEFODJFTGVUVSFTBXBJU>

HJUIUUQTHJUIVCDPNBMFYDSJDIUPOGVUVSFTBXBJU

As you can see here, we specify a dependency via a Git URL. This dependency is using nightly-only features, so make sure you're using the nightly compiler by running this command:

rustup default nightly

Let's start our NBJO module by adding the required FYUFSODSBUF statements:

<GFBUVSFQSPD@NBDSPDPOTFSWBUJWF@JNQM@USBJUHFOFSBUPST> FYUFSODSBUFCZUFT

FYUFSODSBUFGVUVSFT@BXBJUBTGVUVSFT

FYUFSODSBUFUPLJP@DPSF

FYUFSODSBUFUPLJP@JP

As you can see, we're using some nightly features. These are needed by the GVUVSFT

BXBJU crate. We also decided to import this crate under another name, GVUVSFT, because it exports the same types and functions as the GVUVSFT crate itself.

[ 323 ]

Implementing an Asynchronous FTP Server Chapter 9

We'll copy some code from the previous chapter and put them in the new module, for better organization. Here are the new modules:

NPEDNE

NPEGUQ

In a new file, called TSDDNEST, put the following code: VTFTUEQBUI\1BUI1BUI#VG^

VTFTUETUS\TFMG'SPN4US^

VTFFSSPS\&SSPS3FTVMU^

<EFSJWF$MPOF%FCVH>

QVCFOVN$PNNBOE\

"VUI

$XE1BUI#VG

-JTU0QUJPO1BUI#VG

.LE1BUI#VG

/P0Q

1PSUV

1BTW

1XE

2VJU

3FUS1BUI#VG

3NE1BUI#VG

4UPS1BUI#VG

4ZTU

5ZQF5SBOTGFS5ZQF

$E6Q

6OLOPXO4USJOH

6TFS4USJOH

^

We first have an enumeration representing the different commands and their parameters: JNQM"T3FGTUS GPS$PNNBOE\

GOBT@SFGTFMG TUS\

NBUDITFMG\

$PNNBOE"VUI "65)

$PNNBOE$XE@ $8%

$PNNBOE-JTU@ -*45

$PNNBOE1BTW 1"47

$PNNBOE1PSU@ 1035

$PNNBOE1XE 18%

$PNNBOE2VJU 26*5

$PNNBOE3FUS@ 3&53

$PNNBOE4UPS@ 4503

[ 324 ]

Implementing an Asynchronous FTP Server Chapter 9

$PNNBOE4ZTU 4:45

$PNNBOE5ZQF@ 5:1&

$PNNBOE6TFS@ 64&3

$PNNBOE$E6Q $%61

$PNNBOE.LE@ .,%

$PNNBOE3NE@ 3.%

$PNNBOE/P0Q /001

$PNNBOE6OLOPXO@ 6/,/EPFTO UFYJTU

^

^

^

Here, we create a method to get the string representation of a command: JNQM$PNNBOE\

QVCGOOFXJOQVU7FDV 3FTVMU4FMG \

MFUNVUJUFSJOQVUTQMJU]CZUF]CZUFC

MFUNVUDPNNBOEJUFSOFYUPL@PS@FMTF

]]&SSPS.THFNQUZDPNNBOEUP@TUSJOHUP@WFD

UP@VQQFSDBTFNVUDPNNBOE

MFUEBUBJUFSOFYUPL@PS@FMTF]]&SSPS.THOPDPNNBOE

QBSBNFUFSUP@TUSJOH

MFUDPNNBOE

NBUDIDPNNBOEBT@TMJDF\

C"65) $PNNBOE"VUI

C$8% $PNNBOE$XEEBUBBOE@UIFO]CZUFT]

0L1BUIOFXTUSGSPN@VUGCZUFTUP@QBUI@CVG

C-*45 $PNNBOE-JTUEBUBBOE@UIFO]CZUFT]

0L1BUIOFXTUSGSPN@VUGCZUFTUP@QBUI@CVGPL

C1"47 $PNNBOE1BTW

C1035 \

MFUBEESEBUBTQMJU]CZUF]CZUFC

GJMUFS@NBQ]CZUFT]

TUSGSPN@VUGCZUFTPL

BOE@UIFO]TUSJOH]

VGSPN@TUSTUSJOHPL

DPMMFDU7FDV

JGBEESMFO\

SFUVSO&SS*OWBMJEBEESFTTQPSUJOUP

^

MFUQPSUBEES<>BTV]BEES<>BT

V

JGQPSU\

SFUVSO&SS1PSUDBO UCFMFTTUIBO

JOUP

^

$PNNBOE1PSUQPSU

[ 325 ]

Implementing an Asynchronous FTP Server Chapter 9

^

C18% $PNNBOE1XE

C26*5 $PNNBOE2VJU

C3&53 $PNNBOE3FUSEBUBBOE@UIFO]CZUFT]

0L1BUIOFXTUSGSPN@VUGCZUFTUP@QBUI@CVG

C4503 $PNNBOE4UPSEBUBBOE@UIFO]CZUFT]

0L1BUIOFXTUSGSPN@VUGCZUFTUP@QBUI@CVG

C4:45 $PNNBOE4ZTU

C5:1& \

NBUDI5SBOTGFS5ZQFGSPNEBUB<>\

5SBOTGFS5ZQF6OLOPXO SFUVSO

&SSDPNNBOEOPUJNQMFNFOUFE

GPSUIBUQBSBNFUFSJOUP

UZQ \

$PNNBOE5ZQFUZQ

^

^

^

C$%61 $PNNBOE$E6Q

C.,% $PNNBOE.LEEBUBBOE@UIFO]CZUFT]

0L1BUIOFXTUSGSPN@VUGCZUFTUP@QBUI@CVG

C3.% $PNNBOE3NEEBUBBOE@UIFO]CZUFT]

0L1BUIOFXTUSGSPN@VUGCZUFTUP@QBUI@CVG

C64&3 $PNNBOE6TFSEBUBBOE@UIFO]CZUFT]

4USJOHGSPN@VUGCZUFTUP@WFDNBQ@FSS*OUPJOUP

C/001 $PNNBOE/P0Q

T

$PNNBOE6OLOPXOTUSGSPN@VUGTVOXSBQ@PSUP@PXOFE

^

0LDPNNBOE

^

^

This constructor parses a byte string as a $PNNBOE. This requires a function to convert a byte string to uppercase:

GOUP@VQQFSDBTFEBUBNVU<V>\

GPSCZUFJOEBUB\

JGCZUF B BTVCZUF [ BTV\

CZUF

^

^

^

[ 326 ]

Implementing an Asynchronous FTP Server Chapter 9

We simply decrement all lowercase letters by 32 to convert them to uppercase:

<EFSJWF$MPOF$PQZ%FCVH>

QVCFOVN5SBOTGFS5ZQF\

"TDJJ

*NBHF

6OLOPXO

^

JNQM'SPNV GPS5SBOTGFS5ZQF\

GOGSPNDV 5SBOTGFS5ZQF\

NBUDID\

C " 5SBOTGFS5ZQF"TDJJ

C * 5SBOTGFS5ZQF*NBHF

@ 5SBOTGFS5ZQF6OLOPXO

^

^

^

Here, we have an enumeration for the transfer type and a function to parse a byte character to this type. And in another file, TSDGUQST, let's write the following: QVCTUSVDU"OTXFS\

QVCDPEF3FTVMU$PEF

QVCNFTTBHF4USJOH

^

JNQM"OTXFS\

QVCGOOFXDPEF3FTVMU$PEFNFTTBHFTUS 4FMG\

"OTXFS\

DPEF

NFTTBHFNFTTBHFUP@TUSJOH

^

^

^

<EFSJWF%FCVH$MPOF$PQZ>

<SFQSV>

<BMMPXEFBE@DPEF>

QVCFOVN3FTVMU$PEF\

3FTUBSU.BSLFS3FQMZ

4FSWJDF3FBE*O999.JOVUFT

%BUB$POOFDUJPO"MSFBEZ0QFO

'JMF4UBUVT0L

0L

$PNNBOE/PU*NQMFNFOUFE4VQFSGMVPVT"U5IJT4JUF

4ZTUFN4UBUVT

[ 327 ]





Implementing an Asynchronous FTP Server Chapter 9

%JSFDUPSZ4UBUVT

'JMF4UBUVT

)FMQ.FTTBHF

4ZTUFN5ZQF

4FSWJDF3FBEZ'PS/FX6TFS

4FSWJDF$MPTJOH$POUSPM$POOFDUJPO

%BUB$POOFDUJPO0QFO

$MPTJOH%BUB$POOFDUJPO

&OUFSJOH1BTTJWF.PEF

6TFS-PHHFE*O

3FRVFTUFE'JMF"DUJPO0LBZ

1"5)/".&$SFBUFE

6TFS/BNF0LBZ/FFE1BTTXPSE

/FFE"DDPVOU'PS-PHJO

3FRVFTUFE'JMF"DUJPO1FOEJOH'VSUIFS*OGPSNBUJPO

4FSWJDF/PU"WBJMBCMF

$BOU0QFO%BUB$POOFDUJPO

$POOFDUJPO$MPTFE

'JMF#VTZ

-PDBM&SSPS*O1SPDFTTJOH

*OTVGGJDJFOU4UPSBHF4QBDF

6OLOPXO$PNNBOE

*OWBMJE1BSBNFUFS0S"SHVNFOU

$PNNBOE/PU*NQMFNFOUFE

#BE4FRVFODF0G$PNNBOET

$PNNBOE/PU*NQMFNFOUFE'PS5IBU1BSBNFUFS

/PU-PHHFE*O

/FFE"DDPVOU'PS4UPSJOH'JMFT

'JMF/PU'PVOE

1BHF5ZQF6OLOPXO

&YDFFEFE4UPSBHF"MMPDBUJPO

'JMF/BNF/PU"MMPXFE

^

We're now ready to start working on the FTP server itself.

Using Tokio

Tokio is based on the lower-level crate mio, which is itself directly based on system calls such as FQPMM (Linux), LRVFVF (FreeBSD), and IOCP (Windows). This crate is also based on the GVUVSFT crate, which provides abstractions to reason about a value (or multiple values) that will be available later. As I told you when using asynchronous I/O, the calls do not block so we need a way to know when the result of a read is available. This is where

'VUVSF and 4USFBN, two abstractions from the GVUVSFT crate, come into play.

[ 328 ]





Implementing an Asynchronous FTP Server Chapter 9

Tokio event loop

Tokio also provides an event loop, on which we will be able to execute some code (with GVUVSFT) that will be executed when some I/O events happen, such as when the result of a socket read is ready. To do so, the event loop will register events on specific file descriptors that represent sockets. It registers these events using the aforementioned system calls and then waits for any of the registered events to happen. The file descriptors and the system calls are low-level stuff that we do not need to know to use UPLJP, but it is important to understand how it works at the lower level. For instance, FQPMM does not support regular files, so if you try to wait for an event to happen on a regular file, it could block even though we're using asynchronous I/O which should not block.

Using futures

A GVUVSF represents a value that will be available later, or an error, similar to the 3FTVMU

type. A TUSFBN represents multiple values (or errors) that will be available at different times in the GVUVSF, similar to an *UFSBUPS3FTVMU5 . This crate provides many combinators such as BOE@UIFO, NBQ, and others similar to the one available on the 3FTVMU type. But, we won't use them, preferring the BTZOD/BXBJU syntax that we'll see later.

Handling errors

Before we start coding the FTP server, let's talk about how we'll be handling the errors.

Unwrapping

In the previous projects, we used the VOXSBQ or FYQFDU methods a lot. These methods are handy for fast prototyping, but when we want to write high-quality software, we should avoid them in most cases. Since we're writing an FTP server, a software that must keep running for a long time, we don't want it to crash because we called VOXSBQ and a client sent a bad command. So, we'll do proper error handling.

[ 329 ]





Implementing an Asynchronous FTP Server Chapter 9

Custom error type

Since we can get different types of errors and we want to keep track of all of them, we'll create a custom error type. Let's create a new module in which we'll put this new type: NPEFSSPS

Add it to the TSDFSSPSST file:

VTFTUEJP

VTFTUETUS6UG&SSPS

VTFTUETUSJOH'SPN6UG&SSPS

QVCFOVN&SSPS\

'SPN6UG'SPN6UG&SSPS

*PJP&SSPS

.TH4USJOH

6UG6UG&SSPS

^

Here, we have an enum representing the different errors that can happen in our FTP server to be implemented. There are UTF-8 errors since FTP is a string-based protocol and I/O

errors because we communicate over the network and communication issues can happen.

We created variants for error types coming from the standard library, which will be helpful later when we want to compose different types of errors. We also created a variant .TH for our own errors and we represent them as a 4USJOH since we only want to show them in the terminal (we could also log them to TZTMPH, for instance).

This is the standard way in Rust to represent an error type. It's a good practice to create this type, especially if your crate is a library, so that the users of your crate can know exactly why an error happened.

Displaying the error

Since we want to print the error to the terminal, we'll implement the %JTQMBZ trait for our

&SSPS type:

VTFTUEGNU\TFMG%JTQMBZ'PSNBUUFS^

VTFTFMG&SSPS

JNQM%JTQMBZGPS&SSPS\

GOGNUTFMGGPSNBUUFSNVU'PSNBUUFS GNU3FTVMU\

NBUDITFMG\

[ 330 ]

Implementing an Asynchronous FTP Server Chapter 9

'SPN6UGSFGFSSPS FSSPSGNUGPSNBUUFS

*PSFGFSSPS FSSPSGNUGPSNBUUFS

6UGSFGFSSPS FSSPSGNUGPSNBUUFS

.THSFGNTH XSJUFGPSNBUUFS\^NTH

^

^

^

For the three cases where we wrap an error from another type, we just call the corresponding GNU method of these errors. In the case that it is a .TH, we write the string using the XSJUF macro. This macro is a bit similar to QSJOU, but needs a parameter to specify where to write the formatted data.

It is not very helpful in our case, but it is recommended to also implement the &SSPS trait for custom error types:

VTFTUEFSSPS

JNQMFSSPS&SSPSGPS&SSPS\

GOEFTDSJQUJPOTFMG TUS\

NBUDITFMG\

'SPN6UGSFGFSSPS FSSPSEFTDSJQUJPO

*PSFGFSSPS FSSPSEFTDSJQUJPO

6UGSFGFSSPS FSSPSEFTDSJQUJPO

.THSFGNTH NTH

^

^

GODBVTFTFMG 0QUJPOFSSPS&SSPS \

MFUDBVTFFSSPS&SSPS

NBUDITFMG\

'SPN6UGSFGFSSPS FSSPS

*PSFGFSSPS FSSPS

6UGSFGFSSPS FSSPS

.TH@ SFUVSO/POF

^

4PNFDBVTF

^

^

The only required method of this trait is EFTDSJQUJPO, which returns a short description of the error. Again, in the three cases, we just call the EFTDSJQUJPO method from the wrapped type itself. And, for our .TH variant, we return the wrapped message.

[ 331 ]





Implementing an Asynchronous FTP Server Chapter 9

It is possible that we don't have a string to return from this method. If it is the case, we can just return TUBUJDTUS, like this:

*P@ *0FSSPS

The DBVTF method is optional and is used to return the cause of the error. Here, we return the inner error when there's one in the variant and return /POF for our .TH variant.

The trait &SSPS requires the 4FMG type to implement both %JTQMBZ and %FCVH. We implemented %JTQMBZ earlier, but we don't implement %FCVH yet. Let's fix that by adding an attribute in front of the type declaration:

<EFSJWF%FCVH>

QVCFOVN&SSPS\

'SPN6UG'SPN6UG&SSPS

*PJP&SSPS

.TH4USJOH

6UG6UG&SSPS

^

It is good practice to provide a type alias named 3FTVMU that is specialized for our error type. Let's write one:

VTFTUESFTVMU

QVCUZQF3FTVMU5 SFTVMU3FTVMU5&SSPS

By doing so, we hide the original 3FTVMU type from the standard library. That's why we're specifying a qualified version of this type. Otherwise, the compiler will assume that it is a recursive type, which is not the case here. We'll have to be careful when we import this type in other modules, because it hides the 3FTVMU type. In case we want to use the original 3FTVMU type, we'll have to use the same trick; qualifying it.

Composing error types

The last thing we need to do in order to use all the good practices for error types in Rust is to make them easy to compose, because, for now, if we have another error type, such as JP&SSPS, we would need to use the following code every time we have another type: MFUWBM

NBUDISFTVMU\

0LWBM WBM

&SSFSSPS SFUVSO&SS&SSPS*PFSSPS

^

[ 332 ]

Implementing an Asynchronous FTP Server Chapter 9

This can quickly become cumbersome. To improve that, we'll implement the 'SPN trait for different error types:

JNQM'SPNJP&SSPS GPS&SSPS\

GOGSPNFSSPSJP&SSPS 4FMG\

*PFSSPS

^

^

JNQM B 'SPN BTUS GPS&SSPS\

GOGSPNNFTTBHF BTUS 4FMG\

.THNFTTBHFUP@TUSJOH

^

^

JNQM'SPN6UG&SSPS GPS&SSPS\

GOGSPNFSSPS6UG&SSPS 4FMG\

6UGFSSPS

^

^

JNQM'SPN'SPN6UG&SSPS GPS&SSPS\

GOGSPNFSSPS'SPN6UG&SSPS 4FMG\

'SPN6UGFSSPS

^

^

These implementations are easy to understand: if we have an JP&SSPS, we just wrap them in the corresponding variant. We also added a convenient conversion from the TUS

type.

This will allow us to use the following, which is not really better, but the good old operator will help us to reduce the boilerplate: MFUWBM

NBUDISFTVMU\

0LWBM WBM

&SSFSSPS SFUVSO&SSFSSPSJOUP

^

[ 333 ]





Implementing an Asynchronous FTP Server Chapter 9

The ? operator, revisited

This operator will not only return the error if there is one, but will also convert it to the required type. It converts it with a call to *OUPJOUP, *OUP being a trait. But why did we implement the 'SPN trait, instead of *OUP? Because there's a generic implementation of

*OUP which is based on 'SPN:

JNQM56 *OUP6 GPS5

XIFSF6'SPN5

Thanks to this implementation, we rarely need to implement the *OUP trait ourselves. We only need to implement the 'SPN trait.

This means that we can rewrite the previous code as follows: MFUWBMSFTVMU

And it will behave exactly the same as before.

Starting the Tokio event loop

In UPLJP, the object we need to use to manage an event loop is $PSF. Here's how we start an event loop using UPLJP (in the NBJO module):

VTFUPLJP@DPSFSFBDUPS$PSF

GONBJO\

MFUNVUDPSF$PSFOFXFYQFDU$BOOPUDSFBUFUPLJP$PSF

JGMFU&SSFSSPSDPSFSVOTFSWFS\

QSJOUMO&SSPSSVOOJOHUIFTFSWFS\^FSSPS

^

^

We first create a new $PSF object, and then call the SVO method to start the event loop.

The latter method will return when the provided future ends. Here, we call TFSWFS to get the future, so let's write this function:

VTFTUEJP

VTFGVUVSFTQSFMVEFBTZOD

<BTZOD>

GOTFSWFS JP3FTVMU \

0L

[ 334 ]





Implementing an Asynchronous FTP Server Chapter 9

^

As you can see, we use the <BTZOD> attribute. Since attributes are currently instable in Rust, we had to specify that we are using the QSPD@NBDSP feature. We also import the BTZOD attribute from the GVUVSFT@BXBJU crate (which was imported under the name GVUVSFT). So don't forget the <GFBUVSF> attribute and the FYUFSODSBUF statements at the top.

This attribute allows us to write a normal function, returning a 3FTVMU, and will convert this function to actually return a 'VUVSF. This function does nothing and returns 0L, so when you run the program, it will end immediately.

There's another syntax we could have used that is provided by the GVUVSFTBXBJU crate: VTFGVUVSFTQSFMVEFBTZOD@CMPDL

GONBJO\

MFUNVUDPSF$PSFOFXFYQFDU$BOOPUDSFBUFUPLJP$PSF

MFUTFSWFSBTZOD@CMPDL\

0L

^

MFUSFTVMU3FTVMU@JP&SSPS DPSFSVOTFSWFS

JGMFU&SSFSSPSSFTVMU\

QSJOUMO&SSPSSVOOJOHUIFTFSWFS\^FSSPS

^

^

We won't use this syntax in our FTP server, but it is worth knowing about. By using an BTZOD@CMPDL, we are not required to create a new function.

Starting the server

The program we just wrote does absolutely nothing, so let's update it so that it at least starts a server, using UPLJP. Let's write an actual body to our TFSWFS function: VTFTUEOFU\*Q"EES*QW"EES4PDLFU"EES^

VTFUPLJP@DPSFSFBDUPS)BOEMF

VTFUPLJP@DPSFOFU5DQ-JTUFOFS

<BTZOD>

GOTFSWFSIBOEMF)BOEMF JP3FTVMU \

MFUQPSU

MFUBEES4PDLFU"EESOFX*Q"EES7*QW"EESOFX

[ 335 ]

Implementing an Asynchronous FTP Server Chapter 9

QPSU

MFUMJTUFOFS5DQ-JTUFOFSCJOEBEESIBOEMF

QSJOUMO8BJUJOHDMJFOUTPOQPSU\^QPSU

<BTZOD>

GPSTUSFBNBEESJOMJTUFOFSJODPNJOH\

MFUBEESFTTGPSNBU<BEESFTT\^>BEES

QSJOUMO/FXDMJFOU\^BEESFTT

IBOEMFTQBXOIBOEMF@DMJFOUTUSFBN

QSJOUMO8BJUJOHBOPUIFSDMJFOU

^

0L

^

The function now takes a )BOEMF, which will be useful to specify on which event loop the server must run. We start this function by specifying on which port we want to start the server by creating a 4PDLFU"EES. Then, we create a 5DQ-JTUFOFS in a similar way to how we would create a synchronous 5DQ-JTUFOFS from the standard library. The difference here is that we also send the IBOEMF as an argument to specify on which event loop we want the server to run. After that, we use the <BTZOD> attribute again, but on a GPS loop this time.

Async GPS loops are used to iterate over a 4USFBN, returning an error if there is one. These async loops can only be used in an <BTZOD> function. In the loop, we spawn the future returned by IBOEMF@DMJFOU. Spawning a future means that it will be executed and handled by the event loop. The difference with $PSFSVO is that the future must return and the error should also be .

Now that this function takes an argument, we'll need to update the NBJO function: GONBJO\

MFUNVUDPSF$PSFOFXFYQFDU$BOOPUDSFBUFUPLJP$PSF

MFUIBOEMFDPSFIBOEMF

JGMFU&SSFSSPSDPSFSVOTFSWFSIBOEMF\

QSJOUMO&SSPSSVOOJOHUIFTFSWFS\^FSSPS

^

^

[ 336 ]





Implementing an Asynchronous FTP Server Chapter 9

Handling clients

Let's now see the IBOEMF@DMJFOU function we've just mentioned: VTFTUESFTVMU

VTFGVUVSFTQSFMVEFBXBJU

<BTZOD>

VTFUPLJP@DPSFOFU5DQ4USFBN

GOIBOEMF@DMJFOUTUSFBN5DQ4USFBN SFTVMU3FTVMU \

BXBJUDMJFOUTUSFBN

NBQ@FSS]FSSPS]QSJOUMO&SSPSIBOEMJOHDMJFOU\^

FSSPS

^

It is a simple wrapper over the DMJFOU future. Here, we used a new macro, BXBJU, which allows us to write asynchronous code in an asynchronous way. When the result of the future inside BXBJU is not ready, the event loop will execute other stuff, and when it's ready it will continue executing the code after the BXBJU. In this case, we print the error returned by the DMJFOU future. This is why we needed a wrapper.

Now, let's write this DMJFOU future:

VTFGVUVSFT\4JOL4USFBN^

VTFGVUVSFTTUSFBN4QMJU4JOL

VTFUPLJP@JP"TZOD3FBE

VTFUPLJP@JPDPEFD'SBNFE

VTFDPEFD'UQ$PEFD

VTFFSSPS3FTVMU

VTFGUQ\"OTXFS3FTVMU$PEF^

<BTZOD>

GODMJFOUTUSFBN5DQ4USFBN 3FTVMU \

MFUXSJUFSSFBEFSTUSFBNGSBNFE'UQ$PEFDTQMJU

MFUXSJUFS

BXBJUXSJUFSTFOE"OTXFSOFX3FTVMU$PEF4FSWJDF3FBEZ'PS/FX6TFS

8FMDPNFUPUIJT'51TFSWFS

MFUNVUDMJFOU$MJFOUOFXXSJUFS

<BTZOD>

GPSDNEJOSFBEFS\

DMJFOUBXBJUDMJFOUIBOEMF@DNEDNE

^

QSJOUMO$MJFOUDMPTFE

[ 337 ]





Implementing an Asynchronous FTP Server Chapter 9

0L

^

Here, we specify that the TUSFBN will be handled by a 'UQ$PEFD, which means that we'll be able to encode and decode structured data instead of dealing with bytes directly. We'll write this 'UQ$PEFD soon. Then, we split the stream between a SFBEFS and a XSJUFS. This TQMJU method is very useful in Rust, because of ownership: we cannot have two owners, one that will write to the socket and another that will read to it. To fix this issue, we split the stream and we can now have an owner for the SFBEFS and another owner for the XSJUFS.

Then, we use the XSJUFS to send a welcome message. Again, we use the BXBJU macro to specify that the code after will be executed when the message is sent (but without blocking the whole program, thanks to asynchronous I/O). Next, we create a $MJFOU which will be the object that will manage a client, by executing the appropriate actions when it receives commands and sending the right responses.

After that, we use again an <BTZOD>GPS loop to iterate over a stream; here, we iterate over the stream of the data received by this specific client. In the GPS loop, we call the IBOEMF@DNE method that we will soon write. This method, as its name indicates, will handle the command received from this FTP client, act accordingly, and send a response back. Here, we use BXBJU with a question mark at the end. The GVUVSFTBXBJU crate allows us to do so; this means that if the future returned an error, this error will propagate to the DMJFOU future, which is the same semantic for the normal operator used in a function returning a 3FTVMU. We'll see why we reassign the result to DMJFOU when we write the IBOEMF@DNE method.

Handling commands

To handle the commands received by the FTP server, we'll have a $MJFOU struct: UZQF8SJUFS4QMJU4JOL'SBNFE5DQ4USFBN'UQ$PEFD

TUSVDU$MJFOU\

XSJUFS8SJUFS

^

The client contains a 8SJUFS object that will be useful to send messages to the client. The 8SJUFS type represents a 4JOL that has been split, and uses the 'UQ$PEFD on a 5DQ4USFBN.

A 4JOL is the opposite of a 4USFBN: instead of representing a sequence of values that are received, it represents a sequence of values that are sent.

[ 338 ]





Implementing an Asynchronous FTP Server Chapter 9

We used two methods on $MJFOU, so let's write them: VTFDNE$PNNBOE

JNQM$MJFOU\

GOOFXXSJUFS8SJUFS $MJFOU\

$MJFOU\

XSJUFS

^

^

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

0LTFMG

^

^

The constructor is very simple and creates the TUSVDU with the provided argument. The IBOEMF@DNE receives the command sent to the FTP server by this specific client and will handle them; we'll write the code to handle them progressively in this chapter and the next.

For now, it only returns TFMG. Also, take note that this method receives TFMG by move, instead of by SFGFSFODF. This is due to a current limitation of the GVUVSFTBXBJU crate: for now, async functions cannot take a reference. This issue will probably be fixed later, which will make the code even better. This is why we reassigned to the DMJFOU variable in the DMJFOU function:

DMJFOUBXBJUDMJFOUIBOEMF@DNEDNE

FTP codec

The only remaining thing to code before we can try our FTP server is the DPEFD. So, let's create a new module for the DPEFD:

NPEDPEFD

In the TSDDPEFDST file, we'll create our FTP DPEFD: QVCTUSVDU'UQ$PEFD

[ 339 ]





Implementing an Asynchronous FTP Server Chapter 9

To create a DPEFD, we must implement the traits %FDPEFS and &ODPEFS. These traits come from the UPLJPJP crate:

VTFUPLJP@JPDPEFD\%FDPEFS&ODPEFS^

Decoding FTP commands

Let's first write the decoder:

VTFTUEJP

VTFCZUFT#ZUFT.VU

VTFDNE$PNNBOE

VTFFSSPS&SSPS

JNQM%FDPEFSGPS'UQ$PEFD\

UZQF*UFN$PNNBOE

UZQF&SSPSJP&SSPS

GOEFDPEFNVUTFMGCVGNVU#ZUFT.VU

JP3FTVMU0QUJPO$PNNBOE \

JGMFU4PNFJOEFYGJOE@DSMGCVG\

MFUMJOFCVGTQMJU@UPJOEFY

CVGTQMJU@UP3FNPWF=S=O

$PNNBOEOFXMJOFUP@WFD

NBQ]DPNNBOE]4PNFDPNNBOE

NBQ@FSS&SSPSUP@JP@FSSPS

^FMTF\

0L/POF

^

^

^

The %FDPEFS trait has two associated types, *UFN and &SSPS. The former is the type produced when we're able to decode a sequence of bytes. The latter is the type of the error. We first check if there the bytes $3 and -'. If we don't find them, we return 0L/POF to indicate that we need more bytes to parse the command. If we find them, we get the line of the command, excluding these bytes. Then, we skip these bytes so that the next parsing does not see them. Finally, we parse the line with $PNNBOEOFX.

[ 340 ]





Implementing an Asynchronous FTP Server Chapter 9

We used two new functions here that we must implement. The first one is the

&SSPSUP@JP@FSSPS method that we'll add to the FSSPS module: JNQM&SSPS\

QVCGOUP@JP@FSSPSTFMG JP&SSPS\

NBUDITFMG\

*PFSSPS FSSPS

'SPN6UG@].TH@]6UG@

JP&SSPS,JOE0UIFSJOUP

^

^

^

If we have an *P error, we return it. Otherwise, we return the 0UIFS kind of I/O error.

The EFDPEF methods also uses the following function: GOGJOE@DSMGCVGNVU#ZUFT.VU 0QUJPOVTJ[F \

CVGXJOEPXT

QPTJUJPO]CZUFT]CZUFTC=S=O

^

This returns the position of the byte string =S=O if it is present. Remember that this string is the delimiter in the FTP protocol.

Encoding FTP commands

We still need to write an &ODPEFS in order to have a DPEFD that can send commands to FTP

clients:

VTFGUQ"OTXFS

JNQM&ODPEFSGPS'UQ$PEFD\

UZQF*UFN"OTXFS

UZQF&SSPSJP&SSPS

GOFODPEFNVUTFMGBOTXFS"OTXFSCVGNVU#ZUFT.VU

JP3FTVMU \

MFUBOTXFS

JGBOTXFSNFTTBHFJT@FNQUZ\

GPSNBU\^=S=OBOTXFSDPEFBTV

^FMTF\

GPSNBU\^\^=S=OBOTXFSDPEFBTV

BOTXFSNFTTBHF

^

CVGFYUFOEBOTXFSBT@CZUFT

[ 341 ]





Implementing an Asynchronous FTP Server

Chapter 9

0L

^

^

Here, if we have a non-empty message, we push it to the buffer, preceded by the FTP code number. Otherwise, we only push this code number to the buffer.

We can now try the FTP server in FileZilla to see the following result:

'JHVSF

Handling commands

Our IBOEMF@DNE method does nothing, for now, so let's update it. First of all, we'll need a method to send a response to a client:

JNQM$MJFOU\

<BTZOD>

GOTFOENVUTFMGBOTXFS"OTXFS 3FTVMU4FMG \

TFMGXSJUFSBXBJUTFMGXSJUFSTFOEBOTXFS

0LTFMG

^

^

[ 342 ]

Implementing an Asynchronous FTP Server Chapter 9

This simply calls the TFOE method of the XSJUFS. Since it consumes it, we reassign the result to the attribute.

Now, we'll handle the 64&3 FTP command:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

QSJOUMO3FDFJWFEDPNNBOE\^DNE

NBUDIDNE\

$PNNBOE6TFSDPOUFOU \

JGDPOUFOUJT@FNQUZ\

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF*OWBMJE1BSBNFUFS0S"SHVNFOU

*OWBMJE

VTFSOBNF

^FMTF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF6TFS-PHHFE*O

GPSNBU8FMDPNF\^DPOUFOU

^

^

$PNNBOE6OLOPXOT

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF6OLOPXO$PNNBOE

GPSNBU=\^=/PUJNQMFNFOUFET

@ TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF$PNNBOE/PU*NQMFNFOUFE

/PUJNQMFNFOUFE

^

0LTFMG

^

Here, we pattern match to know which command was sent by the client. If it is not 6TFS, we send a response to say that the command is not implemented. If it is 6TFS, we check the content and if it is good, we send the welcome message. This is very similar to what we did in the previous chapter.

[ 343 ]





Implementing an Asynchronous FTP Server

Chapter 9

If we run the server again, we'll see the following:

!

'JHVSF

Managing the current working directory

There are still a few commands missing before we can see the files in the FTP client. Let's now add the command to print the current directory and to change it.

Printing the current directory

First of all, we'll need a new attribute for our $MJFOU structure to specify what the current directory is:

VTFTUEQBUI1BUI#VG

TUSVDU$MJFOU\

DXE1BUI#VG

XSJUFS8SJUFS

^

[ 344 ]





Implementing an Asynchronous FTP Server Chapter 9

The DXE attribute stands for current working directory. We also need to update the $MJFOU

constructor accordingly:

JNQM$MJFOU\

GOOFXXSJUFS8SJUFS $MJFOU\

$MJFOU\

DXE1BUI#VGGSPN

XSJUFS

^

^

^

Now, we can add the handler for the 18% command:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

QSJOUMO3FDFJWFEDPNNBOE\^DNE

NBUDIDNE\

$PNNBOE1XE \

MFUNTHGPSNBU\^

TFMGDXEUP@TUSVOXSBQ@PS

JGNTHJT@FNQUZ\

MFUNFTTBHFGPSNBU=\^=NTH

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF1"5)/".&$SFBUFE

NFTTBHF

^FMTF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF'JMF/PU'PVOE/P

TVDIGJMFPSEJSFDUPSZ

^

^

d

^

^

So, again, we have a code similar to the previous chapter.

Changing the current directory

Let's add another case in our NBUDI expression in the IBOEMF@DNE method:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

$PNNBOE$XEEJSFDUPSZ TFMG

[ 345 ]

Implementing an Asynchronous FTP Server Chapter 9

BXBJUTFMGDXEEJSFDUPSZ

d

^

^

It simply calls the following method:

<BTZOD>

GODXENVUTFMGEJSFDUPSZ1BUI#VG 3FTVMU4FMG \

MFUQBUITFMGDXEKPJOEJSFDUPSZ

MFUOFX@TFMGSFTTFMGDPNQMFUF@QBUIQBUI

TFMGOFX@TFMG

JGMFU0LEJSSFT\

MFUOFX@TFMGSFTTFMGTUSJQ@QSFGJYEJS

TFMGOFX@TFMG

JGMFU0LQSFGJYSFT\

TFMGDXEQSFGJYUP@QBUI@CVG

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF0L

GPSNBU%JSFDUPSZ

DIBOHFEUP=

\^=EJSFDUPSZEJTQMBZ

SFUVSO0LTFMG

^

^

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF'JMF/PU'PVOE

/PTVDIGJMFPS

EJSFDUPSZ

0LTFMG

^

This code uses the following two methods, which are similar to those in the previous chapter:

VTFTUEQBUI4USJQ1SFGJY&SSPS

GODPNQMFUF@QBUITFMGQBUI1BUI#VG 4FMG

SFTVMU3FTVMU1BUI#VGJP&SSPS \

MFUEJSFDUPSZTFMGTFSWFS@SPPUKPJOJGQBUIIBT@SPPU\

QBUIJUFSTLJQDPMMFDU

^FMTF\

QBUI

^

MFUEJSEJSFDUPSZDBOPOJDBMJ[F

JGMFU0LSFGEJSEJS\

JGEJSTUBSUT@XJUITFMGTFSWFS@SPPU\

SFUVSOTFMG

&SSJP&SSPS,JOE1FSNJTTJPO%FOJFEJOUP

^

[ 346 ]

Implementing an Asynchronous FTP Server Chapter 9

^

TFMGEJS

^

GOTUSJQ@QSFGJYTFMGEJS1BUI#VG 4FMG

SFTVMU3FTVMU1BUI#VG4USJQ1SFGJY&SSPS \

MFUSFTEJSTUSJQ@QSFGJYTFMGTFSWFS@SPPUNBQ]Q]

QUP@QBUI@CVG

TFMGSFT

^

Since it uses a new attribute, let's add it to the $MJFOU structure: TUSVDU$MJFOU\

DXE1BUI#VG

TFSWFS@SPPU1BUI#VG

XSJUFS8SJUFS

^

We also add its constructor:

JNQM$MJFOU\

GOOFXXSJUFS8SJUFSTFSWFS@SPPU1BUI#VG $MJFOU\

$MJFOU\

DXE1BUI#VGGSPN

TFSWFS@SPPU

XSJUFS

^

^

^

We also need to pass this value in a few places, first, in the DMJFOU function and its wrapper:

<BTZOD>

GODMJFOUTUSFBN5DQ4USFBNTFSWFS@SPPU1BUI#VG 3FTVMU \ d

MFUNVUDMJFOU$MJFOUOFXXSJUFSTFSWFS@SPPU

d

^

<BTZOD>

GOIBOEMF@DMJFOUTUSFBN5DQ4USFBNTFSWFS@SPPU1BUI#VG

SFTVMU3FTVMU \

BXBJUDMJFOUTUSFBNTFSWFS@SPPU

NBQ@FSS]FSSPS]QSJOUMO&SSPSIBOEMJOHDMJFOU\^

FSSPS

^

[ 347 ]





Implementing an Asynchronous FTP Server Chapter 9

Then, we need to update the TFSWFS function:

<BTZOD>

GOTFSWFSIBOEMF)BOEMFTFSWFS@SPPU1BUI#VG JP3FTVMU \

d

<BTZOD>

GPSTUSFBNBEESJOMJTUFOFSJODPNJOH\

MFUBEESFTTGPSNBU<BEESFTT\^>BEES

QSJOUMO/FXDMJFOU\^BEESFTT

IBOEMFTQBXOIBOEMF@DMJFOUTUSFBNTFSWFS@SPPUDMPOF

QSJOUMO8BJUJOHBOPUIFSDMJFOU

^

0L

^

To send the server root to the IBOEMF@DMJFOU function call.

And finally, we'll update the main function to send it to the TFSWFS function: VTFTUEFOW

GONBJO\

MFUNVUDPSF$PSFOFXFYQFDU$BOOPUDSFBUFUPLJP$PSF

MFUIBOEMFDPSFIBOEMF

NBUDIFOWDVSSFOU@EJS\

0LTFSWFS@SPPU \

JGMFU&SSFSSPSDPSFSVOTFSWFSIBOEMF

TFSWFS@SPPU\

QSJOUMO&SSPSSVOOJOHUIFTFSWFS\^FSSPS

^

^

&SSF QSJOUMO$PVMEO UTUBSUTFSWFS\^F

^

^

Here, we send the current directory as the server root.

Setting the transfer type

Let's add a new command before we test our server again: VTFDNE5SBOTGFS5ZQF

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

[ 348 ]

Implementing an Asynchronous FTP Server Chapter 9

NBUDIDNE\

d

$PNNBOE5ZQFUZQ \

TFMGUSBOTGFS@UZQFUZQ

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF0L

5SBOTGFSUZQF

DIBOHFETVDDFTTGVMMZ

^

d

^

^

This requires a new attribute for our $MJFOU structure: TUSVDU$MJFOU\

DXE1BUI#VG

TFSWFS@SPPU1BUI#VG

USBOTGFS@UZQF5SBOTGFS5ZQF

XSJUFS8SJUFS

^

And we need to update the constructor:

JNQM$MJFOU\

GOOFXXSJUFS8SJUFSTFSWFS@SPPU1BUI#VG $MJFOU\

$MJFOU\

DXE1BUI#VGGSPN

TFSWFS@SPPU

USBOTGFS@UZQF5SBOTGFS5ZQF"TDJJ

XSJUFS

^

^

^

[ 349 ]





Implementing an Asynchronous FTP Server

Chapter 9

If we run this new server and connect to it through FileZilla, we'll see the following:

'JHVSF

Entering passive mode

Let's now write the code to handle the 1"47 command. Add the following case in IBOEMF@DNE:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

d

$PNNBOE1BTW TFMGBXBJUTFMGQBTW

d

^

^

For the following, we'll need four new fields in the $MJFOU structure: VTFGVUVSFTTUSFBN4QMJU4USFBN

VTFDPEFD#ZUFT$PEFD

UZQF%BUB3FBEFS4QMJU4USFBN'SBNFE5DQ4USFBN#ZUFT$PEFD

UZQF%BUB8SJUFS4QMJU4JOL'SBNFE5DQ4USFBN#ZUFT$PEFD

[ 350 ]

Implementing an Asynchronous FTP Server Chapter 9

TUSVDU$MJFOU\

EBUB@QPSU0QUJPOV

EBUB@SFBEFS0QUJPO%BUB3FBEFS

EBUB@XSJUFS0QUJPO%BUB8SJUFS

IBOEMF)BOEMF

d

^

And all of them are initialized to /POF:

JNQM$MJFOU\

GOOFXIBOEMF)BOEMFXSJUFS8SJUFSTFSWFS@SPPU1BUI#VG

$MJFOU\

$MJFOU\

EBUB@QPSU/POF

EBUB@SFBEFS/POF

EBUB@XSJUFS/POF

IBOEMF

d

^

^

^

This requires changing a few other functions to send the )BOEMF to the $MJFOU constructor.

First, the DMJFOU function now requires a new IBOEMF parameter:

<BTZOD>

GODMJFOUTUSFBN5DQ4USFBNIBOEMF)BOEMFTFSWFS@SPPU1BUI#VG

3FTVMU \

MFUXSJUFSSFBEFSTUSFBNGSBNFE'UQ$PEFDTQMJU

MFUXSJUFS

BXBJUXSJUFSTFOE"OTXFSOFX3FTVMU$PEF4FSWJDF3FBEZ'PS/FX6TFS

8FMDPNFUPUIJT'51TFSWFS

MFUNVUDMJFOU$MJFOUOFXIBOEMFXSJUFSTFSWFS@SPPU

d

^

The IBOEMF@DMJFOU method also needs to take a new parameter:

<BTZOD>

GOIBOEMF@DMJFOUTUSFBN5DQ4USFBNIBOEMF)BOEMFTFSWFS@SPPU

1BUI#VG SFTVMU3FTVMU \

BXBJUDMJFOUTUSFBNIBOEMFTFSWFS@SPPU

NBQ@FSS]FSSPS]QSJOUMO&SSPSIBOEMJOHDMJFOU\^

FSSPS

^

[ 351 ]

Implementing an Asynchronous FTP Server Chapter 9

And in the TFSWFS function, you need to send the IBOEMFS to the IBOEMF@DMJFOU

function:

<BTZOD>

GOTFSWFSIBOEMF)BOEMFTFSWFS@SPPU1BUI#VG JP3FTVMU \

d

<BTZOD>

GPSTUSFBNBEESJOMJTUFOFSJODPNJOH\

d

IBOEMFTQBXOIBOEMF@DMJFOUTUSFBNIBOEMFDMPOF

TFSWFS@SPPUDMPOF

^

^

And here is the start of the method that does the real stuff for the 1"47 command:

<BTZOD>

GOQBTWNVUTFMG 3FTVMU4FMG \

MFUQPSU

JGMFU4PNFQPSUTFMGEBUB@QPSU\

QPSU

^FMTF\



^

JGTFMGEBUB@XSJUFSJT@TPNF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO

"MSFBEZMJTUFOJOH

SFUVSO0LTFMG

^

d

If a port was set by an earlier command, we use it, otherwise, we use zero to ask the system to choose one. As you know from the previous chapter, there are two channels in FTPbthe command channel and the data channel. So, here, we check whether the data channel is already open. If that is the case, we send the appropriate response and end the function by returning. Here's the rest of the method:

d

MFUBEES4PDLFU"EESOFX*Q"EES7*QW"EESOFX

QPSU

MFUMJTUFOFS5DQ-JTUFOFSCJOEBEESTFMGIBOEMF

MFUQPSUMJTUFOFSMPDBM@BEESQPSU

TFMG

[ 352 ]





Implementing an Asynchronous FTP Server Chapter 9

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF&OUFSJOH1BTTJWF.PEF

GPSNBU\^\^QPSU QPSU

Y''

QSJOUMO8BJUJOHDMJFOUTPOQPSU\^QPSU

<BTZOD>

GPSTUSFBN@SFTUJOMJTUFOFSJODPNJOH\

MFUXSJUFSSFBEFSTUSFBNGSBNFE#ZUFT$PEFDTQMJU

TFMGEBUB@XSJUFS4PNFXSJUFS

TFMGEBUB@SFBEFS4PNFSFBEFS

CSFBL

^

0LTFMG

^

We start by starting the listener for the data channel. See the following line: MFUQPSUMJTUFOFSMPDBM@BEESQPSU

This is used to get the port that was chosen by the system, if we specified port to let the operating system choose a port. Then, we use an BTZODGPS loop that breaks immediately after the first iteration because we only have one client that will connect to this new channel. In the loop, we're using the same split trick again; after saying that our stream uses the #ZUFT$PEFD, we split the stream between the XSJUFS and the SFBEFS. We'll describe this new DPEFD shortly. We then same both the data XSJUFS and SFBEFS.

Bytes codec

We start by creating an empty structure for the DPEFD: QVCTUSVDU#ZUFT$PEFD

Decoding data bytes

Then, we implement the %FDPEFS trait like we did for the 'UQ$PEFD: JNQM%FDPEFSGPS#ZUFT$PEFD\

UZQF*UFN7FDV

UZQF&SSPSJP&SSPS

GOEFDPEFNVUTFMGCVGNVU#ZUFT.VU

JP3FTVMU0QUJPO7FDV \

JGCVGMFO\

SFUVSO0L/POF

[ 353 ]





Implementing an Asynchronous FTP Server Chapter 9

^

MFUEBUBCVGUP@WFD

CVGDMFBS

0L4PNFEBUB

^

^

Since the data of a transmitted file can be binary, we cannot use an *UFN of type 4USJOH.

We instead use 7FDV , which we can contain every possible byte. If the buffer is empty, we return 0L/POF to indicate to UPLJP that we need more data. Otherwise, we convert it to a vector, clear the buffer and return the vector.

Encoding data bytes

Let's now see how to encode data; it's even simpler: JNQM&ODPEFSGPS#ZUFT$PEFD\

UZQF*UFN7FDV

UZQF&SSPSJP&SSPS

GOFODPEFNVUTFMGEBUB7FDV CVGNVU#ZUFT.VU

JP3FTVMU \

CVGFYUFOEEBUB

0L

^

^

We just extend the buffer with the data.

Quitting

Let's now implement the 26*5 command. As always, we need to add a case in the IBOEMF@DNE method:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

$PNNBOE2VJU TFMGBXBJUTFMGRVJU

d

^

^

[ 354 ]





Implementing an Asynchronous FTP Server Chapter 9

And here is the code of the RVJU method:

<BTZOD>

GORVJUNVUTFMG 3FTVMU4FMG \

JGTFMGEBUB@XSJUFSJT@TPNF\

VOJNQMFNFOUFE

^FMTF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF4FSWJDF$MPTJOH$POUSPM$POOF

DUJPO$MPTJOHDPOOFDUJPO

TFMGXSJUFSDMPTF

^

0LTFMG

^

So, we send a response back to the client and DMPTF the XSJUFS.

To finish this chapter, let's implement the command to create and delete directories.

Creating directories

We'll start by handling the command to create a new directory. So, we add a case in IBOEMF@DNE:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

$PNNBOE.LEQBUI TFMGBXBJUTFMGNLEQBUI

d

^

^

And the function handling this command is:

VTFTUEGTDSFBUF@EJS

<BTZOD>

GONLENVUTFMGQBUI1BUI#VG 3FTVMU4FMG \

MFUQBUITFMGDXEKPJOQBUI

MFUQBSFOUHFU@QBSFOUQBUIDMPOF

JGMFU4PNFQBSFOUQBSFOU\

MFUQBSFOUQBSFOUUP@QBUI@CVG

MFUOFX@TFMGSFTTFMGDPNQMFUF@QBUIQBSFOU

TFMGOFX@TFMG

JGMFU0LNVUEJSSFT\

[ 355 ]





Implementing an Asynchronous FTP Server Chapter 9

We first check that the QBSFOU directory is valid and under the server root: JGEJSJT@EJS\

MFUGJMFOBNFHFU@GJMFOBNFQBUI

JGMFU4PNFGJMFOBNFGJMFOBNF\

EJSQVTIGJMFOBNF

JGDSFBUF@EJSEJSJT@PL\

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF1"5)/".&$SFBUFE

'PMEFSTVDDFTTGVMMZDSFBUFE

SFUVSO0LTFMG

^

^

^

^

^

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF'JMF/PU'PVOE

$PVMEO UDSFBUFGPMEFS

0LTFMG

^

If it is, we create the directory. Otherwise, we send an error.

This requires two new functions:

VTFTUEGGJ0T4USJOH

GOHFU@QBSFOUQBUI1BUI#VG 0QUJPO1BUI#VG \

QBUIQBSFOUNBQ]Q]QUP@QBUI@CVG

^

GOHFU@GJMFOBNFQBUI1BUI#VG 0QUJPO0T4USJOH \

QBUIGJMF@OBNFNBQ]Q]QUP@PT@TUSJOH

^

These are simple wrappers over the methods from the standard library, doing type conversion.

Removing directories

Finally, let's see the code to remove directories:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

[ 356 ]





Implementing an Asynchronous FTP Server Chapter 9

$PNNBOE3NEQBUI TFMGBXBJUTFMGSNEQBUI

d

^

^

Like for the previous commands, we add a new case that calls the method that will handle it:

VTFTUEGTSFNPWF@EJS@BMM

<BTZOD>

GOSNENVUTFMGEJSFDUPSZ1BUI#VG 3FTVMU4FMG \

MFUQBUITFMGDXEKPJOEJSFDUPSZ

MFUOFX@TFMGSFTTFMGDPNQMFUF@QBUIQBUI

TFMGOFX@TFMG

JGMFU0LEJSSFT\

JGSFNPWF@EJS@BMMEJSJT@PL\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF3FRVFTUFE'JMF"DUJPO0LBZ

'PMEFS

TVDDFTTGVMMZSFNPWFE

SFUVSO0LTFMG

^

^

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF'JMF/PU'PVOE

$PVMEO USFNPWF

GPMEFS

0LTFMG

^

Here again, we check that the directory is valid and under the server root, and delete it if that is the case. Otherwise, we send an error message.

Summary

In this chapter, we implemented a lot of commands for our asynchronous FTP server and learned about using UPLJP. We also saw in more detail what asynchronous I/O is, and its advantages and disadvantages. We used the new BTZOD/BXBJU syntax to simplify the code using UPLJP. We learned what futures and streams are, and how they interact with UPLJP.

We also saw how to do proper error handling and how to do it concisely. In the next chapter, we'll complete the implementation of the FTP server and see how to test it.

[ 357 ]





10

Implementing Asynchronous

File Transfer

In the previous chapter, we started to write an asynchronous FTP server using UPLJP. Now, we'll start using the second channel used in the FTP protocol: the data channel. We'll cover the following topics:

Unit tests

Integration tests

Backtraces

Documentation

Documentation tests

Fuzzing tests

Listing files

We'll start this chapter by implementing the command to list files. This will allow us to actually see the files in an FTP client, and we'll be able to tests some commands from the previous chapter by navigating in the directories. So, let's add a case in the $MJFOUIBOEMF@DNE method:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

$PNNBOE-JTUQBUI TFMGBXBJUTFMGMJTUQBUI

d

^

^

Implementing Asynchronous File Transfer Chapter 10

This simply calls the MJTU method, which begins as follows: VTFTUEGTSFBE@EJS

<BTZOD>

GOMJTUNVUTFMGQBUI0QUJPO1BUI#VG 3FTVMU4FMG \

JGTFMGEBUB@XSJUFSJT@TPNF\

MFUQBUITFMGDXEKPJOQBUIVOXSBQ@PS@EFGBVMU

MFUEJSFDUPSZ1BUI#VGGSPNQBUI

MFUOFX@TFMGSFTTFMGDPNQMFUF@QBUIEJSFDUPSZ

TFMGOFX@TFMG

JGMFU0LQBUISFT\

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO

4UBSUJOHUPMJTU

EJSFDUPSZ

We first check that the data channel is opened and, if this is the case, we check that the provided optional path is valid. If it is, we send a response that indicates to the client that we're about to send it the data. The next part of the method is as follows: MFUNVUPVUWFD<>

JGQBUIJT@EJS\

JGMFU0LEJSSFBE@EJSQBUI\

GPSFOUSZJOEJS\

JGMFU0LFOUSZFOUSZ\

BEE@GJMF@JOGPFOUSZQBUINVUPVU

^

^

^FMTF\

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF*OWBMJE1BSBNFUFS0S"SHVNFOU

/PTVDIGJMFPS

EJSFDUPSZ

SFUVSO0LTFMG

^

^FMTF\

BEE@GJMF@JOGPQBUINVUPVU

^

[ 359 ]

Implementing Asynchronous File Transfer Chapter 10

We first create a variable, PVU, that will contain the data to send to the client. If the specified path is a directory, we use the SFBE@EJS function from the standard library. We then iterate over all files in the directory to gather the info about every file. If we were unable to open the directory, we send an error back to the client. If the path is not a directory, for example, if it is a file, we only get the info for this single file. Here's the end of the method: TFMGBXBJUTFMGTFOE@EBUBPVU

QSJOUMO BOEEPOF

^FMTF\

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF*OWBMJE1BSBNFUFS0S"SHVNFOU

/PTVDIGJMFPS

EJSFDUPSZ

^

^FMTF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF$POOFDUJPO$MPTFE/P

PQFOFE

EBUBDPOOFDUJPO

^

JGTFMGEBUB@XSJUFSJT@TPNF\

TFMGDMPTF@EBUB@DPOOFDUJPO

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF$MPTJOH%BUB$POOFDUJPO

5SBOTGFSEPOF

^

0LTFMG

^

We then send the data in the right channel using the TFOE@EBUB method that we'll see later. If there was another error, we send the appropriate response to the client. If we successfully sent the data, we close the connection and indicate this action to the client. This code used a few new methods, so let's implement them.

First, here's the method that sends data in the data channel:

<BTZOD>

GOTFOE@EBUBNVUTFMGEBUB7FDV 3FTVMU4FMG \

JGMFU4PNFXSJUFSTFMGEBUB@XSJUFS\

TFMGEBUB@XSJUFS4PNFBXBJUXSJUFSTFOEEBUB

^

0LTFMG

^

[ 360 ]

Implementing Asynchronous File Transfer Chapter 10

It is very similar to the TFOE method, but this one only sends the data if the data socket is opened. Another method that is needed is the one that closes the connection: GODMPTF@EBUB@DPOOFDUJPONVUTFMG\

TFMGEBUB@SFBEFS/POF

TFMGEBUB@XSJUFS/POF

^

We need to implement the method to gather the info about a file. Here is how it starts: DPOTU.0/5)4< TUBUJDTUS><+BO'FC.BS"QS

.BZ+VO

+VM"VH4FQ0DU

/PW%FD>

GOBEE@GJMF@JOGPQBUI1BUI#VGPVUNVU7FDV \

MFUFYUSBJGQBUIJT@EJS\^FMTF\^

MFUJT@EJSJGQBUIJT@EJS\E^FMTF\^

MFUNFUBNBUDITUEGTNFUBEBUBQBUI\

0LNFUB NFUB

@ SFUVSO

^

MFUUJNFGJMF@TJ[FHFU@GJMF@JOGPNFUB

MFUQBUINBUDIQBUIUP@TUS\

4PNFQBUI NBUDIQBUITQMJUMBTU\

4PNFQBUI QBUI

@ SFUVSO

^

@ SFUVSO

^

MFUSJHIUTJGNFUBQFSNJTTJPOTSFBEPOMZ\

SSS

^FMTF\

SXSXSX

^

The parameter PVU is a mutable reference, because we'll append the info in this variable.

Then, we gather the different required info and permissions of the file. Here's the rest of the function:

MFUGJMF@TUSGPSNBU\JT@EJS^\SJHIUT^\MJOLT^\PXOFS^

\HSPVQ^\TJ[F^\NPOUI^

\EBZ^\IPVS^\NJO^\QBUI^\FYUSB^=S=O

JT@EJSJT@EJS

SJHIUTSJHIUT

MJOLTOVNCFSPGMJOLT

[ 361 ]

Implementing Asynchronous File Transfer Chapter 10

PXOFSBOPOZNPVTPXOFSOBNF

HSPVQBOPOZNPVTHSPVQOBNF

TJ[FGJMF@TJ[F

NPOUI.0/5)4<UJNFUN@NPOBTVTJ[F>

EBZUJNFUN@NEBZ

IPVSUJNFUN@IPVS

NJOUJNFUN@NJO

QBUIQBUI

FYUSBFYUSB

PVUFYUFOEGJMF@TUSBT@CZUFT

QSJOUMO \^GJMF@TUS

^

It formats the info and appends it to the variable PVU.

This function uses another one:

FYUFSODSBUFUJNF

VTFTUEGT.FUBEBUB

<DGHXJOEPXT>

GOHFU@GJMF@JOGPNFUB.FUBEBUB UJNF5NV\

VTFTUEPTXJOEPXTQSFMVEF

UJNFBUUJNF5JNFTQFDOFXNFUBMBTU@XSJUF@UJNF

NFUBGJMF@TJ[F

^

<DGHOPUXJOEPXT>

GOHFU@GJMF@JOGPNFUB.FUBEBUB UJNF5NV\

VTFTUEPTVOJYQSFMVEF

UJNFBUUJNF5JNFTQFDOFXNFUBNUJNFNFUBTJ[F

^

Here, we have two versions of HFU@GJMF@JOGP: one for Windows and the other for all non-Windows operating systems. Since we use a new crate, we need to add this line in $BSHPUPNM:

UJNF

[ 362 ]



Implementing Asynchronous File Transfer

Chapter 10

We can now test, in the FTP client, that the files are indeed listed (on the right):

'JHVSF

[ 363 ]





Implementing Asynchronous File Transfer

Chapter 10

If we double-click on a directory, for instance, src, the FTP client will update its content:

'JHVSF

Downloading a file

A very useful feature of an FTP server is the ability to download files. So, it's time to add the command to do so.

First of all, we add the case in the IBOEMF@DNE method:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

$PNNBOE3FUSGJMF TFMGBXBJUTFMGSFUSGJMF

d

^

^

[ 364 ]

Implementing Asynchronous File Transfer Chapter 10

Here is the start of the SFUS function:

VTFTUEGT'JMF

VTFTUEJP3FBE

VTFFSSPS&SSPS

<BTZOD>

GOSFUSNVUTFMGQBUI1BUI#VG 3FTVMU4FMG \

JGTFMGEBUB@XSJUFSJT@TPNF\

MFUQBUITFMGDXEKPJOQBUI

MFUOFX@TFMGSFTTFMGDPNQMFUF@QBUIQBUIDMPOF

TFMGOFX@TFMG

JGMFU0LQBUISFT\

JGQBUIJT@GJMF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO

4UBSUJOHUPTFOEGJMF

MFUNVUGJMF'JMFPQFOQBUI

MFUNVUPVUWFD<>

GJMFSFBE@UP@FOENVUPVU

TFMGBXBJUTFMGTFOE@EBUBPVU

QSJOUMO GJMFUSBOTGFSEPOF

Again, we check that the data channel is opened and we check the path. If it is a file, we open it, read its content, and send it to the client. Otherwise, we send the appropriate error:

^FMTF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF-PDBM&SSPS*O1SPDFTTJOH

GPSNBU=\^=EPFTO UFYJTU

QBUIUP@TUSPL@PS@FMTF]]&SSPS.TH/P

QBUIUP@TUSJOH

^

^FMTF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF-PDBM&SSPS*O1SPDFTTJOH

GPSNBU=\^=EPFTO UFYJTU

QBUIUP@TUSPL@PS@FMTF]]&SSPS.TH/P

QBUIUP@TUSJOH

^

^FMTF\

TFMGBXBJU

[ 365 ]



Implementing Asynchronous File Transfer

Chapter 10

TFMGTFOE"OTXFSOFX3FTVMU$PEF$POOFDUJPO$MPTFE/PPQFOFE

EBUBDPOOFDUJPO

^

Here, we use this pattern:

PL@PS@FMTF]]&SSPS.TH/PQBUIUP@TUSJOH

This converts the 0QUJPO into a 3FTVMU, and returns the error if there is one.

And finally, we close the data socket if we successfully sent the file: JGTFMGEBUB@XSJUFSJT@TPNF\

TFMGDMPTF@EBUB@DPOOFDUJPO

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF$MPTJOH%BUB$POOFDUJPO

5SBOTGFSEPOF

^

0LTFMG

^

Let's download a file in FileZilla to check that it works:

'JHVSF

[ 366 ]





Implementing Asynchronous File Transfer Chapter 10

Uploading files

Now, let's do the opposite command: 4503 to upload a file on the server.

As always, we'll add a case in the IBOEMF@DNE method:

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

NBUDIDNE\

$PNNBOE4UPSGJMF TFMGBXBJUTFMGTUPSGJMF

d

^

^

Here is the start of the corresponding method:

VTFTUEJP8SJUF

<BTZOD>

GOTUPSNVUTFMGQBUI1BUI#VG 3FTVMU4FMG \

JGTFMGEBUB@SFBEFSJT@TPNF\

JGJOWBMJE@QBUIQBUI\

MFUFSSPSJP&SSPS

JP&SSPS,JOE1FSNJTTJPO%FOJFEJOUP

SFUVSO&SSFSSPSJOUP

^

MFUQBUITFMGDXEKPJOQBUI

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF%BUB$POOFDUJPO"MSFBEZ0QFO

4UBSUJOHUPTFOEGJMF

Once again, we check that the data channel is opened. Then, we use a new function to check that the path is valid, by which we mean it does not contain . In the other cases, we used another method, DBOPOJDBMJ[F, and checked that the path was under the server root, but we cannot do so here since there exists no file to upload yet. Here's the end of the method:

MFUEBUBOFX@TFMGBXBJUTFMGSFDFJWF@EBUB

TFMGOFX@TFMG

MFUNVUGJMF'JMFDSFBUFQBUI

GJMFXSJUF@BMMEBUB

QSJOUMO GJMFUSBOTGFSEPOF

TFMGDMPTF@EBUB@DPOOFDUJPO

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF$MPTJOH%BUB$POOFDUJPO

5SBOTGFSEPOF

[ 367 ]

Implementing Asynchronous File Transfer Chapter 10

^FMTF\

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF$POOFDUJPO$MPTFE

/PPQFOFEEBUBDPOOFDUJPO

^

0LTFMG

^

Here, we call SFDFJWF@EBUB, which is a 'VUVSF that will resolve to the data received from the client. Then, we write this content in a new file. Finally, we close the connection and send the response to indicate that the transfer is done.

Here's the method to read the data from the data socket:

<BTZOD>

GOSFDFJWF@EBUBNVUTFMG 3FTVMU7FDV 4FMG \

MFUNVUGJMF@EBUBWFD<>

JGTFMGEBUB@SFBEFSJT@OPOF\

SFUVSO0LWFD<>TFMG

^

MFUSFBEFSTFMGEBUB@SFBEFSUBLFPL@PS@FMTF]]

&SSPS.TH/PEBUB

SFBEFSUP@TUSJOH

<BTZOD>

GPSEBUBJOSFBEFS\

GJMF@EBUBFYUFOEEBUB

^

0LGJMF@EBUBTFMG

^

Here, we take the EBUB@SFBEFS attribute, which means it will be /POF after this statement.

And we iterate, using an BTZODGPS loop, over the reader stream. At every iteration, we add the data to the vector that is returned at the end.

This is the method to check if the path is valid:

VTFTUEQBUI$PNQPOFOU

GOJOWBMJE@QBUIQBUI1BUI CPPM\

GPSDPNQPOFOUJOQBUIDPNQPOFOUT\

JGMFU$PNQPOFOU1BSFOU%JSDPNQPOFOU\

SFUVSOUSVF

^

^

GBMTF

^

[ 368 ]





Implementing Asynchronous File Transfer

Chapter 10

Let's check that the upload does indeed work:

'JHVSF

Going further!

Adding a bit of configuration would be nice, don't you think? Adding user authentication would be nice as well. Let's start with the configuration!

Configuration

First, let's create a new file in TSD called DPOGJHST. To make things easier, we'll use the TOML format for our configuration file. Luckily for us, there is a crate for handling TOML

files in Rust, called UPNM. In addition to this one, we'll use TFSEF to handle serialization and deserialization (very useful!).

[ 369 ]

Implementing Asynchronous File Transfer Chapter 10

Ok, let's start by adding the dependencies into our $BSHPUPNM file: UPNM

TFSEF

TFSEF@EFSJWF

Good, now let's write our $POGJH struct:

QVCTUSVDU$POGJH\

GJFMET

^

So what should we put in there? The port and address the server should listen on to start, maybe?

QVCTUSVDU$POGJH\

QVCTFSWFS@QPSU0QUJPOV

QVCTFSWFS@BEES0QUJPO4USJOH

^

Done. We also talked about handling authentication. Why not adding it as well? We'll need a new TUSVDU for users. Let's call it 6TFS (yay for originality!): QVCTUSVDU6TFS\

QVCOBNF4USJOH

QVCQBTTXPSE4USJOH

^

Now let's add the users into the $POGJH struct:

QVCTUSVDU$POGJH\

QVCTFSWFS@QPSU0QUJPOV

QVCTFSWFS@BEES0QUJPO4USJOH

QVCVTFST7FD6TFS

QVCBENJO0QUJPO6TFS

^

To make these two TUSVDU work with TFSEF, we'll have to add the following tags:

<EFSJWF%FTFSJBMJ[F4FSJBMJ[F>

[ 370 ]

Implementing Asynchronous File Transfer Chapter 10

And because we'll need to clone $POGJH, we'll add %FCVH into the tags, which gives us:

<EFSJWF$MPOF%FTFSJBMJ[F4FSJBMJ[F>

QVCTUSVDU$POGJH\

QVCTFSWFS@QPSU0QUJPOV

QVCTFSWFS@BEES0QUJPO4USJOH

QVCBENJO0QUJPO6TFS

QVCVTFST7FD6TFS

^

<EFSJWF$MPOF%FTFSJBMJ[F4FSJBMJ[F>

QVCTUSVDU6TFS\

QVCOBNF4USJOH

QVCQBTTXPSE4USJOH

^

Ok, we're now ready to implement the reading:

VTFTUEGT'JMF

VTFTUEQBUI1BUI

VTFTUEJP\3FBE8SJUF^

VTFUPNM

GOHFU@DPOUFOU1"T3FG1BUI GJMF@QBUI1 0QUJPO4USJOH \ MFUNVUGJMF'JMFPQFOGJMF@QBUIPL

MFUNVUDPOUFOU4USJOHOFX

GJMFSFBE@UP@TUSJOHNVUDPOUFOUPL

4PNFDPOUFOU

^

JNQM$POGJH\

QVCGOOFX1"T3FG1BUI GJMF@QBUI1 0QUJPO$POGJH \ JGMFU4PNFDPOUFOUHFU@DPOUFOUGJMF@QBUI\

UPNMGSPN@TUSDPOUFOUPL

^FMTF\

QSJOUMO/PDPOGJHGJMFGPVOETPDSFBUJOHBOFXPOFJO

\^GJMF@QBUIBT@SFGEJTQMBZ

*ODBTFXFEJEO UGJOEUIFDPOGJHGJMF

XFKVTUCVJMEBOFXPOF

MFUDPOGJH$POGJH\

TFSWFS@QPSU4PNF%&'"6-5@1035

TFSWFS@BEES4PNFUP@PXOFE

BENJO/POF

VTFSTWFD<6TFS\

OBNFBOPOZNPVTUP@PXOFE

QBTTXPSEUP@PXOFE

^>

[ 371 ]

Implementing Asynchronous File Transfer Chapter 10

^

MFUDPOUFOU

UPNMUP@TUSJOHDPOGJHFYQFDUTFSJBMJ[BUJPOGBJMFE

MFUNVUGJMF

'JMFDSFBUFGJMF@QBUIBT@SFGFYQFDUDPVMEO UDSFBUF

GJMF

XSJUFMOGJMF\^DPOUFOUFYQFDUDPVMEO UGVMGJMM

DPOGJHGJMF

4PNFDPOGJH

^

^

^

Let's go through the $POGJHOFX method's code:

JGMFU4PNFDPOUFOUHFU@DPOUFOUGJMF@QBUI\

UPNMGSPN@TUSDPOUFOUPL

^

Thanks to TFSEF, we can directly load the configuration file from a TUS and it'll return our $POGJH struct fully set. Amazing, right?

For information, the HFU@DPOUFOU function is just a VUJMJUZ function that allows the return of the content of a file, if this file exists.

Also, don't forget to add the %&'"6-5@1035 constant: QVCDPOTU%&'"6-5@1035V

In case the file doesn't exist, we can create a new one with some default values: FMTF\

QSJOUMO/PDPOGJHGJMFGPVOETPDSFBUJOHBOFXPOFJO\^

GJMF@QBUIBT@SFGEJTQMBZ

*ODBTFXFEJEO UGJOEUIFDPOGJHGJMFXFKVTUCVJMEBOFX

POF

MFUDPOGJH$POGJH\

TFSWFS@QPSU4PNF%&'"6-5@1035

TFSWFS@BEES4PNFUP@PXOFE

BENJO/POF

VTFSTWFD<6TFS\

OBNFBOPOZNPVTUP@PXOFE

QBTTXPSEUP@PXOFE

^>

^

MFUDPOUFOUUPNMUP@TUSJOHDPOGJHFYQFDUTFSJBMJ[BUJPO

GBJMFE

[ 372 ]

Implementing Asynchronous File Transfer Chapter 10

MFUNVUGJMF

'JMFDSFBUFGJMF@QBUIBT@SFGFYQFDUDPVMEO UDSFBUF

GJMF

XSJUFMOGJMF\^DPOUFOUFYQFDUDPVMEO UGVMGJMMDPOGJH

GJMF

4PNFDPOGJH

^

Now you might wonder, how will we actually be able to generate TOML from our $POGJH

struct using this code? With TFSEF's magic once again!

With this, our DPOGJH file is now complete. Let get back to the NBJOST one. First, we'll need to define a new constant:

DPOTU$0/'*(@'*-& TUBUJDTUSDPOGJHUPNM

Then, we'll need to update quite a few methods/functions. Let's start with the NBJO

function. Add this line at the beginning:

MFUDPOGJH$POGJHOFX$0/'*(@'*-&FYQFDU&SSPSXIJMFMPBEJOH

DPOGJH

Now pass the DPOGJH variable to the TFSWFS function: JGMFU&SSFSSPSDPSFSVOTFSWFSIBOEMFTFSWFS@SPPUDPOGJH\ Next, let's update the TFSWFS function:

<BTZOD>

GOTFSWFSIBOEMF)BOEMFTFSWFS@SPPU1BUI#VGDPOGJH$POGJH

JP3FTVMU \

MFUQPSUDPOGJHTFSWFS@QPSUVOXSBQ@PS%&'"6-5@1035

MFUBEES

4PDLFU"EESOFX*Q"EES7DPOGJHTFSWFS@BEESBT@SFG

VOXSBQ@PSUP@PXOFE

QBSTF

FYQFDU*OWBMJE

*Q7BEESFTT

QPSU

MFUMJTUFOFS5DQ-JTUFOFSCJOEBEESIBOEMF

QSJOUMO8BJUJOHDMJFOUTPOQPSU\^QPSU

<BTZOD>

GPSTUSFBNBEESJOMJTUFOFSJODPNJOH\

MFUBEESFTTGPSNBU<BEESFTT\^>BEES

QSJOUMO/FXDMJFOU\^BEESFTT

IBOEMFTQBXOIBOEMF@DMJFOUTUSFBNIBOEMFDMPOF

[ 373 ]

Implementing Asynchronous File Transfer Chapter 10

TFSWFS@SPPUDMPOF

IBOEMFTQBXOIBOEMF@DMJFOUTUSFBNIBOEMFDMPOF

TFSWFS@SPPUDMPOF

DPOGJHDMPOF

QSJOUMO8BJUJOHBOPUIFSDMJFOU

^

0L

^

Now, the server is started with the value from the $POGJH struct. However, we still need the user list for each client in order to handle the authentication. To do so, we need to give a $POGJH instance to each $MJFOU. In here, to make things simpler, we'll just DMPOF.

Time to update the IBOEMF@DMJFOU function now:

<BTZOD>

GOIBOEMF@DMJFOUTUSFBN5DQ4USFBNIBOEMF)BOEMFTFSWFS@SPPU

1BUI#VG

DPOGJH$POGJH SFTVMU3FTVMU \

BXBJUDMJFOUTUSFBNIBOEMFTFSWFS@SPPUDPOGJH

NBQ@FSS]FSSPS]QSJOUMO&SSPSIBOEMJOHDMJFOU\^

FSSPS

^

Let's update the DMJFOU function now:

<BTZOD>

GODMJFOUTUSFBN5DQ4USFBNIBOEMF)BOEMFTFSWFS@SPPU1BUI#VG

DPOGJH$POGJH 3FTVMU \

MFUXSJUFSSFBEFSTUSFBNGSBNFE'UQ$PEFDTQMJU

MFUXSJUFS

BXBJUXSJUFSTFOE"OTXFSOFX3FTVMU$PEF4FSWJDF3FBEZ'PS/FX6TFS

8FMDPNFUPUIJT'51

TFSWFS

MFUNVUDMJFOU$MJFOUOFXIBOEMFXSJUFSTFSWFS@SPPU

DPOGJH

<BTZOD>

GPSDNEJOSFBEFS\

DMJFOUBXBJUDMJFOUIBOEMF@DNEDNE

^

QSJOUMO$MJFOUDMPTFE

0L

^

[ 374 ]

Implementing Asynchronous File Transfer Chapter 10

The final step is updating the $MJFOU struct:

TUSVDU$MJFOU\

DXE1BUI#VG

EBUB@QPSU0QUJPOV

EBUB@SFBEFS0QUJPO%BUB3FBEFS

EBUB@XSJUFS0QUJPO%BUB8SJUFS

IBOEMF)BOEMF

OBNF0QUJPO4USJOH

TFSWFS@SPPU1BUI#VG

USBOTGFS@UZQF5SBOTGFS5ZQF

XSJUFS8SJUFS

JT@BENJOCPPM

DPOGJH$POGJH

XBJUJOH@QBTTXPSECPPM

^

The brand new DPOGJH field seems logical, however what about JT@BENJO and XBJUJOH@QBTTXPSE? The first one will be used to be able to list/download/overwrite the DPOGJHUPNM file, whereas the second one will be used when the 64&3 command has been used and the server is now expecting the user's password.

Let's add another method to our $MJFOU struct:

GOJT@MPHHFETFMG CPPM\

TFMGOBNFJT@TPNFTFMGXBJUJOH@QBTTXPSE

^

Don't forget to update the $POGJHOFX method:

GOOFXIBOEMF)BOEMFXSJUFS8SJUFSTFSWFS@SPPU1BUI#VG

DPOGJH$POGJH $MJFOU\

$MJFOU\

DXE1BUI#VGGSPN

EBUB@QPSU/POF

EBUB@SFBEFS/POF

EBUB@XSJUFS/POF

IBOEMF

OBNF/POF

TFSWFS@SPPU

USBOTGFS@UZQF5SBOTGFS5ZQF"TDJJ

XSJUFS

JT@BENJOGBMTF

DPOGJH

XBJUJOH@QBTTXPSEGBMTF

^

^

[ 375 ]

Implementing Asynchronous File Transfer Chapter 10

Ok, now here comes the huge update! But first, don't forget to add the 1BTT command: QVCFOVN$PNNBOE\

WBSJBOUT

1BTT4USJOH

WBSJBOUT

^

Now the $PNNBOEOFX match:

C1"44 $PNNBOE1BTTEBUBBOE@UIFO]CZUFT]

4USJOHGSPN@VUGCZUFTUP@WFDNBQ@FSS*OUPJOUP

Don't forget to also update the "T3FG implementation!

Good, we're ready for the last (and very big) step. Let's head to the $MJFOUIBOEMF@DNE

method:

VTFDPOGJH\%&'"6-5@1035$POGJH^

VTFTUEQBUI1BUI

GOQSFGJY@TMBTIQBUINVU1BUI#VG\

JGQBUIJT@BCTPMVUF\

QBUI1BUIOFXKPJOQBUI

^

^

<BTZOD>

GOIBOEMF@DNENVUTFMGDNE$PNNBOE 3FTVMU4FMG \

QSJOUMO3FDFJWFEDPNNBOE\^DNE

JGTFMGJT@MPHHFE\

NBUDIDNE\

$PNNBOE$XEEJSFDUPSZ SFUVSO

0LBXBJUTFMGDXEEJSFDUPSZ

$PNNBOE-JTUQBUI SFUVSO

0LBXBJUTFMGMJTUQBUI

$PNNBOE1BTW SFUVSO0LBXBJUTFMGQBTW

$PNNBOE1PSUQPSU \

TFMGEBUB@QPSU4PNFQPSU

SFUVSO

0LBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF0L

GPSNBU%BUBQPSUJTOPX\^

QPSU

^

$PNNBOE1XE \

MFUNTHGPSNBU\^

TFMGDXEUP@TUSVOXSBQ@PSTNBMM

[ 376 ]

Implementing Asynchronous File Transfer Chapter 10

USJDL

JGNTHJT@FNQUZ\

MFUNFTTBHFGPSNBU=\^=NTH

SFUVSO0LBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF1"5)/".&$SFBUFE

NFTTBHF

^FMTF\

SFUVSO

0LBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF'JMF/PU'PVOE

/PTVDIGJMFPSEJSFDUPSZ

^

^

$PNNBOE3FUSGJMF SFUVSO

0LBXBJUTFMGSFUSGJMF

$PNNBOE4UPSGJMF SFUVSO

0LBXBJUTFMGTUPSGJMF

$PNNBOE$E6Q \

JGMFU4PNFQBUI

TFMGDXEQBSFOUNBQ1BUIUP@QBUI@CVG\

TFMGDXEQBUI

QSFGJY@TMBTINVUTFMGDXE

^

SFUVSO

0LBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF0L%POF

^

$PNNBOE.LEQBUI SFUVSO

0LBXBJUTFMGNLEQBUI

$PNNBOE3NEQBUI SFUVSO

0LBXBJUTFMGSNEQBUI

@

^

^FMTFJGTFMGOBNFJT@TPNFTFMGXBJUJOH@QBTTXPSE\

JGMFU$PNNBOE1BTTDPOUFOUDNE\

MFUNVUPLGBMTF

JGTFMGJT@BENJO\

PLDPOUFOU

TFMGDPOGJHBENJOBT@SFGVOXSBQQBTTXPSE

^FMTF\

GPSVTFSJOTFMGDPOGJHVTFST\

JG4PNFVTFSOBNFTFMGOBNFBT@SFG\

JGVTFSQBTTXPSEDPOUFOU\

PLUSVF

CSFBL

^

^

^

^

[ 377 ]

Implementing Asynchronous File Transfer Chapter 10

JGPL\

TFMGXBJUJOH@QBTTXPSEGBMTF

MFUOBNF

TFMGOBNFDMPOFVOXSBQ@PS4USJOHOFX

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF6TFS-PHHFE*O

GPSNBU8FMDPNF\^

OBNF

^FMTF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF/PU-PHHFE*O

*OWBMJEQBTTXPSE

^

SFUVSO0LTFMG

^

^

NBUDIDNE\

$PNNBOE"VUI

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF$PNNBOE/PU*NQMFNFOUFE

/PUJNQMFNFOUFE

$PNNBOE2VJU TFMGBXBJUTFMGRVJU

$PNNBOE4ZTU \

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF0L*

XPO UUFMM

^

$PNNBOE5ZQFUZQ \

TFMGUSBOTGFS@UZQFUZQ

TFMGBXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF0L

5SBOTGFSUZQFDIBOHFE

TVDDFTTGVMMZ

^

$PNNBOE6TFSDPOUFOU \

JGDPOUFOUJT@FNQUZ\

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF*OWBMJE1BSBNFUFS0S"SHVNFOU

*OWBMJEVTFSOBNF

^FMTF\

MFUNVUOBNF/POF

MFUNVUQBTT@SFRVJSFEUSVF

TFMGJT@BENJOGBMTF

JGMFU4PNFSFGBENJOTFMGDPOGJHBENJO\

JGBENJOOBNFDPOUFOU\

OBNF4PNFDPOUFOUDMPOF

QBTT@SFRVJSFEBENJOQBTTXPSEJT@FNQUZ

GBMTF

TFMGJT@BENJOUSVF

[ 378 ]

Implementing Asynchronous File Transfer Chapter 10

^

^

*ODBTFUIFVTFSJTO UUIFBENJO

JGOBNFJT@OPOF\

GPSVTFSJOTFMGDPOGJHVTFST\

JGVTFSOBNFDPOUFOU\

OBNF4PNFDPOUFOUDMPOF

QBTT@SFRVJSFE

VTFSQBTTXPSEJT@FNQUZGBMTF

CSFBL

^

^

^

*ODBTFUIJTJTBOVOLOPXOVTFS

JGOBNFJT@OPOF\

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF/PU-PHHFE*O

6OLOPXOVTFS

^FMTF\

TFMGOBNFOBNFDMPOF

JGQBTT@SFRVJSFE\

TFMGXBJUJOH@QBTTXPSEUSVF

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF6TFS/BNF0LBZ/FFE1BTTXPSE

GPSNBU-PHJO0,QBTTXPSE

OFFEFEGPS\^

OBNFVOXSBQ

^FMTF\

TFMGXBJUJOH@QBTTXPSEGBMTF

TFMGBXBJU

TFMGTFOE"OTXFSOFX3FTVMU$PEF6TFS-PHHFE*O

GPSNBU8FMDPNF\^DPOUFOU

^

^

^

^

$PNNBOE/P0Q TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF0L

%PJOH

OPUIJOH

$PNNBOE6OLOPXOT

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF6OLOPXO$PNNBOE

GPSNBU=\^=/PUJNQMFNFOUFE

T

@ \

*UNFBOTUIBUUIFVTFSUSJFEUPTFOEBDPNNBOEXIJMF

UIFZXFSFO U

[ 379 ]

Implementing Asynchronous File Transfer Chapter 10

MPHHFEZFU

TFMG

BXBJUTFMGTFOE"OTXFSOFX3FTVMU$PEF/PU-PHHFE*O

1MFBTFMPHGJSTU

^

^

0LTFMG

^

I told you it was huge! The main points in here are just the flow rework. The following commands only work when you're logged in:

$XE

-JTU

1BTW

1PSU

1XE

3FUS

4UPS

$E6Q

.LE

3NE

This command only works when you're not yet logged in and the server is waiting for the password:

1BTT

The rest of the commands work in any case. We're almost done in here. Remember when I talked about the security? You wouldn't want anyone to have access to the configuration file with the list of all users, I suppose.

[ 380 ]





Implementing Asynchronous File Transfer Chapter 10

Securing the config.toml access

This time, not much to do! We just need to add a check when a user wants to list, download, or overwrite the file. Which means that the three following commands have to be updated:

-JTU

3FUS

4UPS

Let's start with -JTU. Before the first BEE@GJMF@JOGP function call, just wrap the BEE@GJMF@JOGP function call around this block:

JGTFMGJT@BENJO]]FOUSZQBUI

TFMGTFSWFS@SPPUKPJO$0/'*(@'*-&\

Before the second one, add the following:

JGTFMGJT@BENJO]]QBUITFMGTFSWFS@SPPUKPJO$0/'*(@'*-& Now let's update the SFUS function. Take the following condition: JGQBUIJT@GJMF\

Replace it with this:

JGQBUIJT@GJMFTFMGJT@BENJO]]QBUI

TFMGTFSWFS@SPPUKPJO$0/'*(@'*-&\

Finally, let's update the TUPS function. Take the following condition: JGJOWBMJE@QBUIQBUI\

Replace it with this:

JGJOWBMJE@QBUIQBUI]]TFMGJT@BENJOQBUI

TFMGTFSWFS@SPPUKPJO$0/'*(@'*-&\

And we're done! You now have a configurable server that you can easily extend, following your needs.

[ 381 ]





Implementing Asynchronous File Transfer Chapter 10

Unit tests

A good software needs tests to ensure that it works in most cases. So, we will add tests to our FTP server by starting to write unit tests for the FTP DPEFD.

Unit tests verify only a unit of the program, which may be a function. They are different from the integration tests, which we will see later, that test the software as a whole.

Let's go in the DPEFD module and add a new inner module to it:

<DGHUFTU>

NPEUFTUT\

^

We are again using the <DGH> attribute; this time, it only compiles the following module when running the tests. This is to avoid adding useless code in the final binary.

In this new module, we will add a few import statements that we will need later when writing the tests:

<DGHUFTU>

NPEUFTUT\

VTFTUEQBUI1BUI#VG

VTFGUQ3FTVMU$PEF

VTFTVQFS\"OTXFS#ZUFT.VU$PNNBOE%FDPEFS&ODPEFS

'UQ$PEFD^

^

As you can see, we use TVQFS to access some types from the parent module (DPEFD): this is very frequent for unit tests because we usually test the code from the same file.

Let's now add a UFTU function:

<DGHUFTU>

NPEUFTUT\

d

<UFTU>

GOUFTU@FODPEFS\

^

^

In the UFTU@FODPEFS function, we will write the code that will test that the

'UQ$PEFD, &ODPEFS implementation works as intended.

[ 382 ]

Implementing Asynchronous File Transfer Chapter 10

We will first check that an "OTXFS with a message produces the right output:

<DGHUFTU>

NPEUFTUT\

d

<UFTU>

GOUFTU@FODPEFS\

MFUNVUDPEFD'UQ$PEFD

MFUNFTTBHFCBETFRVFODFPGDPNNBOET

MFUBOTXFS"OTXFSOFX3FTVMU$PEF#BE4FRVFODF0G$PNNBOET

NFTTBHF

MFUNVUCVG#ZUFT.VUOFX

MFUSFTVMUDPEFDFODPEFBOTXFSNVUCVG

BTTFSUSFTVMUJT@PL

BTTFSU@FRCVGGPSNBU\^=S=ONFTTBHF

^

^

Here, we start by creating the objects needed to call &ODPEFFODPEF, for example, a DPEFD and a buffer. Then, we call DPEFDFODPEF, since it is the method we actually want to test. After that, we check if the result is 0L and we check that the buffer was filled accordingly. To do so, we use some macros:

BTTFSU: This checks if the value is USVF. If it is GBMTF, it will panic and make the test fail.

BTTFSU@FR: This checks that both values are equal.

This a quite simple and effective test, but it does not test every path of the function. So, let's add more lines in this function to test the other possible path:

<DGHUFTU>

NPEUFTUT\

d

<UFTU>

GOUFTU@FODPEFS\

d

MFUBOTXFS

"OTXFSOFX3FTVMU$PEF$BOU0QFO%BUB$POOFDUJPO

MFUNVUCVG#ZUFT.VUOFX

MFUSFTVMUDPEFDFODPEFBOTXFSNVUCVG

BTTFSUSFTVMUJT@PL3FTVMUJTPL

BTTFSU@FRCVGGPSNBU=S=O#VGGFSDPOUBJOT

^

^

[ 383 ]

Implementing Asynchronous File Transfer Chapter 10

Here, we test with an empty message. The rest is basically the same: we create the necessary objects and use the assert macros. But this time, we added a new parameter to the assert macros; this is an optional message to show when the test fails.

If we run the test with DBSHPUFTU, we get the following result: Compiling ftp-server v0.0.1 (file:///path/to/FTP-server-rs) Finished dev [unoptimized + debuginfo] target(s) in 1.29 secs Running target/debug/deps/ftp_server-452667ddc2d724e8

running 1 test

test codec::tests::test_encoder ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out This shows the test that was run and that it passed.

Let's write a UFTU function that fails:

<UFTU>

GOUFTU@EVNNZ\

BTTFSUGBMTF"MXBZTGBJM

^

When we run DBSHPUFTU, we see the following:

Finished dev [unoptimized + debuginfo] target(s) in 1.30 secs Running target/debug/deps/ftp_server-452667ddc2d724e8

running 2 tests

test codec::tests::test_encoder ... ok

test codec::tests::test_dummy ... FAILED

failures:

---- codec::tests::test_dummy stdout ----

thread 'codec::tests::test_dummy' panicked at 'Always fail', src/codec.rs:102:8

note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:

codec::tests::test_dummy

[ 384 ]





Implementing Asynchronous File Transfer Chapter 10

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--bin ftp-server'

We can see that the message we specified ("MXBZTGBJM) is shown. We also see that test failed.

Backtraces

As mentioned in the output, we can set the environment variable 3645@#"$,53"$& to in order to get more information about where the test failed. Let's do so: FYQPSU3645@#"$,53"$&

Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running target/debug/deps/ftp_server-452667ddc2d724e8

running 2 tests

test codec::tests::test_encoder ... ok

test codec::tests::test_dummy ... FAILED

failures:

---- codec::tests::test_dummy stdout ----

thread 'codec::tests::test_dummy' panicked at 'Always fail', src/codec.rs:102:8

note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.

stack backtrace:

0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49

1: std::sys_common::backtrace::_print

at /checkout/src/libstd/sys_common/backtrace.rs:68

2: std::panicking::default_hook::{{closure}}

at /checkout/src/libstd/sys_common/backtrace.rs:57

at /checkout/src/libstd/panicking.rs:381

3: std::panicking::default_hook

at /checkout/src/libstd/panicking.rs:391

4: std::panicking::rust_panic_with_hook

at /checkout/src/libstd/panicking.rs:577

5: std::panicking::begin_panic

at /checkout/src/libstd/panicking.rs:538

6: ftp_server::codec::tests::test_dummy

at src/codec.rs:102

7: <F as test::FnBox<T>>::call_box

[ 385 ]





Implementing Asynchronous File Transfer Chapter 10

at /checkout/src/libtest/lib.rs:1491

at /checkout/src/libcore/ops/function.rs:223

at /checkout/src/libtest/lib.rs:142

8: __rust_maybe_catch_panic

at /checkout/src/libpanic_unwind/lib.rs:99

failures:

codec::tests::test_dummy

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--bin ftp-server'

The important part here is the following:

6: ftp_server::codec::tests::test_dummy

at src/codec.rs:102

This shows the file, function, and line where the code panicked.

This variable is useful even outside of testing code: when debugging a problem with a code that panics, we can use this variable as well.

Testing failures

Sometimes, we want to test that a function will panic. To do so, we can simply add the

<TIPVME@QBOJD> attribute at the top of the UFTU function:

<TIPVME@QBOJD>

<UFTU>

GOUFTU@EVNNZ\

BTTFSUGBMTF"MXBZTGBJM

^

When doing so, the UFTU now passes:

Finished dev [unoptimized + debuginfo] target(s) in 1.30 secs Running target/debug/deps/ftp_server-452667ddc2d724e8

running 2 tests

test codec::tests::test_dummy ... ok

test codec::tests::test_encoder ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

[ 386 ]





Implementing Asynchronous File Transfer

Chapter 10

Ignoring tests

Sometimes, we have tests that take a lot of time, or we want to avoid running a specific test all the time. To avoid running a test by default, we can add the <JHOPSF> attribute above the function:

<JHOPSF>

<UFTU>

GOUFTU@EVNNZ\

BTTFSUGBMTF"MXBZTGBJM

^

When we run the UFTU, we'll see that the UFTU function was not running: Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running target/debug/deps/ftp_server-452667ddc2d724e8

running 2 tests

test codec::tests::test_dummy ... ignored

test codec::tests::test_encoder ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out As you can see, the UFTU@EVNNZ test function was ignored. To run it, we need to specify a command-line argument to the program running the tests (not to DBSHP itself): cargo test -- --ignored

Note: We specified before JHOPSFE to send the latter to the program running the tests (which is not DBSHP).

With that argument, we see that the test indeed runs: Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running target/debug/deps/ftp_server-452667ddc2d724e8

running 1 test

test codec::tests::test_dummy ... FAILED

failures:

---- codec::tests::test_dummy stdout ----

thread 'codec::tests::test_dummy' panicked at 'Always fail', src/codec.rs:102:8

note: Run with `RUST_BACKTRACE=1` for a backtrace.

[ 387 ]

Implementing Asynchronous File Transfer Chapter 10

failures:

codec::tests::test_dummy

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 1 filtered out

error: test failed, to rerun pass '--bin ftp-server'

To end this section, let's write a unit test for the decoder:

<DGHUFTU>

NPEUFTUT\

d

<UFTU>

GOUFTU@EFDPEFS\

MFUNVUDPEFD'UQ$PEFD

MFUNVUCVG#ZUFT.VUOFX

CVGFYUFOEC18%

MFUSFTVMUDPEFDEFDPEFNVUCVG

BTTFSUSFTVMUJT@PL

MFUDPNNBOESFTVMUVOXSBQ

BTTFSUDPNNBOEJT@OPOF

Here, we test that /POF is returned in the case when more input is needed: CVGFYUFOEC=S=O

MFUSFTVMUDPEFDEFDPEFNVUCVG

BTTFSUSFTVMUJT@PL

MFUDPNNBOESFTVMUVOXSBQ

BTTFSU@FRDPNNBOE4PNF$PNNBOE1XE

And here, we add the missing output to check that the command was parsed correctly: MFUNVUCVG#ZUFT.VUOFX

CVGFYUFOEC-*45UNQ=S=O

MFUSFTVMUDPEFDEFDPEFNVUCVG

BTTFSUSFTVMUJT@PL

MFUDPNNBOESFTVMUVOXSBQ

BTTFSU@FRDPNNBOE

4PNF$PNNBOE-JTU4PNF1BUI#VGGSPNUNQ

^

^

[ 388 ]





Implementing Asynchronous File Transfer Chapter 10

Finally, we test that parsing a command with an argument works. If we run DBSHPUFTU

again, we get the following output:

Finished dev [unoptimized + debuginfo] target(s) in 1.70 secs Running target/debug/deps/ftp_server-452667ddc2d724e8

running 2 tests

test codec::tests::test_encoder ... ok

test codec::tests::test_decoder ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Integration tests

In the previous section, we checked that a part of our code works: now, we will check that the program as a whole works, by writing integration tests. These tests reside in the UFTUT

directory, so we start by creating it:

mkdir tests

In this directory, we can create a new file, UFTUTTFSWFSST, in which we'll put the following content:

FYUFSODSBUFGUQ

VTFTUEQSPDFTT$PNNBOE

VTFTUEUISFBE

VTFTUEUJNF%VSBUJPO

VTFGUQ'UQ4USFBN

We import the GUQ crate which is an FTP client; it will be useful to test our FTP server. We need to add it in $BSHPUPNM as well:

<EFWEFQFOEFODJFT>

GUQ?

Here we see a new section, EFWEFQFOEFODJFT: it contains the dependencies that are needed outside the main crate itself, like in the integration tests. By putting the dependency here and not in <EFQFOEFODJFT>, it won't be available in the main crate, which is what we want.

[ 389 ]





Implementing Asynchronous File Transfer

Chapter 10

Let's go back to the file UFTUTTFSWFSST and add a UFTU function:

<UFTU>

GOUFTU@QXE\

MFUDIJME

$PNNBOEOFXUBSHFUEFCVHGUQTFSWFS

TQBXOVOXSBQ

MFUNVUDPOUSPMMFS1SPDFTT$POUSPMMFSOFXDIJME

UISFBETMFFQ%VSBUJPOGSPN@NJMMJT

BTTFSUDPOUSPMMFSJT@SVOOJOH4FSWFSXBTBCPSUFE

MFUNVUGUQ'UQ4USFBNDPOOFDUVOXSBQ

GUQRVJUVOXSBQ

^

Here, we don't need to put the code in an inner UFTUT module because the integration tests are compiled separately. Since our crate is a binary, we need to run it with the $PNNBOE

object. We give the child process to a 1SPDFTT$POUSPMMFS that we will create later.

Note: If our crate was a library, we would add an FYUFSODSBUF for it, and we would be able to call functions from it directly.

We then call UISFBETMFFQ to give some time for our server to start. After that, we use the GUQ crate to connect to our server, and then we quit.

Teardown

In the Rust test framework, there's no TFUVQ and UFBSEPXO functions like there are in the test frameworks of many other languages. And here, we need to run some code when the test is done: we need to kill our FTP server. So, we need some kind of UFBSEPXO

function. We cannot simply say DIJMELJMM at the end of the function because, if the test panics before that, the FTP server will continue running after the test ends. To make sure the cleanup code is always called, no matter how the function ended, we'll have to use the 3"** pattern that we discovered in $IBQUFS , Implementing the Engine of the Music Player.

[ 390 ]

Implementing Asynchronous File Transfer Chapter 10

Let's write a simple UFBSEPXO structure:

TUSVDU1SPDFTT$POUSPMMFS\

DIJME$IJME

^

The structure contains the child process that will be killed in the destructor. So, if the test panics, this destructor will be called. It will also be called if the function ends normally.

We'll also create a constructor and the VUJMJUZ method that we used in the UFTU function: JNQM1SPDFTT$POUSPMMFS\

GOOFXDIJME$IJME 4FMG\

1SPDFTT$POUSPMMFS\

DIJME

^

^

GOJT@SVOOJOHNVUTFMG CPPM\

MFUTUBUVTTFMGDIJMEUSZ@XBJUVOXSBQ

TUBUVTJT@OPOF

^

^

The function JT@SVOOJOH is used to ensure that the FTP server we launched is actually running; if another instance of the application is already running, our instance will not run.

That's why we used an assert in the test function.

Finally, we need to create a destructor:

JNQM%SPQGPS1SPDFTT$POUSPMMFS\

GOESPQNVUTFMG\

MFU@TFMGDIJMELJMM

^

^

We're now ready to write the UFTU function:

<UFTU>

GOUFTU@QXE\

d

MFUNVUGUQ'UQ4USFBNDPOOFDUVOXSBQ

MFUQXEGUQQXEVOXSBQ

BTTFSU@FRQXE

[ 391 ]

Implementing Asynchronous File Transfer Chapter 10

GUQMPHJOGFSSJTVOXSBQ

GUQDXETSDVOXSBQ

MFUQXEGUQQXEVOXSBQ

BTTFSU@FRTSDQXE

MFU@GUQDEVQ

MFUQXEGUQQXEVOXSBQ

BTTFSU@FRQXE

GUQRVJUVOXSBQ

^

In this function, we issue some FTP commands and make sure the server state is correct by calling the BTTFSU@FR macro. When we run DBSHPUFTU, we see the following output: Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running target/debug/deps/ftp_server-47386d9089111729

running 2 tests

test codec::tests::test_decoder ... ok

test codec::tests::test_encoder ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Running target/debug/deps/server-1b5cda64792f5f82

running 1 test

Waiting clients on port 1234...

New client: [address : 127.0.0.1:43280]

Waiting another client...

Received command: Pwd

Received command: User("ferris")

Received command: Cwd("src")

Received command: Pwd

Received command: CdUp

Received command: Pwd

Received command: Quit

test test_pwd ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out A new section is added for our integration test.

[ 392 ]





Implementing Asynchronous File Transfer Chapter 10

Print output to stdout

Let's see what happens when we add a call to QSJOUMO in our test (for debug purposes, for instance):

<UFTU>

GOUFTU@QXE\

QSJOUMO3VOOJOH'51TFSWFS

d

^

It will not be printed to the terminal. In order to see it, we need to pass another parameter to the test runner. Let's run DBSHPUFTU this way to see the output to TUEPVU: cargo run -- --nocapture

This time, we see the following output:

e

Running target/debug/deps/server-1b5cda64792f5f82

running 1 test

Running FTP server

Waiting clients on port 1234...

New client: [address : 127.0.0.1:43304]

Waiting another client...

Received command: Pwd

Received command: User("ferris")

Received command: Cwd("src")

Received command: Pwd

Received command: CdUp

Received command: Pwd

Received command: Quit

test test_pwd ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Documentation

Another very important aspect of a software is documentation. It is useful to describe how to use a project, giving some examples and detailing the complete public API: let's see how we can document a crate in Rust.

[ 393 ]





Implementing Asynchronous File Transfer Chapter 10

Documenting a crate

Documentation is written in comments, but these doc-comments start with a special symbol. We use the token to document the item following the comment, and to document the item from within this item. Let's start by seeing an example of the latter.

At the top of our crate's root (specifically, in the file NBJOST), we'll add the following comment:

"O'51TFSWFSXSJUUFOVTJOHUPLJPBOEGVUVSFTBXBJU

Here, we use the form because we cannot write a comment before a crate; we can only write a comment from within the crate.

Documenting a module

Documenting a module is very similar: we add a comment of the form at the top of a module's file. Let's add the following doc-comment in DPEFDST:

'51DPEFDTUPFODPEFBOEEFDPEF'51DPNNBOETBOESBXCZUFT

Headers

The doc-comments are written in Markdown, so let's look at some Markdown formatting syntax. We can write headers by starting a line with a . The more 's, the smaller the title.

For example:

4PNFJOUSPEVDUJPOUFYU



#JH5JUMF



-FTTCJHUJUMF



&WFOMFTTCJHUJUMF



4NBMMUJUMF





I think you get it at this point!

[ 394 ]





Implementing Asynchronous File Transfer Chapter 10

Here is a list of common headers:

Examples

Panics

Failure

Code blocks

The code we write in doc-comments must be inserted between two pairs of AAA. Usually, the code blocks are written under an &YBNQMFT header. Let's see an example using all of these syntactic elements for a function that convert bytes to uppercase: $POWFSUBTFRVFODFPGCZUFTUPVQQFSDBTF



&YBNQMFT



AAA

MFUNVUEBUBCUFTU

UP@VQQFSDBTFNVUEBUB

AAA

GOUP@VQQFSDBTFEBUBNVU<V>\

GPSCZUFJOEBUB\

JGCZUF B BTVCZUF [ BTV\

CZUF

^

^

^

Here, we start with a short description of the function. Then, we show a code example.

It's recommended to add comments in the code if needed, to help users understand it more easily, so don't hesitate to add some!

Documenting an enumeration (or any type with

public fields)

When we want to document an enumeration, we want not only to document the type, but also each variant. To do so, we can simply add a doc-comment before each variant. The same applies for a structure, for its fields.

[ 395 ]





Implementing Asynchronous File Transfer Chapter 10

Let's see an example for the $PNNBOE type:

"O'51DPNNBOEQBSTFECZUIFQBSTFS

<EFSJWF$MPOF%FCVH1BSUJBM&R>

QVCFOVN$PNNBOE\

"VUI

$IBOHFUIFXPSLJOHEJSFDUPSZUPUIFPOFTQFDJGJFEBTBO

BSHVNFOU

$XE1BUI#VG

(FUBMJTUPGGJMFT

-JTU0QUJPO1BUI#VG

$SFBUFBOFXEJSFDUPSZ

.LE1BUI#VG

/PPQFSBUJPO

/P0Q

4QFDJGZUIFQPSUUPVTFGPSUIFEBUBDIBOOFM

1PSUV

&OUFSQBTTJWFNPEF

1BTW

1SJOUDVSSFOUEJSFDUPSZ

1XE

5FSNJOBUFUIFDPOOFDUJPO

2VJU

3FUSJFWFBGJMF

3FUS1BUI#VG

3FNPWFBEJSFDUPSZ

3NE1BUI#VG

4UPSFBGJMFPOUIFTFSWFS

4UPS1BUI#VG

4ZTU

4QFDJGZUIFUSBOTGFSUUZQF

5ZQF5SBOTGFS5ZQF

(PUPUIFQBSFOUEJSFDUPSZ

$E6Q

6OLOPXO4USJOH

6TFS4USJOH

^

We see that the FOVN itself has a doc-comment and most of the variants also have documentation.

Generating the documentation

We can easily generate the documentation by running the following command: cargo doc

[ 396 ]





Implementing Asynchronous File Transfer

Chapter 10

This will generate the documentation in the directory UBSHFUEPDGUQ@TFSWFS. Here is how it looks:

'JHVSF

Warning about public items without

documentation

When writing a library, it is very easy to forget to write the documentation about every item. But, we can use the help of the tools at our disposal. By adding the

<XBSONJTTJOH@EPDT> attribute in our crate's root, the compiler will warn us when public items do not have a doc-comment. In such a case, it will print something like this: warning: missing documentation for crate

--> src/main.rs:9:1

|

9 | / #![feature(proc_macro, conservative_impl_trait, generators)]

10 | | #![warn(missing_docs)]

11 | |

12 | | extern crate bytes;

... |

528 | | }

529 | | }

| |_^

|

note: lint level defined here

--> src/main.rs:10:9

|

10 | #![warn(missing_docs)]

| ^^^^^^^^^^^^

[ 397 ]





Implementing Asynchronous File Transfer Chapter 10

Hiding items from the documentation

Sometimes, we intentionally do not want to have a public item show up in the documentation. In this case, we can use the <EPDIJEEFO> attribute:

<EPDIJEEFO>

<EFSJWF$MPOF$PQZ%FCVH1BSUJBM&R>

QVCFOVN5SBOTGFS5ZQF\

"TDJJ

*NBHF

6OLOPXO

^

For instance, this can be useful for something that is used by a macro of the crate but is not intended to be used directly by the user.

Documentation tests

Writing documentation is a great thing. Showing code in your documentation is even better. However, how can you be sure that the code you're showing is still up to date? That it won't break when users copy/paste it to test it out? Here comes another wonderful feature from Rust: EPDUFTUT.

Tags

First, any code blocks in documentation comments will be tested by default if they don't have JHOPSF or any non-recognized tag. So, for example: AAAJHOPSF

MFUY

Y

AAA

[ 398 ]





Implementing Asynchronous File Transfer Chapter 10

This block code won't be tested (luckily, because it wouldn't compile!). A few other examples:

4PNFUFYU



AAAUFYU

UIJTJTKVTUTPNFUFYU

CVUJU TSFOEFSFEJOTJEFBDPEFCMPDL

OJDFSJHIU

AAA



8IZOPU$



AAADMBOHVBHF

JOUTUSMFODPOTUDIBST\

DIBSDT



GPSDD

SFUVSODT

^

AAA



0SBOVOLOPXOMBOHVBHF



AAAXIBUFWFS



AAA

A few other instructions might come in handy for you. Let's start with JHOPSF!

ignore

Just like this flag name states, JHOPSF makes the block code ignored. As simple as that. It'll still get the Rust syntax color once rendered in the documentation. For example: AAAJHOPSF

MFUY

AAA

[ 399 ]





Implementing Asynchronous File Transfer

Chapter 10

However, once rendered, it'll have a graphical notification about the fact that this block code isn't tested:

'JHVSF

And when you hover over the

sign:

'JHVSF

Now let's continue with DPNQJMF@GBJM!

compile_fail

The DPNQJMF@GBJM flag ensures that the given code blocks don't compile. As simple as that.

It's mostly used when you're showing bad code and demonstrating why it is bad. For example:

AAADPNQJMF@GBJM

MFUY

Y%BNOAYAJTO UNVUBCMFTPZPVDBOOPUVQEBUFJU

AAA

Then you just write a small explanation about what went wrong and show a working example. It's very common in tutorials, to help users understand why it's wrong and how to fix it.

[ 400 ]





Implementing Asynchronous File Transfer

Chapter 10

In addition to this, please note that there will be a graphical indication that this block is supposed to fail at compilation:

'JHVSF

And when you hover over the

sign:

'JHVSF

Let's continue with OP@SVO!

no_run

The OP@SVO flag tells SVTUEPD to only check if the code block compiles (and therefore, not to run it). It's mostly used in cases involving external resources (such as files). For example: AAAOP@SVO

VTFTUEGT'JMF



MFUNVUG'JMFPQFOTPNFGJMFUYUFYQFDUGJMFOPU

GPVOE

AAA

If you run this test, it's very likely (but not certain, since there is a possibility that some funny user decided to suddenly add a TPNFGJMFUYU file) to fail at execution. However, the code is perfectly fine so it'd be a shame to just JHOPSF it, right?

[ 401 ]





Implementing Asynchronous File Transfer Chapter 10

Now, let's see what to do if you want the test to fail: should_panic

The TIPVME@QBOJD flag ensures that your block code panics at execution. If it doesn't, then the test fails. Let's take the previous code block: AAATIPVME@QBOJD

VTFTUEGT'JMF



MFUNVUG'JMFPQFOTPNFGJMFUYUFYQFDUGJMFOPU

GPVOE

AAA

Once again, the test should succeed (unless, again, you have a funny user who added the file). Quite useful if you want to show some bad behavior.

Combining flags?

It's actually possible to combine flags, although it's not really useful. For example: AAASVTUJHOPSF

MFUY

AAA

You could just have written this as follows:

AAAJHOPSF

MFUY

AAA

For now, it's not really useful, but who knows what will happen in the future? At least now you know!

[ 402 ]





Implementing Asynchronous File Transfer Chapter 10

About the doc blocks themselves

I suppose you noticed that we never added a function or anything. So how does it actually work?

Well first, it checks if the NBJO function is defined. If not, it'll wrap the code into one.

Observe the following code:

AAA

MFUY

AAA

When you write the preceding code, it gets transformed into this: AAA

GONBJO\

MFUY

^

AAA

Also, you can use all the public items defined in your crate in your code blocks. No need to import the crate with an FYUFSODSBUF (however, you still have to import the item!).

One last (very) important point remains to be talked about: hiding code blocks lines.

Hiding code blocks lines

If you want to use , you'll have to do it inside a function returning an 0QUJPO or a 3FTVMU.

But still, inside a function. However, you don't necessarily want to show those lines to the user in order to focus on what you're trying to explain.

To put it simply, you just need to add a at the beginning of the line. As simple as that. As always, let's show it with a small example:

AAA

GOGPP TUEJP3FTVMU \

MFUNVUGJMF'JMFPQFOTPNFGJMFUYU

XSJUFGJMF)FMMPXPSME

0L

^

AAA

[ 403 ]





Implementing Asynchronous File Transfer Chapter 10

The user will only see the following:

MFUNVUGJMF'JMFPQFOTPNFGJMFUYU

XSJUFGJMF)FMMPXPSME

However, if they click on the Run button, they'll see the following: GONBJO\

VTFTUEGT'JMF

VTFTUEJPQSFMVEF

GOGPP TUEJP3FTVMU \

MFUNVUGJMF'JMFPQFOTPNFGJMFUYU

XSJUFGJMF)FMMPXPSME

0L

^

^

(Don't forget that the NBJO function is added as well!).

That's it for the doc tests. With all this knowledge, you should be able to write a nice API documentation which will always be up to date and tested (hopefully)!

Fuzzing tests

There is another type of test that is very useful but is not integrated into the Rust standard library: fuzzing tests.

A fuzzing test will test a function's automatically generated input with the sole purpose of crashing this function or making it behave incorrectly. Fuzzing tests can be used to complement tests that are written manually because they can generate way more input than we can possibly write by hand. We will use DBSHPGV[[ to test our command parser.

First, we need to install it:

cargo install cargo-fuzz

Next, we will use the new DBSHPGV[[ command to create a new fuzz test crate in our FTP

server crate:

cargo fuzz init

[ 404 ]

Implementing Asynchronous File Transfer Chapter 10

This generated a few files. The most important of them and the one we will modify, is GV[[GV[[@UBSHFUTGV[[@UBSHFU@ST. Let's replace its content with the following:

<OP@NBJO>

<NBDSP@VTF>FYUFSODSBUFMJCGV[[FS@TZT

NPEFSSPS\

JODMVEFTSDFSSPSST

^

JODMVEFTSDDNEST

GV[[@UBSHFU]EBUB<V>]\

MFU@$PNNBOEOFXEBUBUP@WFD

^

Since our crate is a binary instead of a library, we cannot directly import functions from it.

So, we use this little trick to get access to the functions we want: NPEFSSPS\

JODMVEFTSDFSSPSST

^

JODMVEFTSDDNEST

The NPEFSSPS is needed because our DNE module depends on it. With that sorted, we include the DNE module with a macro. This macro will expand to the content of the file, similarly to the JODMVEF preprocessor directive in $. Finally, we have our UFTU function: GV[[@UBSHFU]EBUB<V>]\

MFU@$PNNBOEOFXEBUBUP@WFD

^

Here, we just create a new command from the random input we receive. We ignore the result since there's no way we can possibly check if it is right, except by listing all possibilities (which would make a great unit test). So, if there's a bug in our command parser that causes a panic, the fuzzer could find it.

To run the fuzzer, issue the following command:

cargo fuzz run fuzz_target_1

[ 405 ]

Implementing Asynchronous File Transfer Chapter 10

Here's the output:

Fresh arbitrary v0.1.0

Fresh cc v1.0.3

Fresh libfuzzer-sys v0.1.0

(https://github.com/rust-fuzz/libfuzzer-sys.git#737524f7) Compiling ftp-server-fuzz v0.0.1 (file:///path/to/FTP-server-rs/fuzz) Running `rustc --crate-name fuzz_target_1

fuzz/fuzz_targets/fuzz_target_1.rs --crate-type bin --emit=dep-info,link -C

debuginfo=2 -C metadata=7eb012a2948092cc -C extra-filename=-7eb012a2948092cc --out-dir /path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/deps --target x86_64-unknown-linux-gnu -L dependency=/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/deps -L dependency=/path/to/FTP-server-rs/fuzz/target/debug/deps --extern libfuzzer_sys=/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-

gnu/debug/deps/liblibfuzzer_sys-44f07aaa9fd00b00.rlib --cfg fuzzing -

Cpasses=sancov -Cllvm-args=-sanitizer-coverage-level=3 -Zsanitizer=address

-Cpanic=abort -L native=/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/build/libfuzzer-sys-b260d147c5e0139d/out`

Finished dev [unoptimized + debuginfo] target(s) in 1.57 secs Fresh arbitrary v0.1.0

Fresh cc v1.0.3

Fresh libfuzzer-sys v0.1.0

(https://github.com/rust-fuzz/libfuzzer-sys.git#737524f7) Fresh ftp-server-fuzz v0.0.1 (file:///path/to/FTP-server-rs/fuzz) Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running `fuzz/target/x86_64-unknown-linux-gnu/debug/fuzz_target_1 -

artifact_prefix=/path/to/FTP-server-rs/fuzz/artifacts/fuzz_target_1/

/path/to/FTP-server-rs/fuzz/corpus/fuzz_target_1`

INFO: Seed: 1369551667

INFO: Loaded 0 modules (0 guards):

Loading corpus dir: /path/to/FTP-server-rs/fuzz/corpus/fuzz_target_1

INFO: -max_len is not provided, using 64

INFO: A corpus is not provided, starting from an empty corpus

#0 READ units: 1

#1 INITED cov: 389 corp: 1/1b exec/s: 0 rss: 23Mb

#4 NEW cov: 393 corp: 2/4b exec/s: 0 rss: 23Mb L: 3 MS: 3 ShuffleBytes-InsertByte-InsertByte-

#5 NEW cov: 412 corp: 3/62b exec/s: 0 rss: 23Mb L: 58 MS: 4

ShuffleBytes-InsertByte-InsertByte-InsertRepeatedBytes-

#7 NEW cov: 415 corp: 4/121b exec/s: 0 rss: 23Mb L: 59 MS: 1

InsertByte-

#21 NEW cov: 416 corp: 5/181b exec/s: 0 rss: 23Mb L: 60 MS: 5 ChangeBit-InsertByte-ChangeBinInt-ChangeByte-InsertByte-

#707 NEW cov: 446 corp: 6/241b exec/s: 0 rss: 23Mb L: 60 MS: 1

ChangeBit-

#710 NEW cov: 447 corp: 7/295b exec/s: 0 rss: 23Mb L: 54 MS: 4

[ 406 ]

Implementing Asynchronous File Transfer Chapter 10

ChangeBit-InsertByte-EraseBytes-InsertByte-

#767 NEW cov: 448 corp: 8/357b exec/s: 0 rss: 23Mb L: 62 MS: 1 CMP-DE: "\x01\x00"-

#780 NEW cov: 449 corp: 9/421b exec/s: 0 rss: 23Mb L: 64 MS: 4

CopyPart-InsertByte-ChangeByte-CrossOver-

#852 NEW cov: 450 corp: 10/439b exec/s: 0 rss: 23Mb L: 18 MS: 1

CrossOver-

#1072 NEW cov: 452 corp: 11/483b exec/s: 0 rss: 23Mb L: 44 MS: 1

InsertRepeatedBytes-

#85826 NEW cov: 454 corp: 12/487b exec/s: 85826 rss: 41Mb L: 4 MS: 5

ChangeBit-InsertByte-InsertByte-EraseBytes-CMP- DE: "NOOP"-

#92732 NEW cov: 456 corp: 13/491b exec/s: 92732 rss: 43Mb L: 4 MS: 1

CMP- DE: "PASV"-

#101858 NEW cov: 477 corp: 14/495b exec/s: 50929 rss: 46Mb L: 4 MS: 2

ChangeByte-CMP- DE: "STOR"-

#105338 NEW cov: 497 corp: 15/499b exec/s: 52669 rss: 47Mb L: 4 MS: 2

ShuffleBytes-CMP- DE: "LIST"-

#108617 NEW cov: 499 corp: 16/503b exec/s: 54308 rss: 48Mb L: 4 MS: 1

CMP- DE: "AUTH"-

#108867 NEW cov: 501 corp: 17/507b exec/s: 54433 rss: 48Mb L: 4 MS: 1

CMP- DE: "QUIT"-

#115442 NEW cov: 503 corp: 18/511b exec/s: 57721 rss: 50Mb L: 4 MS: 1

CMP- DE: "SYST"-

#115533 NEW cov: 505 corp: 19/515b exec/s: 57766 rss: 50Mb L: 4 MS: 2

ChangeBinInt-CMP- DE: "CDUP"-

#123001 NEW cov: 513 corp: 20/518b exec/s: 61500 rss: 52Mb L: 3 MS: 5

PersAutoDict-EraseBytes-ChangeByte-ChangeBinInt-CMP- DE: "\x01\x00"-"RMD"-

#127270 NEW cov: 515 corp: 21/521b exec/s: 63635 rss: 54Mb L: 3 MS: 4

EraseBytes-ChangeByte-InsertByte-CMP- DE: "PWD"-

#131072 pulse cov: 515 corp: 21/521b exec/s: 65536 rss: 55Mb

#148469 NEW cov: 527 corp: 22/525b exec/s: 49489 rss: 59Mb L: 4 MS: 3

ChangeBit-ChangeBit-CMP- DE: "USER"-

#151237 NEW cov: 528 corp: 23/529b exec/s: 50412 rss: 60Mb L: 4 MS: 1

CMP- DE: "TYPE"-

#169842 NEW cov: 536 corp: 24/532b exec/s: 56614 rss: 65Mb L: 3 MS: 1

ChangeByte-

#262144 pulse cov: 536 corp: 24/532b exec/s: 52428 rss: 90Mb

#274258 NEW cov: 544 corp: 25/535b exec/s: 54851 rss: 94Mb L: 3 MS: 2

ChangeBit-CMP- DE: "MKD"-

#355992 NEW cov: 566 corp: 26/539b exec/s: 50856 rss: 116Mb L: 4 MS: 1

InsertByte-

#356837 NEW cov: 575 corp: 27/558b exec/s: 50976 rss: 116Mb L: 19 MS: 1

InsertRepeatedBytes-

#361667 NEW cov: 586 corp: 28/562b exec/s: 51666 rss: 117Mb L: 4 MS: 1

PersAutoDict- DE: "MKD"-

thread '<unnamed>' panicked at 'index out of bounds: the len is 0 but the index is 0', fuzz/fuzz_targets/../../src/cmd.rs:85:46

note: Run with `RUST_BACKTRACE=1` for a backtrace.

[ 407 ]

Implementing Asynchronous File Transfer Chapter 10

==10969== ERROR: libFuzzer: deadly signal

#0 0x55e90764cf73 (/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/fuzz_target_1+0x110f73)

#1 0x55e9076aa701 (/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/fuzz_target_1+0x16e701)

#2 0x55e9076aa64b (/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/fuzz_target_1+0x16e64b)

#3 0x55e907683059 (/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/fuzz_target_1+0x147059)

#4 0x7f4bda433d9f (/usr/lib/libpthread.so.0+0x11d9f)

#5 0x7f4bd9e8789f (/usr/lib/libc.so.6+0x3489f)

#6 0x7f4bd9e88f08 (/usr/lib/libc.so.6+0x35f08)

#7 0x55e9076c2b18 (/path/to/FTP-server-rs/fuzz/target/x86_64-unknown-linux-gnu/debug/fuzz_target_1+0x186b18)

NOTE: libFuzzer has rudimentary signal handlers.

Combine libFuzzer with AddressSanitizer or similar for better crash reports.

SUMMARY: libFuzzer: deadly signal

MS: 2 CopyPart-InsertByte-; base unit:

6e9816a8e9d0388eecdb52866188c04e75e4b1b3

0x54,0x59,0x50,0x45,0x20,

TYPE

artifact_prefix='/path/to/FTP-server-rs/fuzz/artifacts/fuzz_target_1/'; Test unit written to /path/to/FTP-server-rs/fuzz/artifacts/fuzz_target_1/crash-601e8dbb61bd6c7d63cff0bd3f749f7cb5392

2bc

Base64: VFlQRSA=

==10969==LeakSanitizer has encountered a fatal error.

==10969==HINT: For debugging, try setting environment variable LSAN_OPTIONS=verbosity=1:log_threads=1

==10969==HINT: LeakSanitizer does not work under ptrace (strace, gdb, etc) MS: 2 CopyPart-InsertByte-; base unit:

6e9816a8e9d0388eecdb52866188c04e75e4b1b3

0x54,0x59,0x50,0x45,0x20,

TYPE

artifact_prefix='/path/to/FTP-server-rs/fuzz/artifacts/fuzz_target_1/'; Test unit written to /path/to/FTP-server-rs/fuzz/artifacts/fuzz_target_1/crash-601e8dbb61bd6c7d63cff0bd3f749f7cb5392

2bc

Base64: VFlQRSA=

There's actually a bug in our parser! We can see where, thanks to this line: thread '<unnamed>' panicked at 'index out of bounds: the len is 0 but the index is 0', fuzz/fuzz_targets/../../src/cmd.rs:85:46

[ 408 ]

Implementing Asynchronous File Transfer Chapter 10

The corresponding line in the source code is:

NBUDI5SBOTGFS5ZQFGSPNEBUB<>\

And indeed, if the data is empty, this will panic. Let's fix that: JNQM$PNNBOE\

QVCGOOFXJOQVU7FDV 3FTVMU4FMG \

d

MFUDPNNBOE

NBUDIDPNNBOEBT@TMJDF\

d

C5:1& \

MFUFSSPS&SSDPNNBOEOPUJNQMFNFOUFEGPS

UIBU

QBSBNFUFSJOUP

MFUEBUBEBUB

JGEBUBJT@FNQUZ\

SFUVSOFSSPS

^

NBUDI5SBOTGFS5ZQFGSPNEBUB<>\

5SBOTGFS5ZQF6OLOPXO SFUVSOFSSPS

UZQ \

$PNNBOE5ZQFUZQ

^

^

^

d

^

0LDPNNBOE

^

^

The fix is simple: we check if the data is empty, in which case we return an error.

Let's try the fuzzer to see if it can find another bug. Here's the output: INFO: Seed: 81554194

INFO: Loaded 0 modules (0 guards):

Loading corpus dir:

/home/bouanto/Ordinateur/Programmation/Rust/Projets/FTP-server-rs/fuzz/corpus/fuzz_target_1

INFO: -max_len is not provided, using 64

#0 READ units: 27

#27 INITED cov: 595 corp: 23/330b exec/s: 0 rss: 28Mb

#21494 NEW cov: 602 corp: 24/349b exec/s: 0 rss: 28Mb L: 19 MS: 2

ShuffleBytes-CMP- DE: "STOR"-

#21504 NEW cov: 606 corp: 25/354b exec/s: 0 rss: 28Mb L: 5 MS: 2

[ 409 ]

Implementing Asynchronous File Transfer Chapter 10

InsertByte-PersAutoDict- DE: "STOR"-

#24893 NEW cov: 616 corp: 26/359b exec/s: 0 rss: 29Mb L: 5 MS: 1 CMP-DE: "TYPE"-

#25619 NEW cov: 620 corp: 27/365b exec/s: 0 rss: 29Mb L: 6 MS: 2

PersAutoDict-InsertByte- DE: "TYPE"-

#25620 NEW cov: 621 corp: 28/379b exec/s: 0 rss: 29Mb L: 14 MS: 3

PersAutoDict-InsertByte-CMP- DE: "TYPE"-"\x00\x00\x00\x00\x00\x00\x00\x00"-

#32193 NEW cov: 628 corp: 29/398b exec/s: 0 rss: 31Mb L: 19 MS: 1 CMP-DE: "CWD"-

#34108 NEW cov: 662 corp: 30/417b exec/s: 0 rss: 31Mb L: 19 MS: 1 CMP-DE: "USER"-

#35745 NEW cov: 666 corp: 31/421b exec/s: 0 rss: 31Mb L: 4 MS: 3

ShuffleBytes-EraseBytes-PersAutoDict- DE: "CWD"-

#36518 NEW cov: 673 corp: 32/426b exec/s: 0 rss: 32Mb L: 5 MS: 1

PersAutoDict- DE: "USER"-

#36634 NEW cov: 685 corp: 33/433b exec/s: 0 rss: 32Mb L: 7 MS: 2 CMP-CMP- DE: "\xff\xff"-"RETR"-

#37172 NEW cov: 688 corp: 34/437b exec/s: 0 rss: 32Mb L: 4 MS: 5

EraseBytes-ChangeBinInt-InsertByte-ChangeBit-CMP- DE: "RETR"-

#39248 NEW cov: 692 corp: 35/442b exec/s: 0 rss: 32Mb L: 5 MS: 1

PersAutoDict- DE: "RETR"-

#65735 NEW cov: 699 corp: 36/492b exec/s: 65735 rss: 39Mb L: 50 MS: 3

InsertRepeatedBytes-ChangeBit-CMP- DE: "LIST"-

#69797 NEW cov: 703 corp: 37/497b exec/s: 69797 rss: 40Mb L: 5 MS: 5

ChangeByte-CopyPart-CopyPart-EraseBytes-PersAutoDict- DE: "LIST"-

#131072 pulse cov: 703 corp: 37/497b exec/s: 65536 rss: 55Mb

#217284 NEW cov: 707 corp: 38/511b exec/s: 54321 rss: 75Mb L: 14 MS: 2

CMP-ShuffleBytes- DE: "LIST"-

#219879 NEW cov: 708 corp: 39/525b exec/s: 54969 rss: 76Mb L: 14 MS: 2

ChangeByte-ChangeBit-

#262144 pulse cov: 708 corp: 39/525b exec/s: 52428 rss: 86Mb

#524288 pulse cov: 708 corp: 39/525b exec/s: 52428 rss: 148Mb

#1048576 pulse cov: 708 corp: 39/525b exec/s: 52428 rss: 273Mb

#2097152 pulse cov: 708 corp: 39/525b exec/s: 51150 rss: 522Mb

#4194304 pulse cov: 708 corp: 39/525b exec/s: 50533 rss: 569Mb

#8388608 pulse cov: 708 corp: 39/525b exec/s: 50533 rss: 569Mb

#12628080 NEW cov: 835 corp: 40/530b exec/s: 50311 rss: 570Mb L: 5 MS: 3 ChangeBit-ChangeBinInt-ShuffleBytes-

#12628883 NEW cov: 859 corp: 41/540b exec/s: 50314 rss: 570Mb L: 10

MS: 1 CopyPart-

#12628893 NEW cov: 867 corp: 42/604b exec/s: 50314 rss: 570Mb L: 64

MS: 1 CrossOver-

#12643279 NEW cov: 868 corp: 43/608b exec/s: 50371 rss: 570Mb L: 4 MS: 2 EraseBytes-EraseBytes-

#12670956 NEW cov: 871 corp: 44/652b exec/s: 50281 rss: 570Mb L: 44

MS: 4 EraseBytes-InsertByte-ChangeBinInt-ChangeBinInt-

#12671130 NEW cov: 872 corp: 45/697b exec/s: 50282 rss: 570Mb L: 45

MS: 3 ChangeBit-CMP-InsertByte- DE: "\xff\xff\xff\xff"-

[ 410 ]





Implementing Asynchronous File Transfer Chapter 10

#12671140 NEW cov: 873 corp: 46/750b exec/s: 50282 rss: 570Mb L: 53

MS: 3 ChangeBinInt-CMP-CopyPart- DE: "\x00\x00\x00\x00\x00\x00\x00\x00"-

#12671906 NEW cov: 874 corp: 47/803b exec/s: 50285 rss: 570Mb L: 53

MS: 4 ChangeBit-ChangeByte-PersAutoDict-ShuffleBytes- DE: "CWD"-

#12687428 NEW cov: 875 corp: 48/856b exec/s: 50346 rss: 574Mb L: 53

MS: 1 ShuffleBytes-

#12699014 NEW cov: 945 corp: 49/862b exec/s: 50392 rss: 574Mb L: 6 MS: 2 InsertByte-ChangeBit-

#13319888 NEW cov: 946 corp: 50/869b exec/s: 50074 rss: 579Mb L: 7 MS: 1 InsertByte-

#13424473 NEW cov: 1015 corp: 51/878b exec/s: 50091 rss: 580Mb L: 9

MS: 1 CopyPart-

#13432333 NEW cov: 1018 corp: 52/888b exec/s: 50120 rss: 580Mb L: 10

MS: 1 CopyPart-

#13651748 NEW cov: 1019 corp: 53/901b exec/s: 50006 rss: 582Mb L: 13

MS: 1 CopyPart-

#13652268 NEW cov: 1020 corp: 54/920b exec/s: 50008 rss: 582Mb L: 19

MS: 1 CopyPart-

#13652535 NEW cov: 1025 corp: 55/978b exec/s: 50009 rss: 582Mb L: 58

MS: 3 InsertRepeatedBytes-ChangeBit-InsertByte-

#13662779 NEW cov: 1028 corp: 56/997b exec/s: 50046 rss: 582Mb L: 19

MS: 2 ChangeBit-ShuffleBytes-

#16777216 pulse cov: 1028 corp: 56/997b exec/s: 48913 rss: 589Mb

#33554432 pulse cov: 1028 corp: 56/997b exec/s: 46154 rss: 589Mb

#67108864 pulse cov: 1028 corp: 56/997b exec/s: 45343 rss: 589Mb

#134217728 pulse cov: 1028 corp: 56/997b exec/s: 44325 rss: 589Mb

#268435456 pulse cov: 1028 corp: 56/997b exec/s: 43819 rss: 589Mb

^C==16792== libFuzzer: run interrupted; exiting So, we ran the fuzzer for a very long time and it didn't find a panic, so we ended it with Ctrl + C. We cannot be certain that there's no bug left, but we are more confident thanks to all these tests.

Summary

In this chapter, we finalized our FTP server. Then, we learned how to do different types of tests. We saw how we can test a single function or type by writing unit tests. We learned how to test a program as a whole by writing integration tests. We also learned about documentation and fuzzing tests to make sure our examples are up to date and to find even more bugs in our application.

In the next and ultimate chapter, we will learn about Rust's good practice and common idioms.

[ 411 ]





11

Rust Best Practices

Rust is a powerful language, but a few things easily avoidable with practice can make your life really hard when starting. This chapter aims to show you some good practices and tips.

We will cover the following topics in this chapter: Best practices

API tips and improvements

Usage tips

Code readability

Now let's go!

Rust best practices

Let's start with some basics (and maybe obvious) things.

Slices

First, a little recap; a slice is a constant view over an array, and <5> is the constant view of a 7FD5 , whereas TUS is the constant view of a 4USJOH (just like 1BUI is the constant view of a 1BUI#VG and 0T4US is the constant view of an 0T4USJOH). Now that you have this in mind, let's continue!

Rust Best Practices

Chapter 11

When a function expects a constant argument of type 7FD or 4USJOH, then always write them as follows:

GOTPNF@GVODW<V>\

TPNFDPEF

^

Instead of:

GOTPNF@DPEFW7FDV \

TPNFDPEF

^

And:

GOTPNF@GVODTTUS\

TPNFDPEF

^

Instead of:

GOTPNF@GVODT4USJOH\

TPNFDPEF

^

You might be wondering why this is the case. So, let's imagine your function displays your 7FD as ASCII characters:

GOQSJOU@BT@BTDJJW<V>\

GPSDJOW\

QSJOU\^DBTDIBS

^

QSJOUMO

^

And now you just want to print a part of your 7FD: MFUWCTBMVU

QSJOU@BT@BTDJJW<>

Now, if the QSJOU@BT@BTDJJ only accepted references on 7FD, you'd have to make a (useless) allocation, as follows:

MFUWCTBMVU

QSJOU@BT@BTDJJW<>UP@WFD

[ 413 ]





Rust Best Practices

Chapter 11

API tips and improvements

When writing a public API (either for you or other users), a few tips can really make everyone's life easier. This is where generics kick in. Let's start with 0QUJPO arguments: Explaining the Some function

Generally, when a function expects an 0QUJPO argument, it looks like this: GOTPNF@GVODBSH0QUJPOTUS \

TPNFDPEF

^

And you call it as follows:

TPNF@GVOD4PNFSBUBUPVJMMF

TPNF@GVOD/POF

Now, what if I told you that you could get rid of the 4PNF? Nice, right? Well, this is actually pretty easy:

GOTPNF@GVOD B5*OUP0QUJPO BTUS BSH5\

TPNFDPEF

^

And you can now call it as follows:

TPNF@GVOD4PNFSBUBUPVJMMF*GZPVSFBMMZMJLFUPXSJUF

4PNF

TPNF@GVODSBUBUPVJMMF

TPNF@GVOD/POF

Better! However, to make users' lives easier, it'll require a bit more code for whoever's writing the function. You can't use BSH as it is; you need to add an extra step. Before, you'd just do this:

GOTPNF@GVODBSH0QUJPOTUS \

JGMFU4PNFBBSH\

QSJOUMO\^B

^FMTF\

QSJOUMOOPUIJOH

^

^

[ 414 ]





Rust Best Practices

Chapter 11

Now, you'll need to add an JOUP call before being able to use BSH: GOTPNF@GVOD B5*OUP0QUJPO BTUS BSH5\

MFUBSHBSHJOUP

JGMFU4PNFBBSH\

QSJOUMO\^B

^FMTF\

QSJOUMOOPUIJOH

^

^

And that's it. As we said before, it doesn't require much and makes users' lives easier, so why not do it?

Using the Path function

Just like the previous section, this will show you some tips to make your API more comfortable to use by auto-converting it into a 1BUI.

So, let's take an example with a function receiving a 1BUI as an argument: VTFTUEQBUI1BUI

GOTPNF@GVODQ1BUI\

TPNFDPEF

^

There's nothing new in here. You can call this function just like this: TPNF@GVOD1BUIOFXUPSUVHBUYU

The annoying thing, here, is that you have to build the 1BUI yourself before sending it to the function. This is way too annoying, but we can do better!

GOTPNF@GVOD1"T3FG1BUI Q1\

TPNFDPEF

^

And that's it... You can now call the function as follows: TPNF@GVOD1BUIOFXUPSUVHBUYU*GZPVSFBMMZMJLFUP

CVJMEUIF1BUICZZPVSTFMG

TPNF@GVODUPSUVHBUYU

[ 415 ]





Rust Best Practices

Chapter 11

And just like for the *OUP trait, you need to add one line of code in order to make it work: GOTPNF@GVOD1"T3FG1BUI Q1\

MFUQ1BUIQBT@SFG

TPNFDPEF

^

And that's it! Now, as long as the given type implements "T3FG1BUI , you can just send it like that. For information, here's a (non-exhaustive) list of types implementing this trait: 0T4US / 0T4USJOH

TUS / 4USJOH

1BUI (yes, 1BUI implements "T3FG1BUI as well!) / 1BUI#VG

*UFS

This is already quite a lot, so you should be able to do it pretty easily!

Usage tips

Now that you've seen few examples about how some small tips can make users' code more beautiful, how about we see some others things that might make your code better?

Builder pattern

A builder pattern is meant to be able to build a final object through multiple calls that can be chained. An excellent example is the 0QFO0QUJPOT type in the Rust standard library.

It's strongly recommended you use 0QFO0QUJPOT when you need to play with 'JMF!

VTFTUEGT0QFO0QUJPOT

MFUGJMF0QFO0QUJPOTOFX

SFBEUSVF

XSJUFUSVF

DSFBUFUSVF

PQFOGPPUYU

[ 416 ]





Rust Best Practices

Chapter 11

To make such APIs, you have two ways:

Playing with mutable borrows

Playing with moves

Let's start with the mutable borrows!

1MBZJOHXJUINVUBCMFCPSSPXT

The first one works just like 0QFO0QUJPOT:

TUSVDU/VNCFSV

JNQM/VNCFS\

GOOFXOCV /VNCFS\

/VNCFSOC

^

GOBEENVUTFMGPUIFSV NVU/VNCFS\

TFMGPUIFS

TFMG

^

GOTVCNVUTFMGPUIFSV NVU/VNCFS\

TFMGPUIFS

TFMG

^

GODPNQVUFTFMG V\

TFMG

^

^

If you wonder about TFMG, just remember that it's how you access a tuple field.

And then you can call it as follow:

MFUOC/VNCFSOFXBEETVCBEEDPNQVUF

BTTFSU@FROC

This is the first way to do it.

You'll note that you need to add an ending method so that you can transform your mutable borrow into an object (otherwise, you'll have a borrow issue).

[ 417 ]





Rust Best Practices

Chapter 11

Let's now take a look at the second way to do it!

1MBZJOHXJUINPWFT

Instead of taking NVU every time, we'll directly take the object's ownership every time: TUSVDU/VNCFSV

JNQM/VNCFS\

GOOFXOCV /VNCFS\

/VNCFSOC

^

GOBEENVUTFMGPUIFSV /VNCFS\

TFMGPUIFS

TFMG

^

GOTVCNVUTFMGPUIFSV /VNCFS\

TFMGPUIFS

TFMG

^

^

Then, there's no more need for the ending method: MFUOC/VNCFSOFXBEETVCBEE

BTTFSU@FROC

I generally prefer this way of doing builder patterns but it's more of a personal opinion than a thoughtful decision. Pick whichever seems to fit the best in your situation!

Code readability

We'll now talk about Rust's syntax itself. A few things can improve the code readability and are important to know. Let's start with big numbers.

Big number formatting

It's not uncommon to see huge constant numbers in code, such as this: MFUY

[ 418 ]





Rust Best Practices

Chapter 11

However, this is quite difficult to read for us (human brains aren't very efficient at parsing such numbers). In Rust, you can insert @ characters into numbers without any problem: MFUY@@@

A lot better, right?

Specifying types

The Rust compiler can automatically detect the type of a variable in most cases. However, for people reading the code, it's not always obvious what a code returns. An example? Sure!

MFUYBDPVDPVTQMJU

GJMUFS@NBQ]F]

FQBSTFV PL

GJMUFS]Y]Y

NBQ]T]GPSNBU\^T

DPMMFDU7FD@

KPJO

After reading the code carefully, you'll guess that Y is a 4USJOH. However, you needed to read all those closures to get it and even then, are you really sure of the type?

In such cases, it's strongly recommended to just add the type annotation: MFUY4USJOHBDPVDPVTQMJU

GJMUFS@NBQ]F]

FQBSTFV PL

GJMUFS]Y]Y

NBQ]T]GPSNBU\^T

DPMMFDU7FD@

KPJO

It doesn't cost much and allows readers (including you) to go through the code so much faster.

[ 419 ]





Rust Best Practices

Chapter 11

Matching

It's common to use pattern matching through NBUDI blocks in Rust. However, it's often a better solution to use JGMFU conditions. Let's take a simple example: FOVN4PNF&OVN\

0L

&SS

6OLOPXO

^

Now let's say you want to perform an action only when you get 0L. With a NBUDI, you would do this:

MFUY4PNF&OVN&SS

NBUDIY\

4PNF&OVN0L \

)VHFDPEFEPJOHBMPUPGUIJOHT

^

@ \^

^

Not really an issue, right? Now let's see it with an JGMFU: MFUY4PNF&OVN&SS

JGMFU4PNF&OVN0LY\

)VHFDPEFEPJOHBMPUPGUIJOHT

^

And that's it. It basically makes the code a little shorter, while improving readability a lot.

Whenever you just need to get one value, it's often a better solution to use JGMFU instead of NBUDI.

Summary

With this last chapter, you should have a good overview of good practices in Rust. Keep in mind that good code is easy to read and well commented. Even complex features can be a lot simpler to understand with well-made documentation.

[ 420 ]





Other Books You May Enjoy

If you enjoyed this book, you may be interested in these other books by Packt: Learning Rust

Paul Johnson, Vesa Kaihlavirta

ISBN: 978-1-78588-430-6

Set up Rust for Windows, Linux, and OS X

Write effective code using Rust

Expand your Rust applications using libraries

Interface existing non-Rust libraries with your Rust applications Use the standard library within your applications

Understand memory management within Rust and speed efficiency when passing variables

Create more complex data types

Study concurrency in Rust with multi-threaded applications and sync threading techniques to improve the performance of an application problem



Other Books You May Enjoy

Mastering Rust

Vesa Kaihlavirta

ISBN: 978-1-78588-530-3

Implement unit testing patterns with the standard Rust tools Get to know the different philosophies of error handling and how to use them wisely

Appreciate Rust's ability to solve memory allocation problems safely without garbage collection

Get to know how concurrency works in Rust and use concurrency primitives such as threads and message passing

Use syntax extensions and write your own

Create a Web application with Rocket

Use Diesel to build safe database abstractions

[ 422 ]

Other Books You May Enjoy

Leave a review - let other readers know what

you think

Please share your thoughts on this book with others by leaving a review on the site that you bought it from. If you purchased the book from Amazon, please leave us an honest review on this book's Amazon page. This is vital so that other potential readers can see and use your unbiased opinion to make purchasing decisions, we can understand what our customers think about our products, and our authors can see your feedback on the title that they have worked with Packt to create. It will only take a few minutes of your time, but is valuable to other potential customers, our authors, and Packt. Thank you!

[ 423 ]





Index

A

Cargo.toml file

child widget

API tips, Rust

adding ,

Path function, using

dialogs

some function, explaining

methods

application

one-way data binding

improving

post-initialization of view , ,

arrays

chunks of commands

about

basics ,

for loops

implementation ,

slices

clients

asynchronous IO

handling

advantages

code blocks

disadvantages

code readability, Rust

asynchronous user interface

big number formatting

B

matching

types, specifying

binary project

commands implementation

creating , ,

about

builder pattern

CDUP command, implementation

about

CWD command, implementation

moves, playing

LIST command, implementation ,

mutable borrows, playing

MKD command, implementation

built-in data types

NOOP command, implementation

about

PWD command, implementation

Boolean type

RMD command, implementation

character type

SYST command, implementation

floating-point types

TYPE command, implementation

integer types

USER command, implementation

bytes codec

commands

about

handling ,

data bytes, decoding

config.toml access

data bytes, encoding

securing

configuration , , , , ,

C

containers

cargo

about

box container

types

features, playing

control flow

images, loading

about

images, playing

condition, writing

options, playing

copy types

solution

mutable references

while loops, creating

E

cover

enumeration

displaying

about

CPU usage

documenting

condition variable

error handling

improving

about

crate

error type

documenting

unwrapping

reference link

error type

current directory

? operator, revisited

changing , ,

about

managing

composing

printing

displaying

custom widgets

error, displaying

creating

event loop

D

about

atomic reference counting

dependencies

lock-free data structures

installing

mutual exclusion

installing, on Linux

Resource Acquisition Is Initialization (RAII)

installing, on Mac

send trait

installing, on Windows

sync trait

dialogs

directories

F

creating

file

removing

downloading ,

doc blocks

formatted data, reading

about

handling

code blocks lines, hiding

high scores, loading

docs.rs documentation

high scores, saving

about

iterators

Cargo.toml file

listing , , ,

documentation

opening, with file dialog

about

uploading ,

generating

fonts

tags

installing, on Linux

testing

installing, on OS X

drawing

loading , , ,

about

[ 425 ]

system/package manager

SDL2_image, installing on Linux

FTP

SDL2_image, installing on Mac

FTP codec

integration tests

FTP commands

about

decoding

output, printing to stdout

encoding

teardown ,

FTP protocol

interior mutability , , , ,

about

irrefutable patterns

chunks of commands, implementation

items

commands implementation

hiding, from documentation

testing

iterators

functions

creating

L

futures

level ,

using

lines sent ,

G

LIST command

game map

M

interacting , ,

macros

game mechanisms

about

about

multiple pattern rules

fonts

repetitions

rendering UI

messages

generics

methods

about

about ,

option type

constructors

gstreamer

model

used, for playback , ,

model parameter , , ,

GTK+

module

installing, on Linux

documenting

installing, on Mac

MP3 decoder

installing, on Windows

implementing , ,

H

MP3 files

decoding

headers

dependencies, adding

high scores

frame samples

loading ,

opening

overwriting

Multiple-Producers-Single-Consumer (MPSC)

saving

music player

using

I



music

ID3

event loop

MP3 metadata

mutex guard

images

playing , , , , , ,

[ 426 ]

MVC pattern

Rust nightly, installing

state mutation

O



used, instead of gtk-rs directly

one-way data binding

used, on stable Rust

window, creating

P

rendering

rendering initialization

passive mode

, ,

repetitions, macros

bytes codec

optional quantifier

entering



, ,

Rust crates

PASV command



Rust nightly

implementation

installing

pattern matching



Rust project

about

cargo

irrefutable patterns





crates.io

playlist



docs.rs documentation

about





setting up

adding





Rust's modules

loading



, ,

Rust

model parameter , , ,

about

MVC pattern





API tips

saving





best practices

post-initialization of view



, ,

code readability

prerequisite



improvements

GTK+, installing on Linux





installation, testing

GTK+, installing on Mac





installing

GTK+, installing on Windows





Linux/Mac

installing





main function

public items



references

warning, without documentation





slices

Q

usage tips

variables

quitting

Windows

R

S

reference-counting pointer

score

references

SDL events , , , ,

about ,

SDL2

clone types

installing

relm widget

installing, on Linux

adding

installing, on Windows

data binding ,

Windows (MinGW)

relm

Windows (MSVC)

asynchronous user interface

Windows, with Build

custom widgets, creating

SDL2_image

[ 427 ]

installing, on Windows

adding

Semantic Versioning (SemVer)

lifetime , ,

server

ownership

about

toolbar

clients, handling

creating

commands, handling

stock item

FTP codec

traits

slices

about

song duration

associated types

computing ,

default methods

song

rules

current time, displaying , ,

transfer type

deleting

setting

pausing

tuples

progression, displaying ,

resuming

U

stable Rust

unit tests

relm, used

about ,

state mutation

backtraces

structures

failures, testing

creating

tests, ignoring ,

T

unwrapping

usage tips, Rust

tags, documentation

builder pattern

compile_fail

flags, combining

V

ignore

view

no_run

about

should_panic

code generation

tests

events

fuzzing , ,

properties

tetrimino

about , ,

W

creating , , , ,

widget

generating ,

about

rotating , ,

communicating

tetris

emit

tetris struct , , ,

message, sending to relm widget

Tetris

messages

writing

messages, handling from relm widget

Tokio event loop

method

Tokio

model

event loop

update function

using

view

tool button events

[ 428 ]

widgets

window

communicating

creating

Window

Window

creating ,

creating, with relm

default behavior, preventing of an event





Document Outline


Cover

Copyright and Credits

Packt Upsell

Contributors

Table of Contents

Preface

Chapter 1: Basics of Rust Getting to know Rust Installing Rust Windows

Linux/Mac

Test your installation





Documentation and reference

Main function Variables





Built-in data types Integer types

Floating-point types

Boolean type

Character type





Control flow Writing a condition

Creating while loops





Creating functions

Creating structures

References Clone types

Copy types

Mutable references





Methods Constructors





Tuples

Enumerations

Pattern matching Irrefutable patterns





Traits Default methods

Associated types

Rules





Generics The Option type





Arrays Slices

For loops





Macros Multiple pattern rules

Repetitions Optional quantifier





Summary





Chapter 2: Starting with SDL Understanding Rust crates

Installing SDL2 Installing SDL2 on Linux

Installing SDL2 on Mac

Installing SDL2 on Windows Windows with Build Script

Windows (MinGW)

Windows (MSVC)





Setting up your Rust project Cargo and crates.io

The docs.rs documentation Back to our Cargo.toml file





Rust's modules

Tetris

Creating a window

Drawing Playing with Options

Solution

Loading images Installing SDL2_image on Mac

Installing SDL2_image on Linux

Installing SDL2_image on Windows





Playing with features

Playing with images





Handling files Saving/loading high scores

Iterators

Reading formatted data from files





Summary





Chapter 3: Events and Basic Game Mechanisms Writing Tetris Tetrimino

Creating tetriminos

Generating a tetrimino Rotating a tetrimino





Tetris struct

Interacting with the game map

SDL events

Score, level, lines sent Levels and lines sent

Highscores loading/overwriting





Summary





Chapter 4: Adding All Game Mechanisms Getting started with game mechanisms Rendering UI Rendering initialization

Rendering





Playing with fonts Install on OS X

Install on Linux

Other system/package manager





Loading font





Summary





Chapter 5: Creating a Music Player Installing the prerequisite Installing GTK+ on Linux

Installing GTK+ on Mac

Installing GTK+ on Windows





Creating your first window Closure

Preventing the default behavior of an event





Creating a toolbar Stock item





Improving the organization of the application

Adding tool button events Lifetime

Ownership





Containers Types of containers

The Box container





Adding a playlist The MVC pattern





Opening MP3 files Reference-counting pointer

ID3â€” MP3 metadata

Opening files with a file dialog

Deleting a song

Displaying the cover when playing a song





Summary





Chapter 6: Implementing the Engine of the Music Player Installing the dependencies Installing dependencies on Linux

Installing dependencies on Mac

Installing dependencies on Windows





Decoding MP3 files Adding dependencies

Implementing an MP3 decoder

Getting the frame samples





Playing music Event loop Atomic reference counting

Mutual exclusion

Send trait

Sync trait

Lock-free data structures





Playing music Mutex guard

RAII





Using the music player





Pausing and resuming the song Interior mutability





Showing the progression of the song

Improving CPU usage Condition variable





Showing the song's current time

Loading and saving the playlist Saving a playlist

Loading a playlist





Using gstreamer for playback

Summary





Chapter 7: Music Player in a More Rusty Way with Relm Reasons to use relm instead of gtk-rs directly State mutation

Asynchronous user interface

Creating custom widgets





Creating a window with relm Installing Rust nightly





Widget Model

Messages

View Properties

Events

Code generation





Update function





Adding child widgets One-way data binding

Post-initialization of the view

Dialogs

Other methods





Playlist Model parameter





Adding a relm widget

Communicating between widgets Communicating with the same widget

Emit

With different widgets Handle messages from a relm widget

Syntax sugar to send a message to another relm widget





Playing music

Computing the song duration

Using relm on stable Rust

Relm widgets data binding

Summary





Chapter 8: Understanding FTP File transfer protocol Introduction to FTP

Implementing simple chunks of commands Starting with basics





Commands implementation Implementing the SYST command

Implementing the USER command

Implementing the NOOP command

Implementing the PWD command

Implementing the TYPE command

Implementing the LIST command Implementing the PASV command

Back to the LIST command





Implementing the CWD command

Implementing the CDUP command

Full implementation of the LIST command

Implementing the MKD command

Implementing the RMD command





Testing it





Summary





Chapter 9: Implementing an Asynchronous FTP Server Advantages of asynchronous IO

Disadvantages of asynchronous IO

Creating the new project

Using Tokio Tokio event loop





Using futures

Handling errors Unwrapping

Custom error type Displaying the error

Composing error types

The ? operator, revisited





Starting the Tokio event loop

Starting the server Handling clients

Handling commands

FTP codec Decoding FTP commands

Encoding FTP commands





Handling commands

Managing the current working directory Printing the current directory

Changing the current directory





Setting the transfer type

Entering passive mode Bytes codec Decoding data bytes

Encoding data bytes





Quitting

Creating directories

Removing directories

Summary





Chapter 10: Implementing Asynchronous File Transfer Listing files

Downloading a file

Uploading files

Going further! Configuration

Securing the config.toml access





Unit tests Backtraces

Testing failures

Ignoring tests





Integration tests Teardown

Print output to stdout





Documentation Documenting a crate

Documenting a module

Headers

Code blocks

Documenting an enumeration (or any type with public fields)

Generating the documentation

Warning about public items without documentation

Hiding items from the documentation





Documentation tests Tags ignore

compile_fail

no_run

should_panic

Combining flags?





About the doc blocks themselves Hiding code blocks lines





Fuzzing tests

Summary





Chapter 11: Rust Best Practices Rust best practices Slices

API tips and improvements Explaining the Some function

Using the Path function





Usage tips Builder pattern Playing with mutable borrows

Playing with moves





Code readability Big number formatting

Specifying types

Matching





Summary





Chapter 12: Other Books You May Enjoy

Index





